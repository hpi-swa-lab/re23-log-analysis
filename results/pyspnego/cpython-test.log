.package create: /workdir/pyspnego-0.9.1/.tox/.package
.package installdeps: Cython >= 0.29.29, < 3.0.0; sys_platform == 'win32', setuptools >= 61.0.0
/workdir/pyspnego-0.9.1/.tox/.package/lib/python3.10/site-packages/setuptools/config/pyprojecttoml.py:104: _BetaConfiguration: Support for `[tool.setuptools]` in `pyproject.toml` is still *beta*.
  warnings.warn(msg, _BetaConfiguration)
warning: no previously-included files found matching '.coverage'
warning: no previously-included files found matching '.gitignore'
warning: no previously-included files found matching '.pre-commit-config.yaml'
warning: no previously-included files matching '*.c' found under directory 'src/spnego'
warning: no previously-included files matching '*.pyc' found under directory 'tests'
/workdir/pyspnego-0.9.1/.tox/.package/lib/python3.10/site-packages/setuptools/config/pyprojecttoml.py:104: _BetaConfiguration: Support for `[tool.setuptools]` in `pyproject.toml` is still *beta*.
  warnings.warn(msg, _BetaConfiguration)
warning: no previously-included files found matching '.coverage'
warning: no previously-included files found matching '.gitignore'
warning: no previously-included files found matching '.pre-commit-config.yaml'
warning: no previously-included files matching '*.c' found under directory 'src/spnego'
warning: no previously-included files matching '*.pyc' found under directory 'tests'
warning: check: missing required meta-data: url

warning: check: missing meta-data: either (author and author_email) or (maintainer and maintainer_email) should be supplied

cpythonlibtest-unit-test-tests create: /workdir/pyspnego-0.9.1/.tox/cpythonlibtest-unit-test-tests
cpythonlibtest-unit-test-tests installdeps: -r/workdir/pyspnego-0.9.1/requirements-test.txt
cpythonlibtest-unit-test-tests inst: /workdir/pyspnego-0.9.1/.tox/.tmp/package/1/pyspnego-0.9.1.tar.gz
cpythonlibtest-unit-test-tests installed: black==22.10.0,cffi==1.16.0,cfgv==3.4.0,click==8.1.7,coverage==7.3.2,cryptography==41.0.7,decorator==5.1.1,distlib==0.3.7,exceptiongroup==1.2.0,filelock==3.13.1,gssapi==1.8.3,identify==2.5.32,iniconfig==2.0.0,isort==5.10.1,k5test==0.10.3,krb5==0.5.1,mypy==0.982,mypy-extensions==1.0.0,nodeenv==1.8.0,packaging==23.2,pathspec==0.11.2,platformdirs==4.0.0,pluggy==1.3.0,pre-commit==3.5.0,pycparser==2.21,pyspnego @ file:///workdir/pyspnego-0.9.1/.tox/.tmp/package/1/pyspnego-0.9.1.tar.gz#sha256=3df1b0f562739c0767e168802ee55c0f9cd0fa31588c6bd05dc4bfae9575f3d1,pytest==7.4.3,pytest-cov==4.1.0,pytest-mock==3.12.0,PyYAML==6.0.1,ruamel.yaml==0.18.5,ruamel.yaml.clib==0.2.8,tomli==2.0.1,types-cryptography==3.3.23.2,typing_extensions==4.8.0,virtualenv==20.24.7
cpythonlibtest-unit-test-tests run-test-pre: PYTHONHASHSEED='1936669122'
cpythonlibtest-unit-test-tests run-test: commands[0] | python -m pytest -v --cov spnego --cov-report term-missing
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0 -- /workdir/pyspnego-0.9.1/.tox/cpythonlibtest-unit-test-tests/bin/python
cachedir: .tox/cpythonlibtest-unit-test-tests/.pytest_cache
rootdir: /workdir/pyspnego-0.9.1
configfile: pyproject.toml
testpaths: tests
plugins: mock-3.12.0, cov-4.1.0
collecting ... collected 672 items

tests/test_asn1.py::test_tag_class_native_labels PASSED                  [  0%]
tests/test_asn1.py::test_type_tag_number_native_labels PASSED            [  0%]
tests/test_asn1.py::test_extract_asn1_tlv[value0-TagClass.universal-TypeTagNumber.octet_string-\x00\x01] PASSED [  0%]
tests/test_asn1.py::test_extract_asn1_tlv[\x00\x01-TagClass.universal-TypeTagNumber.octet_string-\x00\x01] PASSED [  0%]
tests/test_asn1.py::test_extract_asn1_tlv[value2-TagClass.application-1023-\x00] PASSED [  0%]
tests/test_asn1.py::test_extract_asn1_tlv_invalid_universal_class PASSED [  0%]
tests/test_asn1.py::test_extract_asn1_invalid_other_class PASSED         [  1%]
tests/test_asn1.py::test_get_sequence_value PASSED                       [  1%]
tests/test_asn1.py::test_get_sequence_value_raw PASSED                   [  1%]
tests/test_asn1.py::test_get_sequence_value_no_tag PASSED                [  1%]
tests/test_asn1.py::test_get_sequence_value_failure_with_field_name PASSED [  1%]
tests/test_asn1.py::test_get_sequence_value_failure_without_field_name PASSED [  1%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00-\x04\x01\x00] PASSED [  1%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.universal-True-TypeTagNumber.octet_string-\x00\x00-$\x02\x00\x00] PASSED [  2%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.application-True-1024-\x00\x00-\x7f\x88\x00\x02\x00\x00] PASSED [  2%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.application-True-1048576-\x00\x00-\x7f\xc0\x80\x00\x02\x00\x00] PASSED [  2%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x04\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00] PASSED [  2%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x04\x81\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00] PASSED [  2%]
tests/test_asn1.py::test_pack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x04\x82\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00] PASSED [  2%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00-\x04\x01\x00] PASSED [  2%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.universal-True-TypeTagNumber.octet_string-\x00\x00-$\x02\x00\x00] PASSED [  3%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.application-True-1024-\x00\x00-\x7f\x88\x00\x02\x00\x00] PASSED [  3%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.application-True-1048576-\x00\x00-\x7f\xc0\x80\x00\x02\x00\x00] PASSED [  3%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x04\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00] PASSED [  3%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x04\x81\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00] PASSED [  3%]
tests/test_asn1.py::test_unpack_asn1_tlv[TagClass.universal-False-TypeTagNumber.octet_string-\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-\x04\x82\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00] PASSED [  3%]
tests/test_asn1.py::test_unpack_asn1_tlv_remaining_data PASSED           [  4%]
tests/test_asn1.py::test_pack_asn1_tlv_invalid_class PASSED              [  4%]
tests/test_asn1.py::test_pack_asn1_bit_string PASSED                     [  4%]
tests/test_asn1.py::test_unpack_asn1_bit_string[\x03\x03\x00\x01\x01-\x01\x01] PASSED [  4%]
tests/test_asn1.py::test_unpack_asn1_bit_string[\x03\x03\x01\x01\x01-\x01\x00] PASSED [  4%]
tests/test_asn1.py::test_pack_asn1_general_string PASSED                 [  4%]
tests/test_asn1.py::test_pack_asn1_enumerated PASSED                     [  4%]
tests/test_asn1.py::test_unpack_asn1_enumerated PASSED                   [  5%]
tests/test_asn1.py::test_pack_asn1_general_string_encoding PASSED        [  5%]
tests/test_asn1.py::test_unpack_asn1_general_string PASSED               [  5%]
tests/test_asn1.py::test_pack_asn1_integer[-748591-\x02\x03\xf4\x93\xd1] PASSED [  5%]
tests/test_asn1.py::test_pack_asn1_integer[-32769-\x02\x03\xff\x7f\xff] PASSED [  5%]
tests/test_asn1.py::test_pack_asn1_integer[-32768-\x02\x02\x80\x00] PASSED [  5%]
tests/test_asn1.py::test_pack_asn1_integer[-32767-\x02\x02\x80\x01] PASSED [  5%]
tests/test_asn1.py::test_pack_asn1_integer[-257-\x02\x02\xfe\xff] PASSED [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-256-\x02\x02\xff\x00] PASSED [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-255-\x02\x02\xff\x01] PASSED [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-129-\x02\x02\xff\x7f] PASSED [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-128-\x02\x01\x80] PASSED     [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-127-\x02\x01\x81] PASSED     [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-17-\x02\x01\xef] PASSED      [  6%]
tests/test_asn1.py::test_pack_asn1_integer[-16-\x02\x01\xf0] PASSED      [  7%]
tests/test_asn1.py::test_pack_asn1_integer[-10-\x02\x01\xf6] PASSED      [  7%]
tests/test_asn1.py::test_pack_asn1_integer[-1-\x02\x01\xff] PASSED       [  7%]
tests/test_asn1.py::test_pack_asn1_integer[0-\x02\x01\x00] PASSED        [  7%]
tests/test_asn1.py::test_pack_asn1_integer[1-\x02\x01\x01] PASSED        [  7%]
tests/test_asn1.py::test_pack_asn1_integer[10-\x02\x01\n] PASSED         [  7%]
tests/test_asn1.py::test_pack_asn1_integer[16-\x02\x01\x10] PASSED       [  8%]
tests/test_asn1.py::test_pack_asn1_integer[17-\x02\x01\x11] PASSED       [  8%]
tests/test_asn1.py::test_pack_asn1_integer[127-\x02\x01\x7f] PASSED      [  8%]
tests/test_asn1.py::test_pack_asn1_integer[128-\x02\x02\x00\x80] PASSED  [  8%]
tests/test_asn1.py::test_pack_asn1_integer[129-\x02\x02\x00\x81] PASSED  [  8%]
tests/test_asn1.py::test_pack_asn1_integer[255-\x02\x02\x00\xff] PASSED  [  8%]
tests/test_asn1.py::test_pack_asn1_integer[256-\x02\x02\x01\x00] PASSED  [  8%]
tests/test_asn1.py::test_pack_asn1_integer[257-\x02\x02\x01\x01] PASSED  [  9%]
tests/test_asn1.py::test_pack_asn1_integer[32767-\x02\x02\x7f\xff] PASSED [  9%]
tests/test_asn1.py::test_pack_asn1_integer[32768-\x02\x03\x00\x80\x00] PASSED [  9%]
tests/test_asn1.py::test_pack_asn1_integer[32769-\x02\x03\x00\x80\x01] PASSED [  9%]
tests/test_asn1.py::test_pack_asn1_integer[748591-\x02\x03\x0bl/] PASSED [  9%]
tests/test_asn1.py::test_unpack_asn1_integer[-748591-\x02\x03\xf4\x93\xd1] PASSED [  9%]
tests/test_asn1.py::test_unpack_asn1_integer[-32769-\x02\x03\xff\x7f\xff] PASSED [  9%]
tests/test_asn1.py::test_unpack_asn1_integer[-32768-\x02\x02\x80\x00] PASSED [ 10%]
tests/test_asn1.py::test_unpack_asn1_integer[-32767-\x02\x02\x80\x01] PASSED [ 10%]
tests/test_asn1.py::test_unpack_asn1_integer[-257-\x02\x02\xfe\xff] PASSED [ 10%]
tests/test_asn1.py::test_unpack_asn1_integer[-256-\x02\x02\xff\x00] PASSED [ 10%]
tests/test_asn1.py::test_unpack_asn1_integer[-255-\x02\x02\xff\x01] PASSED [ 10%]
tests/test_asn1.py::test_unpack_asn1_integer[-129-\x02\x02\xff\x7f] PASSED [ 10%]
tests/test_asn1.py::test_unpack_asn1_integer[-128-\x02\x01\x80] PASSED   [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[-127-\x02\x01\x81] PASSED   [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[-17-\x02\x01\xef] PASSED    [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[-16-\x02\x01\xf0] PASSED    [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[-10-\x02\x01\xf6] PASSED    [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[-1-\x02\x01\xff] PASSED     [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[0-\x02\x01\x00] PASSED      [ 11%]
tests/test_asn1.py::test_unpack_asn1_integer[1-\x02\x01\x01] PASSED      [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[10-\x02\x01\n] PASSED       [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[16-\x02\x01\x10] PASSED     [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[17-\x02\x01\x11] PASSED     [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[127-\x02\x01\x7f] PASSED    [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[128-\x02\x02\x00\x80] PASSED [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[129-\x02\x02\x00\x81] PASSED [ 12%]
tests/test_asn1.py::test_unpack_asn1_integer[255-\x02\x02\x00\xff] PASSED [ 13%]
tests/test_asn1.py::test_unpack_asn1_integer[256-\x02\x02\x01\x00] PASSED [ 13%]
tests/test_asn1.py::test_unpack_asn1_integer[257-\x02\x02\x01\x01] PASSED [ 13%]
tests/test_asn1.py::test_unpack_asn1_integer[32767-\x02\x02\x7f\xff] PASSED [ 13%]
tests/test_asn1.py::test_unpack_asn1_integer[32768-\x02\x03\x00\x80\x00] PASSED [ 13%]
tests/test_asn1.py::test_unpack_asn1_integer[32769-\x02\x03\x00\x80\x01] PASSED [ 13%]
tests/test_asn1.py::test_unpack_asn1_integer[748591-\x02\x03\x0bl/] PASSED [ 13%]
tests/test_asn1.py::test_pack_object_identifier[1.2-\x06\x01*] PASSED    [ 14%]
tests/test_asn1.py::test_pack_object_identifier[1.2.3-\x06\x02*\x03] PASSED [ 14%]
tests/test_asn1.py::test_pack_object_identifier[1.2.3.1024.2-\x06\x05*\x03\x88\x00\x02] PASSED [ 14%]
tests/test_asn1.py::test_pack_object_identifier_invalid_value PASSED     [ 14%]
tests/test_asn1.py::test_unpack_object_identifier[1.2-\x06\x01*] PASSED  [ 14%]
tests/test_asn1.py::test_unpack_object_identifier[1.2.3-\x06\x02*\x03] PASSED [ 14%]
tests/test_asn1.py::test_unpack_object_identifier[1.2.3.1024.2-\x06\x05*\x03\x88\x00\x02] PASSED [ 15%]
tests/test_asn1.py::test_pack_asn1_sequence PASSED                       [ 15%]
tests/test_asn1.py::test_unpack_asn1_sequence PASSED                     [ 15%]
tests/test_asn1.py::test_pack_asn1_octet_string PASSED                   [ 15%]
tests/test_asn1.py::test_unpack_asn1_octet_string PASSED                 [ 15%]
tests/test_asn1.py::test_unpack_asn1_boolean[\x00-False] PASSED          [ 15%]
tests/test_asn1.py::test_unpack_asn1_boolean[\x01-True] PASSED           [ 15%]
tests/test_asn1.py::test_unpack_asn1_boolean[\x02-True] PASSED           [ 16%]
tests/test_asn1.py::test_unpack_asn1_generalized_time[19700101000000Z] PASSED [ 16%]
tests/test_asn1.py::test_unpack_asn1_generalized_time[19700101000000.000000Z] PASSED [ 16%]
tests/test_asn1.py::test_unpack_asn1_generalized_time_format_err PASSED  [ 16%]
tests/test_auth.py::test_invalid_protocol PASSED                         [ 16%]
tests/test_auth.py::test_protocol_not_supported PASSED                   [ 16%]
tests/test_auth.py::test_no_valid_credential_available_single_available_protocol PASSED [ 16%]
tests/test_auth.py::test_no_valid_credential_available_multiple_available_protocol PASSED [ 17%]
tests/test_auth.py::test_negotiate_with_kerberos ERROR                   [ 17%]
tests/test_auth.py::test_negotiate_with_kerberos_no_integrity ERROR      [ 17%]
tests/test_auth.py::test_negotiate_through_python_ntlm PASSED            [ 17%]
tests/test_auth.py::test_negotiate_with_raw_ntlm PASSED                  [ 17%]
tests/test_auth.py::test_negotiate_with_ntlm_hash PASSED                 [ 17%]
tests/test_auth.py::test_negotiate_with_ntlm_and_duplicate_response_token PASSED [ 18%]
tests/test_auth.py::test_ntlm_auth[None] PASSED                          [ 18%]
tests/test_auth.py::test_ntlm_auth[0] PASSED                             [ 18%]
tests/test_auth.py::test_ntlm_auth[1] PASSED                             [ 18%]
tests/test_auth.py::test_ntlm_auth[2] PASSED                             [ 18%]
tests/test_auth.py::test_sspi_ntlm_auth_no_sign_or_seal[NegotiateOptions.use_sspi-NegotiateOptions.use_sspi] SKIPPED [ 18%]
tests/test_auth.py::test_sspi_ntlm_auth_no_sign_or_seal[NegotiateOptions.use_ntlm-NegotiateOptions.use_sspi] SKIPPED [ 18%]
tests/test_auth.py::test_sspi_ntlm_auth_no_sign_or_seal[NegotiateOptions.use_sspi-NegotiateOptions.use_ntlm] SKIPPED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth_no_sign_or_seal[NegotiateOptions.use_ntlm-NegotiateOptions.use_ntlm] PASSED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_sspi-False-False] SKIPPED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_sspi-True-False] SKIPPED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_sspi-True-True] SKIPPED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_ntlm-NegotiateOptions.use_sspi-False-False] SKIPPED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_ntlm-NegotiateOptions.use_sspi-True-False] SKIPPED [ 19%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_ntlm-NegotiateOptions.use_sspi-True-True] SKIPPED [ 20%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_ntlm-False-False] SKIPPED [ 20%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_ntlm-True-False0] SKIPPED [ 20%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_ntlm-True-False1] SKIPPED [ 20%]
tests/test_auth.py::test_sspi_ntlm_auth[NegotiateOptions.use_sspi-NegotiateOptions.use_ntlm-True-True] SKIPPED [ 20%]
tests/test_auth.py::test_sspi_ntlm_lm_compat[1] SKIPPED (Test requir...) [ 20%]
tests/test_auth.py::test_sspi_ntlm_lm_compat[2] SKIPPED (Test requir...) [ 20%]
tests/test_auth.py::test_sspi_ntlm_lm_compat[3] SKIPPED (Test requir...) [ 21%]
tests/test_auth.py::test_ntlm_with_explicit_ntlm_hash PASSED             [ 21%]
tests/test_auth.py::test_ntlm_with_unsupported_credential PASSED         [ 21%]
tests/test_auth.py::test_gssapi_kerberos_auth[False] ERROR               [ 21%]
tests/test_auth.py::test_gssapi_kerberos_auth[True] ERROR                [ 21%]
tests/test_auth.py::test_gssapi_kerberos_auth_no_integrity[False] ERROR  [ 21%]
tests/test_auth.py::test_gssapi_kerberos_auth_no_integrity[True] ERROR   [ 22%]
tests/test_auth.py::test_gssapi_kerberos_auth_explicit_cred[False] ERROR [ 22%]
tests/test_auth.py::test_gssapi_kerberos_auth_explicit_cred[True] ERROR  [ 22%]
tests/test_auth.py::test_kerberos_auth_keytab[kerberos-False] ERROR      [ 22%]
tests/test_auth.py::test_kerberos_auth_keytab[kerberos-True] ERROR       [ 22%]
tests/test_auth.py::test_kerberos_auth_keytab[negotiate-False] ERROR     [ 22%]
tests/test_auth.py::test_kerberos_auth_keytab[negotiate-True] ERROR      [ 22%]
tests/test_auth.py::test_kerberos_auth_ccache[kerberos-False] ERROR      [ 23%]
tests/test_auth.py::test_kerberos_auth_ccache[kerberos-True0] ERROR      [ 23%]
tests/test_auth.py::test_kerberos_auth_ccache[negotiate-False] ERROR     [ 23%]
tests/test_auth.py::test_kerberos_auth_ccache[kerberos-True1] ERROR      [ 23%]
tests/test_auth.py::test_kerberos_auth_env_cache[kerberos-False] ERROR   [ 23%]
tests/test_auth.py::test_kerberos_auth_env_cache[kerberos-True0] ERROR   [ 23%]
tests/test_auth.py::test_kerberos_auth_env_cache[negotiate-False] ERROR  [ 23%]
tests/test_auth.py::test_kerberos_auth_env_cache[kerberos-True1] ERROR   [ 24%]
tests/test_auth.py::test_kerberos_auth_channel_bindings[kerberos-False] ERROR [ 24%]
tests/test_auth.py::test_kerberos_auth_channel_bindings[kerberos-True] ERROR [ 24%]
tests/test_auth.py::test_kerberos_auth_channel_bindings[negotiate-False] ERROR [ 24%]
tests/test_auth.py::test_kerberos_auth_channel_bindings[negotiate-True] ERROR [ 24%]
tests/test_auth.py::test_credssp_ntlm_creds[NegotiateOptions.use_negotiate-False-None] PASSED [ 24%]
tests/test_auth.py::test_credssp_ntlm_creds[NegotiateOptions.use_negotiate-False-2] PASSED [ 25%]
tests/test_auth.py::test_credssp_ntlm_creds[NegotiateOptions.use_negotiate-True-None] PASSED [ 25%]
tests/test_auth.py::test_credssp_ntlm_creds[NegotiateOptions.use_ntlm-False-None] PASSED [ 25%]
tests/test_auth.py::test_credssp_ntlm_creds[NegotiateOptions.use_ntlm-False-5] PASSED [ 25%]
tests/test_auth.py::test_credssp_ntlm_creds[NegotiateOptions.use_ntlm-True-None] PASSED [ 25%]
tests/test_auth.py::test_credssp_kerberos_creds[False] ERROR             [ 25%]
tests/test_auth.py::test_credssp_kerberos_creds[True] ERROR              [ 25%]
tests/test_auth.py::test_credssp_multiple_creds PASSED                   [ 26%]
tests/test_auth.py::test_credssp_min_protocol_failure_initiator PASSED   [ 26%]
tests/test_auth.py::test_credssp_min_protocol_failure_acceptor PASSED    [ 26%]
tests/test_auth_dce.py::test_kerberos[negotiate] ERROR                   [ 26%]
tests/test_auth_dce.py::test_kerberos[kerberos] ERROR                    [ 26%]
tests/test_auth_dce.py::test_ntlm[negotiate] PASSED                      [ 26%]
tests/test_auth_dce.py::test_ntlm[ntlm] PASSED                           [ 26%]
tests/test_channel_bindings.py::test_channel_bindings_pack PASSED        [ 27%]
tests/test_channel_bindings.py::test_channel_bindings_none_pack PASSED   [ 27%]
tests/test_channel_bindings.py::test_channel_bindings_unpack PASSED      [ 27%]
tests/test_channel_bindings.py::test_channel_bindings_str PASSED         [ 27%]
tests/test_channel_bindings.py::test_channel_bindings_repr PASSED        [ 27%]
tests/test_channel_bindings.py::test_channel_bindings_eq PASSED          [ 27%]
tests/test_context.py::test_split_username[None-None-None] PASSED        [ 27%]
tests/test_context.py::test_split_username[username-None-username] PASSED [ 28%]
tests/test_context.py::test_split_username[domain\\username-domain-username] PASSED [ 28%]
tests/test_context.py::test_split_username[domain\\username\\part-domain-username\\part] PASSED [ 28%]
tests/test_context.py::test_split_username[username@domain-None-username@domain] PASSED [ 28%]
tests/test_context.py::test_gss_mech_common_name[1.3.6.1.4.1.311.2.2.10-ntlm] PASSED [ 28%]
tests/test_context.py::test_gss_mech_common_name[1.3.6.1.5.5.2-spnego] PASSED [ 28%]
tests/test_context.py::test_gss_mech_common_name[1.2.840.113554.1.2.2-kerberos] PASSED [ 29%]
tests/test_context.py::test_gss_mech_common_name[1.2.840.48018.1.2.2-kerberos] PASSED [ 29%]
tests/test_context.py::test_gss_mech_common_name[1.3.5.1.5.2-kerberos] PASSED [ 29%]
tests/test_context.py::test_gss_mech_common_name[1.3.6.1.5.2-kerberos] PASSED [ 29%]
tests/test_context.py::test_gss_mech_is_kerberos_oid[1.3.6.1.4.1.311.2.2.10-False] PASSED [ 29%]
tests/test_context.py::test_gss_mech_is_kerberos_oid[1.3.6.1.5.5.2-False] PASSED [ 29%]
tests/test_context.py::test_gss_mech_is_kerberos_oid[1.2.840.113554.1.2.2-True] PASSED [ 29%]
tests/test_context.py::test_gss_mech_is_kerberos_oid[1.2.840.48018.1.2.2-True] PASSED [ 30%]
tests/test_context.py::test_gss_mech_is_kerberos_oid[1.3.5.1.5.2-True] PASSED [ 30%]
tests/test_context.py::test_gss_mech_is_kerberos_oid[1.3.6.1.5.2-True] PASSED [ 30%]
tests/test_context.py::test_gss_mech_from_oid[1.3.6.1.4.1.311.2.2.10-1.3.6.1.4.1.311.2.2.10] PASSED [ 30%]
tests/test_context.py::test_gss_mech_from_oid[1.3.6.1.5.5.2-1.3.6.1.5.5.2] PASSED [ 30%]
tests/test_context.py::test_gss_mech_from_oid[1.2.840.113554.1.2.2-1.2.840.113554.1.2.2] PASSED [ 30%]
tests/test_context.py::test_gss_mech_from_oid[1.2.840.48018.1.2.2-1.2.840.48018.1.2.2] PASSED [ 30%]
tests/test_context.py::test_gss_mech_from_oid_invalid PASSED             [ 31%]
tests/test_credssp.py::test_pub_key_auth[\x00\x01-initiate-None] PASSED  [ 31%]
tests/test_credssp.py::test_pub_key_auth[E\x90\xc2l\x83}\xac\xdf=\xa8\xfa\xe5x&M\x9eEHj\xfc9Q\xf2\x1e\xf3W\x06L\xd5_\xbb\xb5-initiate-\x00\x00] PASSED [ 31%]
tests/test_credssp.py::test_pub_key_auth[\x01\x01-accept-None] PASSED    [ 31%]
tests/test_credssp.py::test_pub_key_auth[\xcd\xf4\xff\xeel\xb69^[i,-\xa3\x978oj\x1e\xab-:bq\x81j\x04\xc7\xa2\x91M3?-accept-\x00\x00] PASSED [ 31%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.3-TLS_AES_128_GCM_SHA256-17] PASSED [ 31%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.3-TLS_AES_256_GCM_SHA384-17] PASSED [ 31%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.2-ECDHE-RSA-AES128-GCM-SHA256-16] PASSED [ 32%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.2-RC4-MD5-16] PASSED [ 32%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.2-ECDH-ECDSA-3DES-SHA256-34] PASSED [ 32%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.2-ECDH-RSA-AES-SHA384-50] PASSED [ 32%]
tests/test_credssp.py::test_get_credssp_trailer_length[TLSv1.2-ECDH-RSA-AES-2] PASSED [ 32%]
tests/test_credssp.py::test_credssp_no_iov PASSED                        [ 32%]
tests/test_credssp.py::test_credssp_iov_not_available PASSED             [ 33%]
tests/test_credssp.py::test_credssp_no_session_key PASSED                [ 33%]
tests/test_credssp.py::test_credssp_fail_getting_session_key PASSED      [ 33%]
tests/test_credssp.py::test_credssp_wrap_iov_fail PASSED                 [ 33%]
tests/test_credssp.py::test_credssp_unwrap_iov_fail PASSED               [ 33%]
tests/test_credssp.py::test_credssp_sign_fail PASSED                     [ 33%]
tests/test_credssp.py::test_credssp_verify_fail PASSED                   [ 33%]
tests/test_credssp.py::test_credssp_wrap_no_context PASSED               [ 34%]
tests/test_credssp.py::test_credssp_query_message_sizes_fail PASSED      [ 34%]
tests/test_credssp.py::test_credssp_invalid_handshake PASSED             [ 34%]
tests/test_credssp.py::test_credssp_server_without_pub_key PASSED        [ 34%]
tests/test_credssp.py::test_credssp_invalid_client_authentication_v2[2] PASSED [ 34%]
tests/test_credssp.py::test_credssp_invalid_client_authentication_v2[5] PASSED [ 34%]
tests/test_credssp.py::test_credssp_invalid_client_authentication[3] PASSED [ 34%]
tests/test_credssp.py::test_credssp_invalid_client_authentication[4] PASSED [ 35%]
tests/test_credssp.py::test_credssp_invalid_client_authentication[6] PASSED [ 35%]
tests/test_credssp.py::test_credssp_no_pub_key_after_auth PASSED         [ 35%]
tests/test_credssp.py::test_credssp_pub_key_mismatch_initiator PASSED    [ 35%]
tests/test_credssp.py::test_credssp_pub_key_mismatch_acceptor PASSED     [ 35%]
tests/test_credssp.py::test_credssp_no_credential PASSED                 [ 35%]
tests/test_credssp_structures.py::test_unpack_missing_text_field PASSED  [ 36%]
tests/test_credssp_structures.py::test_ts_request_pack PASSED            [ 36%]
tests/test_credssp_structures.py::test_ts_request_unpack PASSED          [ 36%]
tests/test_credssp_structures.py::test_ts_credential_unknown_credential_type PASSED [ 36%]
tests/test_credssp_structures.py::test_ts_credential_unknown_credential_type_unpack PASSED [ 36%]
tests/test_credssp_structures.py::test_ts_credential_password_pack PASSED [ 36%]
tests/test_credssp_structures.py::test_ts_credential_password_unpack PASSED [ 36%]
tests/test_credssp_structures.py::test_ts_credential_smart_card_pack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_smart_card_unpack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_smart_card_full_pack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_smart_card_full_unpack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_remote_guard_multiple_pack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_remote_guard_multiple_unpack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_remote_guard_no_supplemental_pack PASSED [ 37%]
tests/test_credssp_structures.py::test_ts_credential_remote_guard_no_supplemental_unpack PASSED [ 38%]
tests/test_credssp_structures.py::test_ts_credential_remote_guard_empty_supplemental_pack PASSED [ 38%]
tests/test_credssp_structures.py::test_ts_credential_remote_guard_empty_supplemental_unpack PASSED [ 38%]
tests/test_credssp_structures.py::test_ts_remote_guard_pack PASSED       [ 38%]
tests/test_credssp_structures.py::test_ts_remote_guard_unpack PASSED     [ 38%]
tests/test_deprecation.py::test_gss_import_dep PASSED                    [ 38%]
tests/test_deprecation.py::test_negotiate_import_dep PASSED              [ 38%]
tests/test_deprecation.py::test_ntlm_import_dep PASSED                   [ 39%]
tests/test_deprecation.py::test_sspi_import_dep PASSED                   [ 39%]
tests/test_exceptions.py::test_feature_missing_error[NegotiateOptions.negotiate_kerberos-The Python gssapi library is not installed so Kerberos cannot be negotiated.] PASSED [ 39%]
tests/test_exceptions.py::test_feature_missing_error[NegotiateOptions.wrapping_iov-The system is missing the GSSAPI IOV extension headers or CredSSP is being requested, cannot utilize wrap_iov and unwrap_iov] PASSED [ 39%]
tests/test_exceptions.py::test_feature_missing_error[NegotiateOptions.wrapping_winrm-The system is missing the GSSAPI IOV extension headers required for WinRM encryption with Kerberos.] PASSED [ 39%]
tests/test_exceptions.py::test_feature_missing_error[NegotiateOptions.session_key-The protocol selected does not support getting the session key.] PASSED [ 39%]
tests/test_exceptions.py::test_spnego_error_no_code_fail PASSED          [ 40%]
tests/test_exceptions.py::test_spnego_error_invalid_base_error_fail PASSED [ 40%]
tests/test_exceptions.py::test_spnego_error_unknown_error PASSED         [ 40%]
tests/test_exceptions.py::test_invalid_token_error PASSED                [ 40%]
tests/test_exceptions.py::test_invalid_token_error_with_context PASSED   [ 40%]
tests/test_exceptions.py::test_invalid_token_from_gssapi PASSED          [ 40%]
tests/test_exceptions.py::test_invalid_token_from_sspi SKIPPED (Need...) [ 40%]
tests/test_exceptions.py::test_invalid_token_from_sspi_logon_denied SKIPPED [ 41%]
tests/test_exceptions.py::test_operation_not_available_error PASSED      [ 41%]
tests/test_exceptions.py::test_operation_not_available_error_with_context PASSED [ 41%]
tests/test_exceptions.py::test_operation_not_available_from_gssapi PASSED [ 41%]
tests/test_exceptions.py::test_operation_not_available_from_sspi SKIPPED [ 41%]
tests/test_gss.py::test_gss_sasl_description_fail PASSED                 [ 41%]
tests/test_gss.py::test_build_iov_list ERROR                             [ 41%]
tests/test_gss.py::test_gssapi_query_message_sizes_fail ERROR            [ 42%]
tests/test_gss.py::test_gssapi_wrap_no_context ERROR                     [ 42%]
tests/test_gss.py::test_gssapi_wrap_iov_no_context ERROR                 [ 42%]
tests/test_gss.py::test_gssapi_wrap_winrm_no_context ERROR               [ 42%]
tests/test_gss.py::test_gssapi_unwrap_no_context ERROR                   [ 42%]
tests/test_gss.py::test_gssapi_unwrap_iov_no_context ERROR               [ 42%]
tests/test_gss.py::test_gssapi_unwrap_winrm_no_context ERROR             [ 43%]
tests/test_gss.py::test_gssapi_sign_no_context ERROR                     [ 43%]
tests/test_gss.py::test_gssapi_verify_no_context ERROR                   [ 43%]
tests/test_gss.py::test_build_iov_list_invalid_tuple ERROR               [ 43%]
tests/test_gss.py::test_build_iov_list_invalid_buffer_type ERROR         [ 43%]
tests/test_gss.py::test_build_iov_list_invalid_data ERROR                [ 43%]
tests/test_gss.py::test_build_iov_list_invalid_value ERROR               [ 43%]
tests/test_gss.py::test_no_gssapi_library PASSED                         [ 44%]
tests/test_gss.py::test_gssapi_no_valid_acceptor_cred PASSED             [ 44%]
tests/test_kerberos.py::test_parse_enum_unknown PASSED                   [ 44%]
tests/test_kerberos.py::test_parse_flags_unknown PASSED                  [ 44%]
tests/test_kerberos.py::test_kerberos_ap_options_native_labels PASSED    [ 44%]
tests/test_kerberos.py::test_kerberos_kdc_options_native_labels PASSED   [ 44%]
tests/test_kerberos.py::test_kerberos_encryption_type_native_labels PASSED [ 44%]
tests/test_kerberos.py::test_kerberos_error_code_native_labels PASSED    [ 45%]
tests/test_kerberos.py::test_kerberos_message_type_native_labels PASSED  [ 45%]
tests/test_kerberos.py::test_kerberos_pa_data_type_native_labels PASSED  [ 45%]
tests/test_kerberos.py::test_kerberos_principal_name_type_native_labels PASSED [ 45%]
tests/test_kerberos.py::test_kerberos_host_address_type_native_labels PASSED [ 45%]
tests/test_kerberos.py::test_unpack_unknown_krb PASSED                   [ 45%]
tests/test_kerberos.py::test_unpack_krb_as_req PASSED                    [ 45%]
tests/test_kerberos.py::test_unpack_krb_tgs_req PASSED                   [ 46%]
tests/test_kerberos.py::test_unpack_krb_as_rep PASSED                    [ 46%]
tests/test_kerberos.py::test_unpack_krb_tgs_rep PASSED                   [ 46%]
tests/test_kerberos.py::test_unpack_krb_ap_req PASSED                    [ 46%]
tests/test_kerberos.py::test_unpack_krb_ap_req_unknown_options PASSED    [ 46%]
tests/test_kerberos.py::test_unpack_krb_ap_rep PASSED                    [ 46%]
tests/test_kerberos.py::test_unpack_krb_error PASSED                     [ 47%]
tests/test_kerberos.py::test_padata_unknown_type PASSED                  [ 47%]
tests/test_kerberos.py::test_req_body_addresses PASSED                   [ 47%]
tests/test_kerberos.py::test_req_body_ticket PASSED                      [ 47%]
tests/test_main.py::test_parse_with_hex PASSED                           [ 47%]
tests/test_main.py::test_parse_with_file PASSED                          [ 47%]
tests/test_main.py::test_parse_with_file_missing PASSED                  [ 47%]
tests/test_main.py::test_parse_from_stdin PASSED                         [ 48%]
tests/test_main.py::test_parse_from_stdin_base16 PASSED                  [ 48%]
tests/test_main.py::test_parse_from_stdin_base64 PASSED                  [ 48%]
tests/test_main.py::test_parse_output_yaml PASSED                        [ 48%]
tests/test_main.py::test_parse_output_yaml_not_installed PASSED          [ 48%]
tests/test_main.py::test_parse_invalid_spnego_token PASSED               [ 48%]
tests/test_main.py::test_ntlm_negotiate PASSED                           [ 48%]
tests/test_main.py::test_ntlm_challenge PASSED                           [ 49%]
tests/test_main.py::test_ntlm_authenticate PASSED                        [ 49%]
tests/test_main.py::test_ntlm_authenticate_with_secret PASSED            [ 49%]
tests/test_main.py::test_ntlm_authenticate_ntlmv1 PASSED                 [ 49%]
tests/test_main.py::test_ntlm_authenticate_lmv2 PASSED                   [ 49%]
tests/test_main.py::test_nltm_session_key_no_sign_seal PASSED            [ 49%]
tests/test_main.py::test_ntlm_without_version PASSED                     [ 50%]
tests/test_main.py::test_ntlm_no_target_info PASSED                      [ 50%]
tests/test_main.py::test_ntlm_av_single_host PASSED                      [ 50%]
tests/test_main.py::test_krb_as_rep PASSED                               [ 50%]
tests/test_main.py::test_krb_as_req PASSED                               [ 50%]
tests/test_main.py::test_krb_error PASSED                                [ 50%]
tests/test_main.py::test_krb_tgs_rep PASSED                              [ 50%]
tests/test_main.py::test_krb_tgs_req PASSED                              [ 51%]
tests/test_main.py::test_krb_ap_req_in_initial_context_token PASSED      [ 51%]
tests/test_main.py::test_neg_token_init PASSED                           [ 51%]
tests/test_main.py::test_neg_token_init2 PASSED                          [ 51%]
tests/test_main.py::test_neg_token_resp PASSED                           [ 51%]
tests/test_main.py::test_tls13_client_hello PASSED                       [ 51%]
tests/test_main.py::test_tls12_client_hello PASSED                       [ 51%]
tests/test_main.py::test_tls11_client_hello PASSED                       [ 52%]
tests/test_main.py::test_tls10_client_hello PASSED                       [ 52%]
tests/test_main.py::test_tls13_server_hello PASSED                       [ 52%]
tests/test_main.py::test_tls12_server_hello PASSED                       [ 52%]
tests/test_main.py::test_tls11_server_hello PASSED                       [ 52%]
tests/test_main.py::test_tls10_server_hello PASSED                       [ 52%]
tests/test_main.py::test_tls12_client_key_exchange PASSED                [ 52%]
tests/test_negotiate.py::test_token_rejected PASSED                      [ 53%]
tests/test_negotiate.py::test_token_invalid_input PASSED                 [ 53%]
tests/test_negotiate.py::test_token_no_common_mechs PASSED               [ 53%]
tests/test_negotiate.py::test_token_acceptor_first PASSED                [ 53%]
tests/test_negotiate.py::test_iov_available_sspi SKIPPED (Requires S...) [ 53%]
tests/test_negotiate.py::test_iov_available_gssapi PASSED                [ 53%]
tests/test_ntlm.py::test_get_credential_file_no_env_var PASSED           [ 54%]
tests/test_ntlm.py::test_get_credential_file_env_var_missing_file PASSED [ 54%]
tests/test_ntlm.py::test_get_credential_file PASSED                      [ 54%]
tests/test_ntlm.py::test_get_credential_from_file[domain:Username:password-username-domain-E52CAC67419A9A224A3B108F3FA6CB6D-8846F7EAEE8FB117AD06BDD830B7586C-input0] PASSED [ 54%]
tests/test_ntlm.py::test_get_credential_from_file[domain:Username:password\ndomain:other:pass2-Username-domain-E52CAC67419A9A224A3B108F3FA6CB6D-8846F7EAEE8FB117AD06BDD830B7586C-None] PASSED [ 54%]
tests/test_ntlm.py::test_get_credential_from_file[fake\ndomain:username:password-username-domain-E52CAC67419A9A224A3B108F3FA6CB6D-8846F7EAEE8FB117AD06BDD830B7586C-input2] PASSED [ 54%]
tests/test_ntlm.py::test_get_credential_from_file[:username@DOMAIN.COM:password-username@DOMAIN.COM-None-E52CAC67419A9A224A3B108F3FA6CB6D-8846F7EAEE8FB117AD06BDD830B7586C-input3] PASSED [ 54%]
tests/test_ntlm.py::test_get_credential_from_file[testuser:1000:278623D830DABE161104594F8C2EF12B:C3C6F4FD8A02A6C1268F1A8074B6E7E0:[U]:LCT-1589398321-testuser-None-278623D830DABE161104594F8C2EF12B-C3C6F4FD8A02A6C1268F1A8074B6E7E0-input4] PASSED [ 55%]
tests/test_ntlm.py::test_get_credential_from_file[TESTDOM\\testuser:1000:4588C64B89437893AAD3B435B51404EE:65202355FA01AEF26B89B19E00F52679:[U]:LCT-1589398321-testuser-testdom-4588C64B89437893AAD3B435B51404EE-65202355FA01AEF26B89B19E00F52679-input5] PASSED [ 55%]
tests/test_ntlm.py::test_get_credential_from_file[TESTDOM\\testuser:1000:4588C64B89437893AAD3B435B51404EE:65202355FA01AEF26B89B19E00F52679:[U]:LCT-1589398321-testuser-testdom-4588C64B89437893AAD3B435B51404EE-65202355FA01AEF26B89B19E00F52679-input6] PASSED [ 55%]
tests/test_ntlm.py::test_get_credential_from_file[testuser@TESTDOM.COM:1000:00000000000000000000000000000000:8ADB9B997580D69E69CAA2BBB68F4697:[U]:LCT-1589398321-testuser@testdom.com-None-00000000000000000000000000000000-8ADB9B997580D69E69CAA2BBB68F4697-input7] PASSED [ 55%]
tests/test_ntlm.py::test_get_credential_from_file_no_matches PASSED      [ 55%]
tests/test_ntlm.py::test_invalid_lm_compat_level[-1] PASSED              [ 55%]
tests/test_ntlm.py::test_invalid_lm_compat_level[6] PASSED               [ 55%]
tests/test_ntlm.py::test_context_no_store[initiate] PASSED               [ 56%]
tests/test_ntlm.py::test_context_no_store[accept] PASSED                 [ 56%]
tests/test_ntlm.py::test_iov_available PASSED                            [ 56%]
tests/test_ntlm.py::test_ntlm_invalid_usage PASSED                       [ 56%]
tests/test_ntlm.py::test_ntlm_invalid_protocol PASSED                    [ 56%]
tests/test_ntlm.py::test_ntlm_query_message_sizes_fail PASSED            [ 56%]
tests/test_ntlm.py::test_ntlm_wrap_qop_invalid PASSED                    [ 56%]
tests/test_ntlm.py::test_ntlm_wrap_no_sign_or_seal PASSED                [ 57%]
tests/test_ntlm.py::test_ntlm_wrap_no_context PASSED                     [ 57%]
tests/test_ntlm.py::test_ntlm_wrap_winrm_no_context PASSED               [ 57%]
tests/test_ntlm.py::test_ntlm_unwrap_no_context PASSED                   [ 57%]
tests/test_ntlm.py::test_ntlm_unwrap_winrm_no_context PASSED             [ 57%]
tests/test_ntlm.py::test_ntlm_wrap_iov_with_qop_fail PASSED              [ 57%]
tests/test_ntlm.py::test_ntlm_wrap_iov_no_sign_or_seal PASSED            [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_no_context PASSED                 [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_no_header PASSED                  [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_no_data PASSED                    [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_multiple_header PASSED            [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_multiple_data PASSED              [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_invalid_type PASSED               [ 58%]
tests/test_ntlm.py::test_ntlm_wrap_iov_data_not_bytes PASSED             [ 59%]
tests/test_ntlm.py::test_ntlm_wrap_iov_signonly_not_bytes PASSED         [ 59%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_no_sign_or_seal PASSED          [ 59%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_no_context PASSED               [ 59%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_no_header PASSED                [ 59%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_no_data PASSED                  [ 59%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_multiple_header PASSED          [ 59%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_multiple_data PASSED            [ 60%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_invalid_type PASSED             [ 60%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_data_not_bytes PASSED           [ 60%]
tests/test_ntlm.py::test_ntlm_unwrap_iov_data_readonly_not_bytes PASSED  [ 60%]
tests/test_ntlm.py::test_ntlm_sign_qop_invalid PASSED                    [ 60%]
tests/test_ntlm.py::test_ntlm_sign_no_context PASSED                     [ 60%]
tests/test_ntlm.py::test_ntlm_verify_no_context PASSED                   [ 61%]
tests/test_ntlm.py::test_ntlm_no_encoding_flags PASSED                   [ 61%]
tests/test_ntlm.py::test_ntlm_bad_bindings[NegotiateOptions.use_ntlm-False] PASSED [ 61%]
tests/test_ntlm.py::test_ntlm_bad_bindings[NegotiateOptions.use_ntlm-True] PASSED [ 61%]
tests/test_ntlm.py::test_ntlm_bad_bindings[NegotiateOptions.use_gssapi-True] SKIPPED [ 61%]
tests/test_ntlm.py::test_ntlm_bad_bindings[NegotiateOptions.use_sspi-True] SKIPPED [ 61%]
tests/test_ntlm.py::test_ntlm_bad_mic PASSED                             [ 61%]
tests/test_ntlm.py::test_ntlm_workstation_override[None-A1F8948D47FC] PASSED [ 62%]
tests/test_ntlm.py::test_ntlm_workstation_override[-None] PASSED         [ 62%]
tests/test_ntlm.py::test_ntlm_workstation_override[custom-custom] PASSED [ 62%]
tests/test_ntlm.py::test_ntlm_custom_time[True-0] PASSED                 [ 62%]
tests/test_ntlm.py::test_ntlm_custom_time[False-1] PASSED                [ 62%]
tests/test_ntlm.py::test_ntlm_no_key_exch PASSED                         [ 62%]
tests/test_ntlm.py::test_ntlm_lm_request PASSED                          [ 62%]
tests/test_ntlm.py::test_ntlm_no_lm_allowed PASSED                       [ 63%]
tests/test_ntlm.py::test_ntlm_nt_v1_request PASSED                       [ 63%]
tests/test_ntlm.py::test_ntlm_no_nt_v1_allowed PASSED                    [ 63%]
tests/test_ntlm.py::test_ntlm_invalid_password[NegotiateOptions.use_ntlm] PASSED [ 63%]
tests/test_ntlm.py::test_ntlm_invalid_password[NegotiateOptions.use_gssapi] SKIPPED [ 63%]
tests/test_ntlm.py::test_ntlm_invalid_password[NegotiateOptions.use_sspi] SKIPPED [ 63%]
tests/test_ntlm.py::test_ntlm_verify_fail[NegotiateOptions.use_ntlm] PASSED [ 63%]
tests/test_ntlm.py::test_ntlm_verify_fail[NegotiateOptions.use_gssapi] SKIPPED [ 64%]
tests/test_ntlm.py::test_ntlm_verify_fail[NegotiateOptions.use_sspi] SKIPPED [ 64%]
tests/test_ntlm.py::test_ntlm_anon_response PASSED                       [ 64%]
tests/test_ntlm.py::test_ntlm_iov_wrapping PASSED                        [ 64%]
tests/test_ntlm.py::test_ntlm_iov_unwrapping_as_stream PASSED            [ 64%]
tests/test_spnego.py::test_pack_mech_type_list[1.2.840.113554.1.2.2-0\x0b\x06\t*\x86H\x86\xf7\x12\x01\x02\x02] PASSED [ 64%]
tests/test_spnego.py::test_pack_mech_type_list[value1-0\x17\x06\t*\x86H\x86\xf7\x12\x01\x02\x02\x06\n+\x06\x01\x04\x01\x827\x02\x02\n] PASSED [ 65%]
tests/test_spnego.py::test_spnego_context_flags_native_labels PASSED     [ 65%]
tests/test_spnego.py::test_spnego_neg_state_native_labels PASSED         [ 65%]
tests/test_spnego.py::test_initial_context_token_unknown_token PASSED    [ 65%]
tests/test_spnego.py::test_initial_context_token_unknown_mech PASSED     [ 65%]
tests/test_spnego.py::test_unpack_initial_context_token_unknown_mech PASSED [ 65%]
tests/test_spnego.py::test_unpack_initial_context_token_invalid_application_tag PASSED [ 65%]
tests/test_spnego.py::test_unpack_initial_context_token_invalid_context_specific_tag PASSED [ 66%]
tests/test_spnego.py::test_unpack_neg_token_init PASSED                  [ 66%]
tests/test_spnego.py::test_unpack_neg_token_init2 PASSED                 [ 66%]
tests/test_spnego.py::test_unpack_neg_token_resp PASSED                  [ 66%]
tests/test_spnego.py::test_unpack_krb_ap_req PASSED                      [ 66%]
tests/test_spnego.py::test_unpack_krb_ap_rep PASSED                      [ 66%]
tests/test_spnego.py::test_unpack_ntlm PASSED                            [ 66%]
tests/test_spnego.py::test_pack_neg_token_init PASSED                    [ 67%]
tests/test_spnego.py::test_pack_neg_token_init2 PASSED                   [ 67%]
tests/test_spnego.py::test_pack_neg_token_resp PASSED                    [ 67%]
tests/test_sspi.py::test_build_iov_list SKIPPED (Requires SSPI library)  [ 67%]
tests/test_sspi.py::test_build_iov_list_fail_auto_alloc SKIPPED (Req...) [ 67%]
tests/test_sspi.py::test_no_sspi_library PASSED                          [ 67%]
tests/test_sspi.py::test_sspi_invalid_qop SKIPPED (Requires SSPI lib...) [ 68%]
tests/test_sspi.py::test_sspi_wrap_no_encryption SKIPPED (Requires S...) [ 68%]
tests/test_sspi.py::test_sspi_no_valid_cred SKIPPED (Requires SSPI l...) [ 68%]
tests/test_text.py::test_to_bytes_from_bytes PASSED                      [ 68%]
tests/test_text.py::test_to_bytes_from_text[cafe-cafe] PASSED            [ 68%]
tests/test_text.py::test_to_bytes_from_text[caf\xe9-caf\xc3\xa9] PASSED  [ 68%]
tests/test_text.py::test_to_bytes_from_text[U\u0308se\u04dc-U\xcc\x88se\xd3\x9c] PASSED [ 68%]
tests/test_text.py::test_to_bytes_encoding PASSED                        [ 69%]
tests/test_text.py::test_to_bytes_errors PASSED                          [ 69%]
tests/test_text.py::test_to_bytes_nonstr PASSED                          [ 69%]
tests/test_text.py::test_to_bytes_nonstr_default PASSED                  [ 69%]
tests/test_text.py::test_to_bytes_nonstr_repr PASSED                     [ 69%]
tests/test_text.py::test_to_bytes_nonstr_unicode_error PASSED            [ 69%]
tests/test_text.py::test_to_bytes_nonstr_passthru PASSED                 [ 69%]
tests/test_text.py::test_to_bytes_nonstr_empty PASSED                    [ 70%]
tests/test_text.py::test_to_bytes_nonstr_invalid PASSED                  [ 70%]
tests/test_text.py::test_to_text_from_text PASSED                        [ 70%]
tests/test_text.py::test_to_text_from_bytes[cafe-cafe] PASSED            [ 70%]
tests/test_text.py::test_to_text_from_bytes[caf\xc3\xa9-caf\xe9] PASSED  [ 70%]
tests/test_text.py::test_to_text_from_bytes[U\xcc\x88se\xd3\x9c-U\u0308se\u04dc] PASSED [ 70%]
tests/test_text.py::test_to_text_encoding PASSED                         [ 70%]
tests/test_text.py::test_to_text_errors PASSED                           [ 71%]
tests/test_text.py::test_to_text_nonstr PASSED                           [ 71%]
tests/test_text.py::test_to_text_nonstr_unicode PASSED                   [ 71%]
tests/test_text.py::test_to_text_nonstr_default PASSED                   [ 71%]
tests/test_text.py::test_to_text_nonstr_repr PASSED                      [ 71%]
tests/test_text.py::test_to_text_nonstr_unicode_error PASSED             [ 71%]
tests/test_text.py::test_to_text_nonstr_passthru PASSED                  [ 72%]
tests/test_text.py::test_to_text_nonstr_empty PASSED                     [ 72%]
tests/test_text.py::test_to_text_nonstr_invalid PASSED                   [ 72%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsProtocolVersion-10-Unknown TLS Protocol Version 0x000A] PASSED [ 72%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsContentType-99-Unknown TLS Content Type 0x63] PASSED [ 72%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsHandshakeMessageType-255-Unknown Handshake Message Type 0xFF] PASSED [ 72%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsCipherSuite-65281-Unknown Cipher Suite 0xFF01] PASSED [ 72%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsCompressionMethod-5-Unknown Compression Method 0x05] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsExtensionType-99-Unknown Extension Type 0x0063] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsServerNameType-2-Unknown Server Name Type 0x02] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsECPointFormat-3-Unknown EC Point Format 0x03] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsSupportedGroup-4692-Unknown Supported Group 0x1254] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsSignatureScheme-1-Unknown Signature Scheme 0x0001] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsPskKeyExchangeMode-68-Unknown PSK Key Exchange Mode 0x44] PASSED [ 73%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsECCurveType-85-Unknown EC Curve Type 0x55] PASSED [ 74%]
tests/test_tls_struct.py::test_tls_enum_missing_member[TlsClientCertificateType-112-Unknown Client Certificate Type 0x70] PASSED [ 74%]
tests/test_tls_struct.py::test_tls_enum_missing_member[DistinguishedNameType-1.2.3.4-Unknown DN OID Type 1.2.3.4] PASSED [ 74%]
tests/test_tls_struct.py::test_tls_enum_fail_non_int PASSED              [ 74%]
tests/_ntlm_raw/test_crypto.py::test_crc32 PASSED                        [ 74%]
tests/_ntlm_raw/test_crypto.py::test_lmowfv1 PASSED                      [ 74%]
tests/_ntlm_raw/test_crypto.py::test_lmowfv1_hash PASSED                 [ 75%]
tests/_ntlm_raw/test_crypto.py::test_ntowfv1 PASSED                      [ 75%]
tests/_ntlm_raw/test_crypto.py::test_ntowfv1_hash PASSED                 [ 75%]
tests/_ntlm_raw/test_crypto.py::test_compute_response_v1_no_session_security PASSED [ 75%]
tests/_ntlm_raw/test_crypto.py::test_compute_response_v1_no_session_security_non_nt_key PASSED [ 75%]
tests/_ntlm_raw/test_crypto.py::test_compute_response_v1_no_session_security_lm_key PASSED [ 75%]
tests/_ntlm_raw/test_crypto.py::test_compute_response_v1_session_security PASSED [ 75%]
tests/_ntlm_raw/test_crypto.py::test_ntowfv2 PASSED                      [ 76%]
tests/_ntlm_raw/test_crypto.py::test_compute_response_v2 PASSED          [ 76%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_ess[initiate-128] PASSED   [ 76%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_ess[accept-128] PASSED     [ 76%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_ess[initiate-56] PASSED    [ 76%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_ess[accept-56] PASSED      [ 76%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_ess[initiate-40] PASSED    [ 76%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_ess[accept-40] PASSED      [ 77%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_lm_key_or_datagram[NegotiateFlags.key_56|lm_key-UUUUUUU\xa0] PASSED [ 77%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_lm_key_or_datagram[NegotiateFlags.key_56|datagram-UUUUUUU\xa0] PASSED [ 77%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_lm_key_or_datagram[NegotiateFlags.lm_key-UUUUU\xe58\xb0] PASSED [ 77%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_lm_key_or_datagram[NegotiateFlags.datagram-UUUUU\xe58\xb0] PASSED [ 77%]
tests/_ntlm_raw/test_crypto.py::test_seal_key_no_flags PASSED            [ 77%]
tests/_ntlm_raw/test_crypto.py::test_signkey_no_ess PASSED               [ 77%]
tests/_ntlm_raw/test_crypto.py::test_signkey_client PASSED               [ 78%]
tests/_ntlm_raw/test_crypto.py::test_signkey_server PASSED               [ 78%]
tests/_ntlm_raw/test_des.py::test_des_invalid_key_size PASSED            [ 78%]
tests/_ntlm_raw/test_des.py::test_expand_56bit_key PASSED                [ 78%]
tests/_ntlm_raw/test_des.py::test_encrypt_block PASSED                   [ 78%]
tests/_ntlm_raw/test_des.py::test_encrypt PASSED                         [ 78%]
tests/_ntlm_raw/test_des.py::test_encrypt_large_bytes_padding PASSED     [ 79%]
tests/_ntlm_raw/test_des.py::test_decrypt PASSED                         [ 79%]
tests/_ntlm_raw/test_des.py::test_decrypt_large_bytes_padding PASSED     [ 79%]
tests/_ntlm_raw/test_des.py::test_decrypt_fail_invalid_size PASSED       [ 79%]
tests/_ntlm_raw/test_des.py::test_encrypt_decrypt_multiple_keys PASSED   [ 79%]
tests/_ntlm_raw/test_md4.py::test_md4[-1\xd6\xcf\xe0\xd1j\xe91\xb7<Y\xd7\xe0\xc0\x89\xc0] PASSED [ 79%]
tests/_ntlm_raw/test_md4.py::test_md4[a-\xbd\xe5,\xb3\x1d\xe3>F$^\x05\xfb\xdb\xd6\xfb$] PASSED [ 79%]
tests/_ntlm_raw/test_md4.py::test_md4[abc-\xa4H\x01z\xaf!\xd8R_\xc1\n\xe8z\xa6r\x9d] PASSED [ 80%]
tests/_ntlm_raw/test_md4.py::test_md4[message digest-\xd9\x13\n\x81dT\x9f\xe8\x18\x87H\x06\xe1\xc7\x01K] PASSED [ 80%]
tests/_ntlm_raw/test_md4.py::test_md4[abcdefghijklmnopqrstuvwxyz-\xd7\x9e\x1c0\x8a\xa5\xbb\xcd\xee\xa8\xedc\xdfA-\xa9] PASSED [ 80%]
tests/_ntlm_raw/test_md4.py::test_md4[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-\x04?\x85\x82\xf2A\xdb5\x1c\xe6'\xe1S\xe7\xf0\xe4] PASSED [ 80%]
tests/_ntlm_raw/test_md4.py::test_md4[12345678901234567890123456789012345678901234567890123456789012345678901234567890-\xe3;M\xdc\x9c8\xf2\x19\x9c>{\x16O\xcc\x056] PASSED [ 80%]
tests/_ntlm_raw/test_md4.py::test_md4_to_hashlib PASSED                  [ 80%]
tests/_ntlm_raw/test_messages.py::test_negotiate_flags_native_labels PASSED [ 80%]
tests/_ntlm_raw/test_messages.py::test_av_id_native_labels PASSED        [ 81%]
tests/_ntlm_raw/test_messages.py::test_av_flags_native_labels PASSED     [ 81%]
tests/_ntlm_raw/test_messages.py::test_message_type_native_labels PASSED [ 81%]
tests/_ntlm_raw/test_messages.py::test_negotiate_pack_defaults PASSED    [ 81%]
tests/_ntlm_raw/test_messages.py::test_negotiate_pack_with_domain PASSED [ 81%]
tests/_ntlm_raw/test_messages.py::test_negotiate_pack_with_all_fields PASSED [ 81%]
tests/_ntlm_raw/test_messages.py::test_negotiate_pack_encoding PASSED    [ 81%]
tests/_ntlm_raw/test_messages.py::test_negotiate_unpack PASSED           [ 82%]
tests/_ntlm_raw/test_messages.py::test_negotiate_unpack_with_domain PASSED [ 82%]
tests/_ntlm_raw/test_messages.py::test_negotiate_unpack_with_all_fields PASSED [ 82%]
tests/_ntlm_raw/test_messages.py::test_negotiate_unpack_encoding PASSED  [ 82%]
tests/_ntlm_raw/test_messages.py::test_negotiate_unpack_invalid_encoding PASSED [ 82%]
tests/_ntlm_raw/test_messages.py::test_negotiate_invalid_size PASSED     [ 82%]
tests/_ntlm_raw/test_messages.py::test_negotiate_unpack_invalid_msg PASSED [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_pack PASSED             [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_pack_target_name PASSED [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_pack_target_name_oem PASSED [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_pack_target_info PASSED [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_pack_all_fields PASSED  [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_set_fields PASSED       [ 83%]
tests/_ntlm_raw/test_messages.py::test_challenge_invalid_server_challenge_length PASSED [ 84%]
tests/_ntlm_raw/test_messages.py::test_challenge_invalid_size PASSED     [ 84%]
tests/_ntlm_raw/test_messages.py::test_challenge_unpack_ntlmv1 PASSED    [ 84%]
tests/_ntlm_raw/test_messages.py::test_challenge_unpack_ntlmv2 PASSED    [ 84%]
tests/_ntlm_raw/test_messages.py::test_challenge_unpack_encoding PASSED  [ 84%]
tests/_ntlm_raw/test_messages.py::test_challenge_unpack_invalid_msg PASSED [ 84%]
tests/_ntlm_raw/test_messages.py::test_authenticate_pack PASSED          [ 84%]
tests/_ntlm_raw/test_messages.py::test_authenticate_pack_domain_version PASSED [ 85%]
tests/_ntlm_raw/test_messages.py::test_authenticate_pack_oem_encoding PASSED [ 85%]
tests/_ntlm_raw/test_messages.py::test_authenticate_set_flags PASSED     [ 85%]
tests/_ntlm_raw/test_messages.py::test_authenticate_set_mic PASSED       [ 85%]
tests/_ntlm_raw/test_messages.py::test_authenticate_set_encrypted_session_key PASSED [ 85%]
tests/_ntlm_raw/test_messages.py::test_authenticate_invalid_mic_length PASSED [ 85%]
tests/_ntlm_raw/test_messages.py::test_authenticate_set_mic_not_present PASSED [ 86%]
tests/_ntlm_raw/test_messages.py::test_authenticate_unpack_empty PASSED  [ 86%]
tests/_ntlm_raw/test_messages.py::test_authenticate_unpack_ntlmv1 PASSED [ 86%]
tests/_ntlm_raw/test_messages.py::test_authenticate_unpack_ntlmv2 PASSED [ 86%]
tests/_ntlm_raw/test_messages.py::test_authenticate_unpack_mic_no_version PASSED [ 86%]
tests/_ntlm_raw/test_messages.py::test_authenticate_invalid_size PASSED  [ 86%]
tests/_ntlm_raw/test_messages.py::test_authenticate_unpack_invalid_msg PASSED [ 86%]
tests/_ntlm_raw/test_messages.py::test_filetime_pack PASSED              [ 87%]
tests/_ntlm_raw/test_messages.py::test_filetime_unpack PASSED            [ 87%]
tests/_ntlm_raw/test_messages.py::test_filetime_from_datetime_nanoseconds PASSED [ 87%]
tests/_ntlm_raw/test_messages.py::test_filetime_now PASSED               [ 87%]
tests/_ntlm_raw/test_messages.py::test_filetime_with_timezone PASSED     [ 87%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_pack PASSED          [ 87%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_create PASSED        [ 87%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_unpack PASSED        [ 88%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_unpack_invalid_size PASSED [ 88%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_resp_type PASSED     [ 88%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_hi_resp_type PASSED  [ 88%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_client_challenge PASSED [ 88%]
tests/_ntlm_raw/test_messages.py::test_nt_challenge_client_challenge_bad_length PASSED [ 88%]
tests/_ntlm_raw/test_messages.py::test_target_info_pack PASSED           [ 88%]
tests/_ntlm_raw/test_messages.py::test_target_info_unpack PASSED         [ 89%]
tests/_ntlm_raw/test_messages.py::test_single_host_pack PASSED           [ 89%]
tests/_ntlm_raw/test_messages.py::test_single_host_defaults PASSED       [ 89%]
tests/_ntlm_raw/test_messages.py::test_single_host_invalid_size PASSED   [ 89%]
tests/_ntlm_raw/test_messages.py::test_single_host_invalid_custom_data_size PASSED [ 89%]
tests/_ntlm_raw/test_messages.py::test_single_host_invalid_machine_id_size PASSED [ 89%]
tests/_ntlm_raw/test_messages.py::test_single_host_unpack PASSED         [ 90%]
tests/_ntlm_raw/test_messages.py::test_single_host_eq PASSED             [ 90%]
tests/_ntlm_raw/test_messages.py::test_version_pack PASSED               [ 90%]
tests/_ntlm_raw/test_messages.py::test_version_defaults PASSED           [ 90%]
tests/_ntlm_raw/test_messages.py::test_version_unpack PASSED             [ 90%]
tests/_ntlm_raw/test_messages.py::test_version_unpack_incorrect_length PASSED [ 90%]
tests/_ntlm_raw/test_messages.py::test_version_get_current PASSED        [ 90%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[0.1.0.dev1-0-1-0] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[0.1.0b1-0-1-0] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[0.1.10b1-0-1-10] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[0.1.0a1-0-1-0] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[0.1.0-0-1-0] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[0-0-0-0] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[1-1-0-0] PASSED [ 91%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[1.2-1-2-0] PASSED [ 92%]
tests/_ntlm_raw/test_messages.py::test_version_get_current_formats[1..-1-0-0] PASSED [ 92%]
tests/_ntlm_raw/test_messages.py::test_version_eq PASSED                 [ 92%]
tests/_ntlm_raw/test_security.py::test_seal_ntlmv1 PASSED                [ 92%]
tests/_ntlm_raw/test_security.py::test_seal_ntlmv1_with_ess PASSED       [ 92%]
tests/_ntlm_raw/test_security.py::test_seal_ntlmv2 PASSED                [ 92%]
tests/_ntlm_raw/test_security.py::test_seal_ntlmv2_no_key_exch PASSED    [ 93%]
tests/_ntlm_raw/test_security.py::test_sign_with_always_sign PASSED      [ 93%]
tests/_ntlm_raw/test_security.py::test_sign_no_integrity PASSED          [ 93%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_desc_repr SKIPPED (Can...) [ 93%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_desc_str SKIPPED (Can ...) [ 93%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_desc_version SKIPPED (...) [ 93%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_length[buffer0-3] SKIPPED  [ 93%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_length[buffer1-5] SKIPPED  [ 94%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_repr SKIPPED (Can only...) [ 94%]
tests/_sspi_raw/test_sspi.py::test_sec_buffer_str SKIPPED (Can only ...) [ 94%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[username-domain-domain\\username] SKIPPED [ 94%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[username@DOMAIN--username@DOMAIN] SKIPPED [ 94%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[username@DOMAIN-None-username@DOMAIN] SKIPPED [ 94%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[None-domain-domain\\] SKIPPED [ 94%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[None-None-] SKIPPED [ 95%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[--] SKIPPED      [ 95%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity[user\U0001d11e-domain\U0001d11e-domain\U0001d11e\\user\U0001d11e] SKIPPED [ 95%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity_set_username SKIPPED [ 95%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity_set_domain SKIPPED [ 95%]
tests/_sspi_raw/test_sspi.py::test_win_nt_auth_identity_set_password SKIPPED [ 95%]
tests/_sspi_raw/test_sspi.py::test_accept_security_context_fail SKIPPED  [ 95%]
tests/_sspi_raw/test_sspi.py::test_acquire_credentials_handle_fail SKIPPED [ 96%]
tests/_sspi_raw/test_sspi.py::test_decrypt_message_fail SKIPPED (Can...) [ 96%]
tests/_sspi_raw/test_sspi.py::test_encrypt_message_fail SKIPPED (Can...) [ 96%]
tests/_sspi_raw/test_sspi.py::test_initialize_security_context_fail SKIPPED [ 96%]
tests/_sspi_raw/test_sspi.py::test_make_signature_fail SKIPPED (Can ...) [ 96%]
tests/_sspi_raw/test_sspi.py::test_query_context_attributes_unknown SKIPPED [ 96%]
tests/_sspi_raw/test_sspi.py::test_query_context_attributes_invalid_handle[0] SKIPPED [ 97%]
tests/_sspi_raw/test_sspi.py::test_query_context_attributes_invalid_handle[9] SKIPPED [ 97%]
tests/_sspi_raw/test_sspi.py::test_query_context_attributes_invalid_handle[10] SKIPPED [ 97%]
tests/_sspi_raw/test_sspi.py::test_verify_signature_fail SKIPPED (Ca...) [ 97%]
tests/_sspi_raw/test_text.py::test_wide_char[None-0] SKIPPED (Can on...) [ 97%]
tests/_sspi_raw/test_text.py::test_wide_char[-0] SKIPPED (Can only t...) [ 97%]
tests/_sspi_raw/test_text.py::test_wide_char[cafe-5] SKIPPED (Can on...) [ 97%]
tests/_sspi_raw/test_text.py::test_wide_char[caf\xe9-5] SKIPPED (Can...) [ 98%]
tests/_sspi_raw/test_text.py::test_wide_char[\U0001d11e-3] SKIPPED (...) [ 98%]
tests/data/test_context.py::test_split_username[None-None-None] PASSED   [ 98%]
tests/data/test_context.py::test_split_username[username-None-username] PASSED [ 98%]
tests/data/test_context.py::test_split_username[domain\\username-domain-username] PASSED [ 98%]
tests/data/test_context.py::test_split_username[username@DOMAIN.COM-None-username@DOMAIN.COM] PASSED [ 98%]
tests/data/test_context.py::test_gss_mech_native_labels PASSED           [ 98%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.3.6.1.4.1.311.2.2.10-False] PASSED [ 99%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.3.6.1.5.5.2-False] PASSED [ 99%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.2.840.113554.1.2.2.3-False] PASSED [ 99%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.2.840.113554.1.2.2-True] PASSED [ 99%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.2.840.48018.1.2.2-True] PASSED [ 99%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.3.5.1.5.2-True] PASSED [ 99%]
tests/data/test_context.py::test_gss_mech_is_kerberos_oid[1.3.6.1.5.2-True] PASSED [100%]

==================================== ERRORS ====================================
________________ ERROR at setup of test_negotiate_with_kerberos ________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc009720>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpmntmrci7-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpmntmrci7-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_negotiate_with_kerberos_no_integrity __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc8763b0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpqoimjt6t-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpqoimjt6t-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
______________ ERROR at setup of test_gssapi_kerberos_auth[False] ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc747130>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp7q8qupfc-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp7q8qupfc-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
______________ ERROR at setup of test_gssapi_kerberos_auth[True] _______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc8f2080>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmplutjweiq-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmplutjweiq-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_______ ERROR at setup of test_gssapi_kerberos_auth_no_integrity[False] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc8474c0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp_uhpkvup-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp_uhpkvup-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
________ ERROR at setup of test_gssapi_kerberos_auth_no_integrity[True] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbaac850>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpfhctbsbp-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpfhctbsbp-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_______ ERROR at setup of test_gssapi_kerberos_auth_explicit_cred[False] _______

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc995ff0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpsqo85l3r-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpsqo85l3r-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_______ ERROR at setup of test_gssapi_kerberos_auth_explicit_cred[True] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc9af220>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpxyjwfbtt-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpxyjwfbtt-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_keytab[kerberos-False] __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc6ac310>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpcr2r76rp-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpcr2r76rp-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
__________ ERROR at setup of test_kerberos_auth_keytab[kerberos-True] __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbd06dd0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp3n1bafic-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp3n1bafic-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_keytab[negotiate-False] _________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc4f6dd0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpir6_ab_u-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpir6_ab_u-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_keytab[negotiate-True] __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc875cc0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpec2ffn4b-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpec2ffn4b-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_ccache[kerberos-False] __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc62b460>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpsost2h24-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpsost2h24-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_ccache[kerberos-True0] __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66db8379d0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp5o8af513-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp5o8af513-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_ccache[negotiate-False] _________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbaad660>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpkuebqhdq-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpkuebqhdq-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_________ ERROR at setup of test_kerberos_auth_ccache[kerberos-True1] __________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc9acd00>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmppwoglb3p-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmppwoglb3p-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
________ ERROR at setup of test_kerberos_auth_env_cache[kerberos-False] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc0cc2e0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp538zcnar-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp538zcnar-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
________ ERROR at setup of test_kerberos_auth_env_cache[kerberos-True0] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbd04b50>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpxv8ubyll-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpxv8ubyll-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_______ ERROR at setup of test_kerberos_auth_env_cache[negotiate-False] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc039870>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpmacz2k55-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpmacz2k55-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
________ ERROR at setup of test_kerberos_auth_env_cache[kerberos-True1] ________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc9adf00>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpdep2vnc3-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpdep2vnc3-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
____ ERROR at setup of test_kerberos_auth_channel_bindings[kerberos-False] _____

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbaacb80>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp7d4elz9z-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp7d4elz9z-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____ ERROR at setup of test_kerberos_auth_channel_bindings[kerberos-True] _____

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc84c6d0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmph7dbsojw-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmph7dbsojw-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
____ ERROR at setup of test_kerberos_auth_channel_bindings[negotiate-False] ____

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dba3b130>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmplvtpqzx9-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmplvtpqzx9-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
____ ERROR at setup of test_kerberos_auth_channel_bindings[negotiate-True] _____

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc0924d0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp5pu62wni-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp5pu62wni-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____________ ERROR at setup of test_credssp_kerberos_creds[False] _____________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc6cc9d0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp8y9gv9g5-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp8y9gv9g5-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____________ ERROR at setup of test_credssp_kerberos_creds[True] ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dba123e0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpv5br89bl-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpv5br89bl-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
__________________ ERROR at setup of test_kerberos[negotiate] __________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbac4e20>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp6iy00uad-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp6iy00uad-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
__________________ ERROR at setup of test_kerberos[kerberos] ___________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc044b20>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp8wabr9oo-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp8wabr9oo-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
____________________ ERROR at setup of test_build_iov_list _____________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc62a380>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmput8074ro-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmput8074ro-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
____________ ERROR at setup of test_gssapi_query_message_sizes_fail ____________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc4f7b20>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp_xuyyk61-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp_xuyyk61-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
________________ ERROR at setup of test_gssapi_wrap_no_context _________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc8ad240>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpkab3mi89-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpkab3mi89-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
______________ ERROR at setup of test_gssapi_wrap_iov_no_context _______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc090880>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmptbvb48os-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmptbvb48os-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____________ ERROR at setup of test_gssapi_wrap_winrm_no_context ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbac7dc0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpjx49egn3-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpjx49egn3-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_______________ ERROR at setup of test_gssapi_unwrap_no_context ________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc994670>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp4qo73b5d-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp4qo73b5d-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____________ ERROR at setup of test_gssapi_unwrap_iov_no_context ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66db836020>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpcmmxrxn3-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpcmmxrxn3-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
____________ ERROR at setup of test_gssapi_unwrap_winrm_no_context _____________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbd7d090>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpf4bl0i4f-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpf4bl0i4f-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
________________ ERROR at setup of test_gssapi_sign_no_context _________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66db8a75e0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp99b485mk-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp99b485mk-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_______________ ERROR at setup of test_gssapi_verify_no_context ________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc844be0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpc4qd5eim-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpc4qd5eim-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____________ ERROR at setup of test_build_iov_list_invalid_tuple ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dc6dedd0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmphgtsk_h2-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmphgtsk_h2-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
__________ ERROR at setup of test_build_iov_list_invalid_buffer_type ___________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbd04580>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmplphe_ba8-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmplphe_ba8-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
______________ ERROR at setup of test_build_iov_list_invalid_data ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66db870d90>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpoaq7s340-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpoaq7s340-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError
_____________ ERROR at setup of test_build_iov_list_invalid_value ______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f66dbd9f5e0>

    @pytest.fixture()
    def kerb_cred(monkeypatch):
        if not HAS_K5TEST:
            pytest.skip("Cannot create Kerberos credential without k5test being installed")
    
>       realm = K5Realm()

tests/conftest.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/usr/local/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmpukhcoh21-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmpukhcoh21-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = -1, c2pread = 12, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/usr/local/lib/python3.10/subprocess.py:1847: FileNotFoundError

---------- coverage: platform linux, python 3.10.8-final-0 -----------
Name                                Stmts   Miss  Cover   Missing
-----------------------------------------------------------------
src/spnego/__init__.py                 14      0   100%
src/spnego/__main__.py                419      3    99%   69, 610, 765
src/spnego/_asn1.py                   275      0   100%
src/spnego/_context.py                198      8    96%   67-71, 798, 801, 805, 820
src/spnego/_credential.py              69      1    99%   263
src/spnego/_credssp.py                310      0   100%
src/spnego/_credssp_structures.py     186      0   100%
src/spnego/_gss.py                    284    148    48%   52-55, 64-67, 76-81, 112, 118, 124-126, 133-139, 147-149, 162, 219-226, 231-252, 270-293, 339-349, 367-370, 374, 378, 383-386, 389, 407-446, 450-459, 463-467, 476-483, 486-491, 495-500, 507-514, 525-536, 540-543, 547-550, 575-596
src/spnego/_kerberos.py               525      0   100%
src/spnego/_negotiate.py              237      8    97%   105, 117, 125, 447, 466-469
src/spnego/_ntlm.py                   429      0   100%
src/spnego/_ntlm_raw/__init__.py        0      0   100%
src/spnego/_ntlm_raw/crypto.py        112      0   100%
src/spnego/_ntlm_raw/des.py           151      0   100%
src/spnego/_ntlm_raw/md4.py            82      0   100%
src/spnego/_ntlm_raw/messages.py      598      0   100%
src/spnego/_ntlm_raw/security.py       30      0   100%
src/spnego/_spnego.py                 151      0   100%
src/spnego/_sspi.py                   248    185    25%   40-63, 73, 80-91, 115-135, 163-184, 192-195, 199, 205-206, 211, 214, 232-297, 300-303, 306-307, 316-331, 334-338, 341-344, 351-361, 364-365, 369-378, 382-390, 395-416, 420-422, 425-459, 463-482
src/spnego/_sspi_raw/__init__.py        2      1    50%   33
src/spnego/_text.py                    38      0   100%
src/spnego/_tls_struct.py             688      0   100%
src/spnego/_version.py                  1      0   100%
src/spnego/auth.py                     43      2    95%   55, 65
src/spnego/channel_bindings.py         66      0   100%
src/spnego/exceptions.py              162      2    99%   10-11
src/spnego/gss.py                       3      0   100%
src/spnego/iov.py                      19      0   100%
src/spnego/negotiate.py                 3      0   100%
src/spnego/ntlm.py                      3      0   100%
src/spnego/sspi.py                      3      0   100%
src/spnego/tls.py                      38      1    97%   106
-----------------------------------------------------------------
TOTAL                                5387    359    93%

=========================== short test summary info ============================
ERROR tests/test_auth.py::test_negotiate_with_kerberos - FileNotFoundError: [...
ERROR tests/test_auth.py::test_negotiate_with_kerberos_no_integrity - FileNot...
ERROR tests/test_auth.py::test_gssapi_kerberos_auth[False] - FileNotFoundErro...
ERROR tests/test_auth.py::test_gssapi_kerberos_auth[True] - FileNotFoundError...
ERROR tests/test_auth.py::test_gssapi_kerberos_auth_no_integrity[False] - Fil...
ERROR tests/test_auth.py::test_gssapi_kerberos_auth_no_integrity[True] - File...
ERROR tests/test_auth.py::test_gssapi_kerberos_auth_explicit_cred[False] - Fi...
ERROR tests/test_auth.py::test_gssapi_kerberos_auth_explicit_cred[True] - Fil...
ERROR tests/test_auth.py::test_kerberos_auth_keytab[kerberos-False] - FileNot...
ERROR tests/test_auth.py::test_kerberos_auth_keytab[kerberos-True] - FileNotF...
ERROR tests/test_auth.py::test_kerberos_auth_keytab[negotiate-False] - FileNo...
ERROR tests/test_auth.py::test_kerberos_auth_keytab[negotiate-True] - FileNot...
ERROR tests/test_auth.py::test_kerberos_auth_ccache[kerberos-False] - FileNot...
ERROR tests/test_auth.py::test_kerberos_auth_ccache[kerberos-True0] - FileNot...
ERROR tests/test_auth.py::test_kerberos_auth_ccache[negotiate-False] - FileNo...
ERROR tests/test_auth.py::test_kerberos_auth_ccache[kerberos-True1] - FileNot...
ERROR tests/test_auth.py::test_kerberos_auth_env_cache[kerberos-False] - File...
ERROR tests/test_auth.py::test_kerberos_auth_env_cache[kerberos-True0] - File...
ERROR tests/test_auth.py::test_kerberos_auth_env_cache[negotiate-False] - Fil...
ERROR tests/test_auth.py::test_kerberos_auth_env_cache[kerberos-True1] - File...
ERROR tests/test_auth.py::test_kerberos_auth_channel_bindings[kerberos-False]
ERROR tests/test_auth.py::test_kerberos_auth_channel_bindings[kerberos-True]
ERROR tests/test_auth.py::test_kerberos_auth_channel_bindings[negotiate-False]
ERROR tests/test_auth.py::test_kerberos_auth_channel_bindings[negotiate-True]
ERROR tests/test_auth.py::test_credssp_kerberos_creds[False] - FileNotFoundEr...
ERROR tests/test_auth.py::test_credssp_kerberos_creds[True] - FileNotFoundErr...
ERROR tests/test_auth_dce.py::test_kerberos[negotiate] - FileNotFoundError: [...
ERROR tests/test_auth_dce.py::test_kerberos[kerberos] - FileNotFoundError: [E...
ERROR tests/test_gss.py::test_build_iov_list - FileNotFoundError: [Errno 2] N...
ERROR tests/test_gss.py::test_gssapi_query_message_sizes_fail - FileNotFoundE...
ERROR tests/test_gss.py::test_gssapi_wrap_no_context - FileNotFoundError: [Er...
ERROR tests/test_gss.py::test_gssapi_wrap_iov_no_context - FileNotFoundError:...
ERROR tests/test_gss.py::test_gssapi_wrap_winrm_no_context - FileNotFoundErro...
ERROR tests/test_gss.py::test_gssapi_unwrap_no_context - FileNotFoundError: [...
ERROR tests/test_gss.py::test_gssapi_unwrap_iov_no_context - FileNotFoundErro...
ERROR tests/test_gss.py::test_gssapi_unwrap_winrm_no_context - FileNotFoundEr...
ERROR tests/test_gss.py::test_gssapi_sign_no_context - FileNotFoundError: [Er...
ERROR tests/test_gss.py::test_gssapi_verify_no_context - FileNotFoundError: [...
ERROR tests/test_gss.py::test_build_iov_list_invalid_tuple - FileNotFoundErro...
ERROR tests/test_gss.py::test_build_iov_list_invalid_buffer_type - FileNotFou...
ERROR tests/test_gss.py::test_build_iov_list_invalid_data - FileNotFoundError...
ERROR tests/test_gss.py::test_build_iov_list_invalid_value - FileNotFoundErro...
================= 566 passed, 64 skipped, 42 errors in 12.87s ==================
ERROR: InvocationError for command /workdir/pyspnego-0.9.1/.tox/cpythonlibtest-unit-test-tests/bin/python -m pytest -v --cov spnego --cov-report term-missing (exited with code 1)
___________________________________ summary ____________________________________
ERROR:   cpythonlibtest-unit-test-tests: commands failed
