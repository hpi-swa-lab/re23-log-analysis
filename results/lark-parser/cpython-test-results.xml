<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
	<testsuite name="tests.test_cache.TestCache-20231122060405" tests="6" file="tests/test_cache.py" time="0.024" timestamp="2023-11-22T06:04:05" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_cache.TestCache" name="test_automatic_naming" time="0.007" timestamp="2023-11-22T06:04:05" file="tests/test_cache.py" line="81"/>
		<testcase classname="tests.test_cache.TestCache" name="test_custom_lexer" time="0.001" timestamp="2023-11-22T06:04:05" file="tests/test_cache.py" line="95"/>
		<testcase classname="tests.test_cache.TestCache" name="test_imports" time="0.009" timestamp="2023-11-22T06:04:05" file="tests/test_cache.py" line="127"/>
		<testcase classname="tests.test_cache.TestCache" name="test_inline" time="0.004" timestamp="2023-11-22T06:04:05" file="tests/test_cache.py" line="108"/>
		<testcase classname="tests.test_cache.TestCache" name="test_options" time="0.001" timestamp="2023-11-22T06:04:05" file="tests/test_cache.py" line="102"/>
		<testcase classname="tests.test_cache.TestCache" name="test_simple" time="0.001" timestamp="2023-11-22T06:04:05" file="tests/test_cache.py" line="73"/>
	</testsuite>
	<testsuite name="tests.test_grammar.TestGrammar-20231122060405" tests="20" file="tests/test_grammar.py" time="0.358" timestamp="2023-11-22T06:04:06" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_grammar.TestGrammar" name="test_alias_in_terminal" time="0.001" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="111"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_empty_literal" time="0.000" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="25"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_errors" time="0.032" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="15"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_extend_rule" time="0.008" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="65"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_extend_term" time="0.008" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="78"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_extend_twice" time="0.003" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="87"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_find_grammar_errors" time="0.017" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="167"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_import_custom_sources" time="0.008" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="132"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_import_custom_sources2" time="0.002" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="145"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_import_custom_sources3" time="0.016" timestamp="2023-11-22T06:04:05" file="tests/test_grammar.py" line="157"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_large_terminal" time="0.109" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="249"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_list_grammar_imports" time="0.007" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="259"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_override_rule" time="0.006" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="29"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_override_terminal" time="0.007" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="53"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_ranged_repeat_large" time="0.128" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="223"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_ranged_repeat_terms" time="0.004" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="201"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_token_multiline_only_works_with_x_flag" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="123"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_undefined_ignore" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="98"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_undefined_rule" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="117"/>
		<testcase classname="tests.test_grammar.TestGrammar" name="test_undefined_term" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_grammar.py" line="120"/>
	</testsuite>
	<testsuite name="tests.test_lexer.TestLexer-20231122060405" tests="1" file="tests/test_lexer.py" time="0.002" timestamp="2023-11-22T06:04:06" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_lexer.TestLexer" name="test_basic" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_lexer.py" line="9"/>
	</testsuite>
	<testsuite name="tests.test_logger.Testlogger-20231122060405" tests="3" file="tests/test_logger.py" time="0.006" timestamp="2023-11-22T06:04:06" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_logger.Testlogger" name="test_debug" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_logger.py" line="23"/>
		<testcase classname="tests.test_logger.Testlogger" name="test_loglevel_higher" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_logger.py" line="51"/>
		<testcase classname="tests.test_logger.Testlogger" name="test_non_debug" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_logger.py" line="38"/>
	</testsuite>
	<testsuite name="tests.test_nearley.test_nearley.TestNearley-20231122060405" tests="8" file="tests/test_nearley/test_nearley.py" time="0.156" timestamp="2023-11-22T06:04:06" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_backslash" time="0.044" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="82"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_css" time="0.085" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="26"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_include" time="0.007" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="46"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_include_utf8" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="103"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_multi_include" time="0.009" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="59"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_null" time="0.003" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="90"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_utf8" time="0.003" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="73"/>
		<testcase classname="tests.test_nearley.test_nearley.TestNearley" name="test_utf8_2" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_nearley/test_nearley.py" line="99"/>
	</testsuite>
	<testsuite name="tests.test_parser.TestCykCustom_new-20231122060405" tests="98" file="tests/test_parser.py" time="1.802" timestamp="2023-11-22T06:04:08" failures="0" errors="0" skipped="21">
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_backslash" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_backslash2" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_basic1" time="0.003" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_bytes_utf8" time="0.009" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_escaped_string" time="0.008" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_expand1_lists_with_one_item" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_expand1_lists_with_one_item_2" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_float_without_lexer" time="0.007" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_g_regex_flags" time="0.003" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_hex_escape" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_hex_literal_range_escape" time="0.002" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_import" time="0.011" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_import_rename" time="0.010" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_join_regex_flags" time="0.004" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_lexer_detect_newline_tokens" time="0.007" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_lexer_token_limit" time="1.498" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_multi_import" time="0.009" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_multi_start" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_priority_vs_embedded" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_ranged_repeat_rules" time="0.004" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_regex_escaping" time="0.009" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_regex_quote" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_regex_width_fallback" time="0.003" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_import" time="0.013" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_import_of_nested_grammar" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_import_rename" time="0.014" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_import_rules_dependencies_imported_only_once" time="0.007" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_multi_import" time="0.009" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_rule_import" time="0.008" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_rule_import_drop_ignore" time="0.007" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_rule_import_rename" time="0.007" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_rule_import_subrule" time="0.026" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_relative_rule_import_subrule_no_conflict" time="0.008" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_rule_collision" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_rule_collision2" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_start" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_templates" time="0.003" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_templates_import" time="0.003" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_collision" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_collision2" time="0.006" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_collision_WS" time="0.007" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_ebnf" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_flags" time="0.004" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_token_not_anon" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode_class" time="0.003" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_empty" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1547">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_empty_end" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="2235">
			<skipped type="skip" message="Empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_empty_expand1_list" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1229">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_empty_expand1_list_2" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1248">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_empty_flatten_list" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1268">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_error_with_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="2466">
			<skipped type="skip" message="interactive_parser error handling only works with LALR for now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_ignore" time="0.000" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="2112">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_lexer_prioritization" time="0.001" timestamp="2023-11-22T06:04:06" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Only standard lexers care about token priority"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_match_examples" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2370">
			<skipped type="skip" message="match_examples() not supported for CYK/old custom lexer"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_maybe" time="0.000" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1486">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_maybe_placeholders" time="0.002" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2246">
			<skipped type="skip" message="Empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_parser_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2429">
			<skipped type="skip" message="interactive_parser is only implemented for LALR at the moment"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_prioritization" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Doesn't work for CYK"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:07" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_stack_for_ebnf" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
			<skipped type="skip" message="Takes forever"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykCustom_new" name="test_twice_empty" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1685">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestCykStandard-20231122060405" tests="98" file="tests/test_parser.py" time="1.562" timestamp="2023-11-22T06:04:09" failures="0" errors="0" skipped="20">
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_backslash" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_backslash2" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_basic1" time="0.003" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_bytes_utf8" time="0.005" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_escaped_string" time="0.007" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_expand1_lists_with_one_item" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_expand1_lists_with_one_item_2" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_float_without_lexer" time="0.006" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_hex_escape" time="0.002" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_import" time="0.009" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_import_rename" time="0.009" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_join_regex_flags" time="0.004" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_lexer_detect_newline_tokens" time="0.006" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_lexer_prioritization" time="0.005" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_lexer_token_limit" time="1.292" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_multi_import" time="0.009" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_multi_start" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_priority_vs_embedded" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_ranged_repeat_rules" time="0.003" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_regex_escaping" time="0.007" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_regex_width_fallback" time="0.003" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_import" time="0.014" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_import_of_nested_grammar" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_import_rename" time="0.014" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_import_rules_dependencies_imported_only_once" time="0.007" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_multi_import" time="0.009" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_rule_import" time="0.008" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_rule_import_drop_ignore" time="0.008" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_rule_import_rename" time="0.007" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_rule_import_subrule" time="0.008" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_relative_rule_import_subrule_no_conflict" time="0.008" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_rule_collision" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_rule_collision2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_start" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_templates" time="0.003" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_templates_import" time="0.003" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_templates_modifiers" time="0.004" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_collision2" time="0.006" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_collision_WS" time="0.007" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_token_not_anon" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_empty" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1547">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_empty_end" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2235">
			<skipped type="skip" message="Empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_empty_expand1_list" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1229">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_empty_expand1_list_2" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1248">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_empty_flatten_list" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="1268">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_error_with_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2466">
			<skipped type="skip" message="interactive_parser error handling only works with LALR for now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_ignore" time="0.000" timestamp="2023-11-22T06:04:08" file="tests/test_parser.py" line="2112">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_match_examples" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2370">
			<skipped type="skip" message="match_examples() not supported for CYK/old custom lexer"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_maybe" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1486">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_maybe_placeholders" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2246">
			<skipped type="skip" message="Empty rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_multiple_item_flatten_list" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_parser_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2429">
			<skipped type="skip" message="interactive_parser is only implemented for LALR at the moment"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_prioritization" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Doesn't work for CYK"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_stack_for_ebnf" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
			<skipped type="skip" message="Takes forever"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestCykStandard" name="test_twice_empty" time="0.000" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1685">
			<skipped type="skip" message="No empty rules"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestEarleyCustom_old-20231122060405" tests="98" file="tests/test_parser.py" time="1.766" timestamp="2023-11-22T06:04:11" failures="0" errors="0" skipped="11">
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_backslash" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_backslash2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_basic1" time="0.004" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_bytes_utf8" time="0.005" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_empty" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_empty_flatten_list" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_escaped_string" time="0.007" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_expand1_lists_with_one_item" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_expand1_lists_with_one_item_2" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_float_without_lexer" time="0.007" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_hex_escape" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_ignore" time="0.009" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_import" time="0.009" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_join_regex_flags" time="0.004" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_lexer_detect_newline_tokens" time="0.006" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_lexer_token_limit" time="1.290" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_maybe" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_maybe_placeholders" time="0.018" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_multi_import" time="0.010" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_multi_start" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_prioritization" time="0.009" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_ranged_repeat_rules" time="0.005" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_regex_escaping" time="0.008" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_regex_width_fallback" time="0.003" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_import" time="0.014" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_import_of_nested_grammar" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_import_rename" time="0.014" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_import_rules_dependencies_imported_only_once" time="0.007" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_multi_import" time="0.009" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_rule_import" time="0.007" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_rule_import_drop_ignore" time="0.007" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_rule_import_rename" time="0.007" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_rule_import_subrule" time="0.008" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_relative_rule_import_subrule_no_conflict" time="0.008" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_rule_collision" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_rule_collision2" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_stack_for_ebnf" time="0.168" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_start" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_stringio_unicode" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_templates" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_templates_import" time="0.003" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_collision_WS" time="0.006" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_token_not_anon" time="0.003" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_error_with_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="2466">
			<skipped type="skip" message="interactive_parser error handling only works with LALR for now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_lexer_prioritization" time="0.001" timestamp="2023-11-22T06:04:09" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Only standard lexers care about token priority"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_match_examples" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2370">
			<skipped type="skip" message="match_examples() not supported for CYK/old custom lexer"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_multiple_item_flatten_list" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_parser_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2429">
			<skipped type="skip" message="interactive_parser is only implemented for LALR at the moment"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_priority_vs_embedded" time="0.000" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2209">
			<skipped type="skip" message="Priority not handled correctly right now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyCustom_old" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestEarleyDynamic-20231122060405" tests="98" file="tests/test_parser.py" time="1.690" timestamp="2023-11-22T06:04:13" failures="0" errors="0" skipped="11">
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_backslash" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_backslash2" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_basic1" time="0.004" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_bytes_utf8" time="0.005" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_empty" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_empty_flatten_list" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_escaped_string" time="0.006" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_expand1_lists_with_one_item" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_expand1_lists_with_one_item_2" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_float_without_lexer" time="0.006" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_hex_escape" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_ignore" time="0.008" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_import" time="0.008" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_join_regex_flags" time="0.003" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_lexer_detect_newline_tokens" time="0.006" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_lexer_token_limit" time="1.244" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_match_examples" time="0.003" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_maybe" time="0.002" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_maybe_placeholders" time="0.018" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_meddling_unused" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_multi_import" time="0.008" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_multi_start" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_prioritization" time="0.007" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_prioritization_sum" time="0.008" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_ranged_repeat_rules" time="0.004" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_regex_escaping" time="0.007" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_regex_width_fallback" time="0.002" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_import" time="0.012" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_import_of_nested_grammar" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_import_rename" time="0.011" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_import_rules_dependencies_imported_only_once" time="0.006" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_multi_import" time="0.007" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_rule_import" time="0.006" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_rule_import_drop_ignore" time="0.006" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_rule_import_rename" time="0.006" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_rule_import_subrule" time="0.006" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_relative_rule_import_subrule_no_conflict" time="0.006" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_rule_collision" time="0.002" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_rule_collision2" time="0.002" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_stack_for_ebnf" time="0.166" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_start" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_stringio_unicode" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_templates" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_templates_import" time="0.003" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_collision_WS" time="0.006" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_token_not_anon" time="0.003" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_error_with_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="2466">
			<skipped type="skip" message="interactive_parser error handling only works with LALR for now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_lexer_prioritization" time="0.001" timestamp="2023-11-22T06:04:11" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Only standard lexers care about token priority"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_parser_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2429">
			<skipped type="skip" message="interactive_parser is only implemented for LALR at the moment"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_postlex_declare" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1950">
			<skipped type="skip" message="%declare/postlex doesn't work with dynamic"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_postlex_indenter" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1973">
			<skipped type="skip" message="%declare/postlex doesn't work with dynamic"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_priority_vs_embedded" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2209">
			<skipped type="skip" message="Priority not handled correctly right now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:12" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestEarleyDynamic_complete-20231122060405" tests="98" file="tests/test_parser.py" time="1.801" timestamp="2023-11-22T06:04:14" failures="0" errors="0" skipped="11">
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_backslash" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_backslash2" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_basic1" time="0.004" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_bytes_utf8" time="0.004" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_empty" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_empty_flatten_list" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_escaped_string" time="0.006" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_expand1_lists_with_one_item" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_expand1_lists_with_one_item_2" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_float_without_lexer" time="0.006" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_hex_escape" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_ignore" time="0.008" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_import" time="0.008" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_join_regex_flags" time="0.003" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_lexer_detect_newline_tokens" time="0.005" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_lexer_token_limit" time="1.354" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_match_examples" time="0.003" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_maybe" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_maybe_placeholders" time="0.016" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_meddling_unused" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_multi_import" time="0.008" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_multi_start" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_prioritization" time="0.007" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_prioritization_sum" time="0.008" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_ranged_repeat_rules" time="0.004" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_regex_escaping" time="0.007" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_regex_width_fallback" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_import" time="0.012" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_import_of_nested_grammar" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_import_rename" time="0.012" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_import_rules_dependencies_imported_only_once" time="0.006" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_multi_import" time="0.008" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_rule_import" time="0.006" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_rule_import_drop_ignore" time="0.006" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_rule_import_rename" time="0.006" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_rule_import_subrule" time="0.006" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_relative_rule_import_subrule_no_conflict" time="0.007" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_rule_collision" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_rule_collision2" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_stack_for_ebnf" time="0.169" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_start" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_templates" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_templates_alias" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_templates_import" time="0.003" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_collision_WS" time="0.006" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_flags2" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_token_not_anon" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_error_with_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="2466">
			<skipped type="skip" message="interactive_parser error handling only works with LALR for now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_lexer_prioritization" time="0.001" timestamp="2023-11-22T06:04:13" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Only standard lexers care about token priority"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_parser_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2429">
			<skipped type="skip" message="interactive_parser is only implemented for LALR at the moment"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_postlex_declare" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1950">
			<skipped type="skip" message="%declare/postlex doesn't work with dynamic"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_postlex_indenter" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1973">
			<skipped type="skip" message="%declare/postlex doesn't work with dynamic"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_priority_vs_embedded" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2209">
			<skipped type="skip" message="Priority not handled correctly right now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyDynamic_complete" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestEarleyStandard-20231122060405" tests="98" file="tests/test_parser.py" time="1.760" timestamp="2023-11-22T06:04:16" failures="0" errors="0" skipped="9">
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_alias" time="0.004" timestamp="2023-11-22T06:04:14" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_backslash" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_backslash2" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_basic1" time="0.005" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_bytes_utf8" time="0.005" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_empty" time="0.001" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_empty_flatten_list" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_escaped_string" time="0.007" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_expand1_lists_with_one_item" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_expand1_lists_with_one_item_2" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_float_without_lexer" time="0.008" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_hex_escape" time="0.002" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_ignore" time="0.008" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_import" time="0.008" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_join_regex_flags" time="0.004" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_lexer_detect_newline_tokens" time="0.006" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_lexer_prioritization" time="0.006" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_lexer_token_limit" time="1.278" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_match_examples" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_maybe" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_maybe_placeholders" time="0.017" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_multi_import" time="0.009" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_multi_start" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_prioritization" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_ranged_repeat_rules" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_regex_escaping" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_regex_width_fallback" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_import" time="0.012" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_import_of_nested_grammar" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_import_rename" time="0.012" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_import_rules_dependencies_imported_only_once" time="0.006" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_multi_import" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_rule_import" time="0.006" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_rule_import_drop_ignore" time="0.006" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_rule_import_rename" time="0.007" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_rule_import_subrule" time="0.007" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_relative_rule_import_subrule_no_conflict" time="0.007" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_rule_collision" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_rule_collision2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_stack_for_ebnf" time="0.176" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_start" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_templates" time="0.004" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_templates_import" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_templates_modifiers" time="0.004" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_templates_templates" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_collision_WS" time="0.006" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_token_not_anon" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_error_with_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:15" file="tests/test_parser.py" line="2466">
			<skipped type="skip" message="interactive_parser error handling only works with LALR for now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_parser_interactive_parser" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2429">
			<skipped type="skip" message="interactive_parser is only implemented for LALR at the moment"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_priority_vs_embedded" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2209">
			<skipped type="skip" message="Priority not handled correctly right now"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestEarleyStandard" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestFullEarleyDynamic-20231122060405" tests="24" file="tests/test_parser.py" time="0.057" timestamp="2023-11-22T06:04:16" failures="0" errors="0" skipped="2">
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguity1" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="484"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguity2" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="500"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="522"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node_conditionally_inlined_rule" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="720"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node_inlined_rule" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="703"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node_unnamed_token" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="687"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_symbol_and_intermediate_nodes" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="539"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_anon" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="390"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycle" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="807"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycle2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="820"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycles" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="833"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycles_with_child_filter" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="862"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="399"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="406"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley4" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="440"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley_explicit_ambiguity" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="468"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley_repeating_empty" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="453"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_fruitflies_ambig" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="737"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_many_cycles" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="848"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_nested_ambiguous_intermediate_nodes" time="0.004" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="574"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_nested_ambiguous_intermediate_nodes2" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="614"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_term_ambig_resolve" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="795"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley3" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="422">
			<!--Tests prioritization and disambiguation for pseudo-terminals (there should be only one result)

            By default, `+` should immitate regexp greedy-matching
            -->
			<skipped type="skip" message="Only relevant for the dynamic_complete parser"/>
		</testcase>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_explicit_ambiguity2" time="0.000" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="774">
			<skipped type="skip" message="Only relevant for the dynamic_complete parser"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestFullEarleyDynamic_complete-20231122060405" tests="24" file="tests/test_parser.py" time="0.060" timestamp="2023-11-22T06:04:16" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguity1" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="484"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguity2" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="500"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="522"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node_conditionally_inlined_rule" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="720"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node_inlined_rule" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="703"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_intermediate_node_unnamed_token" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="687"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_ambiguous_symbol_and_intermediate_nodes" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="539"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_anon" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="390"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycle" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="807"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycle2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="820"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycles" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="833"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_cycles_with_child_filter" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="862"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="399"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="406"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley3" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="422">
			<!--Tests prioritization and disambiguation for pseudo-terminals (there should be only one result)

            By default, `+` should immitate regexp greedy-matching
            -->
		</testcase>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley4" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="440"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley_explicit_ambiguity" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="468"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_earley_repeating_empty" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="453"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_explicit_ambiguity2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="774"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_fruitflies_ambig" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="737"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_many_cycles" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="848"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_nested_ambiguous_intermediate_nodes" time="0.004" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="574"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_nested_ambiguous_intermediate_nodes2" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="614"/>
		<testcase classname="tests.test_parser._make_full_earley_test.&lt;locals&gt;._TestFullEarley" name="test_term_ambig_resolve" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="795"/>
	</testsuite>
	<testsuite name="tests.test_parser.TestLalrContextual-20231122060405" tests="98" file="tests/test_parser.py" time="1.625" timestamp="2023-11-22T06:04:18" failures="0" errors="0" skipped="6">
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_backslash" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_backslash2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_basic1" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_basic2" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_bytes_utf8" time="0.005" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_empty" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_empty_flatten_list" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_error_with_interactive_parser" time="0.011" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2466"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_escaped_string" time="0.006" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_expand1_lists_with_one_item" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_expand1_lists_with_one_item_2" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_float_without_lexer" time="0.009" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_hex_escape" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_ignore" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_import" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_join_regex_flags" time="0.003" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_lexer_detect_newline_tokens" time="0.006" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_lexer_token_limit" time="1.302" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_match_examples" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_maybe" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_maybe_placeholders" time="0.016" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_multi_import" time="0.008" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_multi_start" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_parser_interactive_parser" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2429"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_prioritization" time="0.007" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_priority_vs_embedded" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_ranged_repeat_rules" time="0.004" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_regex_escaping" time="0.008" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_regex_width_fallback" time="0.003" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_import" time="0.013" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_import_of_nested_grammar" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_import_rename" time="0.012" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_import_rules_dependencies_imported_only_once" time="0.006" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_multi_import" time="0.008" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_rule_import" time="0.007" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_rule_import_drop_ignore" time="0.006" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_rule_import_rename" time="0.006" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_rule_import_subrule" time="0.006" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_relative_rule_import_subrule_no_conflict" time="0.007" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_rule_collision" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_rule_collision2" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_serialize" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2324"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_stack_for_ebnf" time="0.023" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_start" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_templates" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_templates_import" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_collision_WS" time="0.006" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_flags" time="0.004" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_token_not_anon" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_lexer_prioritization" time="0.001" timestamp="2023-11-22T06:04:16" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Only standard lexers care about token priority"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrContextual" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestLalrCustom_new-20231122060405" tests="98" file="tests/test_parser.py" time="1.673" timestamp="2023-11-22T06:04:20" failures="0" errors="0" skipped="7">
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_backslash" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_backslash2" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_basic1" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_bytes_utf8" time="0.004" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_empty" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_empty_flatten_list" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_error_with_interactive_parser" time="0.009" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2466"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_escaped_string" time="0.006" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_expand1_lists_with_one_item" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_expand1_lists_with_one_item_2" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_float_without_lexer" time="0.007" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_hex_escape" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_ignore" time="0.008" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_import" time="0.008" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_join_regex_flags" time="0.003" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_lexer_detect_newline_tokens" time="0.005" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_lexer_token_limit" time="1.357" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_match_examples" time="0.002" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="2370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_maybe" time="0.001" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_maybe_placeholders" time="0.015" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_multi_import" time="0.020" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_multi_start" time="0.002" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_parser_interactive_parser" time="0.002" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="2429"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_prioritization" time="0.007" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_priority_vs_embedded" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_ranged_repeat_rules" time="0.004" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_regex_escaping" time="0.008" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_regex_width_fallback" time="0.003" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_import" time="0.013" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_import_of_nested_grammar" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_import_rename" time="0.013" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_import_rules_dependencies_imported_only_once" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_multi_import" time="0.008" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_rule_import" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_rule_import_drop_ignore" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_rule_import_rename" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_rule_import_subrule" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_relative_rule_import_subrule_no_conflict" time="0.007" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_rule_collision" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_rule_collision2" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_stack_for_ebnf" time="0.023" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_start" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_templates" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_templates_alias" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_templates_import" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_collision_WS" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_flags2" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_token_not_anon" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_utf8" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_lexer_prioritization" time="0.001" timestamp="2023-11-22T06:04:18" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Only standard lexers care about token priority"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:19" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_serialize" time="0.000" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2324">
			<skipped type="skip" message="Serialize currently only works for LALR parsers without custom lexers (though it should be easy to extend)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrCustom_new" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestLalrStandard-20231122060405" tests="98" file="tests/test_parser.py" time="1.558" timestamp="2023-11-22T06:04:21" failures="0" errors="0" skipped="5">
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_alias" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1498"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_backslash" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1510"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_backslash2" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1520"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_basic1" time="0.003" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1038"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_basic2" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1051"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_bytes_utf8" time="0.004" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1132"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_dont_expand1_lists_with_multiple_items" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1191"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_dont_expand1_lists_with_multiple_items_2" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_empty" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1547"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_empty_end" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2235"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_empty_expand1_list" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1229"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_empty_expand1_list_2" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1248"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_empty_flatten_list" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1268"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_error_with_interactive_parser" time="0.010" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2466"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_escaped_string" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2297">
			<!--Tests common.ESCAPED_STRING-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_expand1_lists_with_one_item" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1163"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_expand1_lists_with_one_item_2" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1177"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_float_without_lexer" time="0.007" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1600"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_g_regex_flags" time="0.002" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1428"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_hex_escape" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1105"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_hex_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1126"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_ignore" time="0.008" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2112"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_import" time="0.008" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1796"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_import_errors" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1935"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_import_rename" time="0.008" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1811"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_join_regex_flags" time="0.003" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1568"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_keep_all_tokens" time="0.001" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1616"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_lexer_detect_newline_tokens" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="2347"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_lexer_prioritization" time="0.006" timestamp="2023-11-22T06:04:20" file="tests/test_parser.py" line="1740">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_lexer_token_limit" time="1.249" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1594">
			<!--Python has a stupid limit of 100 groups in a regular expression. Test that we handle this limitation-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_line_and_column" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1697"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_line_counting" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2222"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_match_examples" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_maybe" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1486"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_maybe_placeholders" time="0.014" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2246"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_meddling_unused" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2312">
			<!--Unless 'unused' is removed, LALR analysis will fail on reduce-reduce collision-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_multi_import" time="0.008" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1900"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_multi_start" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2338"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_parser_interactive_parser" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2429"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_postlex_declare" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1950"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_postlex_indenter" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1973"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_prioritization" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1996">
			<!--Tests effect of priority on result-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_priority_vs_embedded" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2209"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_ranged_repeat_rules" time="0.003" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2174"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_reduce_cycle" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1723">
			<!--Tests an edge-condition in the LALR parser, in which a transition state looks exactly like the end state.
            It seems that the correct solution is to explicitely distinguish finalization in the reduce() function.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_regex_escaping" time="0.007" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2138"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_regex_quote" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1557"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_regex_width_fallback" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2413"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_import" time="0.012" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1826"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_import_of_nested_grammar" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1923"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_import_preserves_leading_underscore" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1918"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_import_rename" time="0.011" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1838"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_import_rules_dependencies_imported_only_once" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1928"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_import_unicode" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1832"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_multi_import" time="0.007" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1913"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_rule_import" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1844"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_rule_import_drop_ignore" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1853"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_rule_import_rename" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1890"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_rule_import_subrule" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1861"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_relative_rule_import_subrule_no_conflict" time="0.017" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1875"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_rule_collision" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1452"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_rule_collision2" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1458"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_serialize" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2324"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_special_chars" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1531"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_stack_for_ebnf" time="0.023" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1155">
			<!--Verify that stack depth isn't an issue for EBNF grammars-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_start" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1492"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_stringio_unicode" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1070">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_templates" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1358"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_templates_alias" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1389"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_templates_import" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1382"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_templates_modifiers" time="0.003" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1400"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_templates_recursion" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1370"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_templates_templates" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1421"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_collision" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1327"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_collision2" time="0.005" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1348"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_collision_WS" time="0.005" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1337"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_ebnf" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1503"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_flags" time="0.003" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1622"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_flags2" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1660"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_flags3" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1652"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_flags_verbose" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1667"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_flags_verbose_multiline" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1675"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_token_not_anon" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1465">
			<!--Tests that "a" is matched as an anonymous token, and not A.
            -->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_twice_empty" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1685"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1074"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode2" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1081"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode3" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1089"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode4" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode_class" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2395">
			<!--Tests that character classes from the `regex` module work correctly.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode_literal_range_escape" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1113"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode_literal_range_escape2" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1119"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_unicode_word" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2405">
			<!--Tests that a persistent bug in the `re` module works when `regex` is enabled.-->
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_utf8" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2097"/>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_multiple_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1300">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_prioritization_sum" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="2040">
			<!--Tests effect of priority on result-->
			<skipped type="skip" message="Currently only Earley supports priority sum in rules"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_recurse_flatten" time="0.000" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1316">
			<!--Verify that stack depth doesn't get exceeded on recursive rules marked for flattening.-->
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_single_item_flatten_list" time="0.000" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1284">
			<skipped type="skip" message="Flattening list isn't implemented (and may never be)"/>
		</testcase>
		<testcase classname="tests.test_parser.tests.test_parser.TestLalrStandard" name="test_stringio_bytes" time="0.000" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="1065">
			<!--Verify that a Lark can be created from file-like objects other than Python's standard 'file' object-->
			<skipped type="skip" message="cStringIO not available"/>
		</testcase>
	</testsuite>
	<testsuite name="tests.test_parser.TestParsers-20231122060405" tests="15" file="tests/test_parser.py" time="0.070" timestamp="2023-11-22T06:04:21" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_parser.TestParsers" name="test_alias" time="0.004" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="365"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_backwards_custom_lexer" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="368"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_big_list" time="0.025" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="50"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_comment_in_rule_definition" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="149"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_embedded_transformer" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="263"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_embedded_transformer_inplace" time="0.007" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="319"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_expand1" time="0.004" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="117"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_infinite_recurse" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="70"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_propagate_positions" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="81"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_propagate_positions2" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="97"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_same_ast" time="0.004" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="57">
			<!--Tests that Earley and LALR parsers produce equal trees-->
		</testcase>
		<testcase classname="tests.test_parser.TestParsers" name="test_vargs_meta" time="0.005" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="207"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_vargs_tree" time="0.001" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="243"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_visit_tokens" time="0.002" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="162"/>
		<testcase classname="tests.test_parser.TestParsers" name="test_visit_tokens2" time="0.006" timestamp="2023-11-22T06:04:21" file="tests/test_parser.py" line="185"/>
	</testsuite>
	<testsuite name="tests.test_reconstructor.TestReconstructor-20231122060405" tests="8" file="tests/test_reconstructor.py" time="0.249" timestamp="2023-11-22T06:04:22" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_alias" time="0.013" timestamp="2023-11-22T06:04:21" file="tests/test_reconstructor.py" line="58"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_expand_rule" time="0.082" timestamp="2023-11-22T06:04:21" file="tests/test_reconstructor.py" line="90"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_json_example" time="0.025" timestamp="2023-11-22T06:04:21" file="tests/test_reconstructor.py" line="104"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_keep_all_tokens" time="0.062" timestamp="2023-11-22T06:04:21" file="tests/test_reconstructor.py" line="146"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_keep_tokens" time="0.014" timestamp="2023-11-22T06:04:22" file="tests/test_reconstructor.py" line="75"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_starred_group" time="0.013" timestamp="2023-11-22T06:04:22" file="tests/test_reconstructor.py" line="45"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_starred_rule" time="0.012" timestamp="2023-11-22T06:04:22" file="tests/test_reconstructor.py" line="30"/>
		<testcase classname="tests.test_reconstructor.TestReconstructor" name="test_switch_grammar_unicode_terminal" time="0.028" timestamp="2023-11-22T06:04:22" file="tests/test_reconstructor.py" line="157">
			<!--
        This test checks that a parse tree built with a grammar containing only ascii characters can be reconstructed
        with a grammar that has unicode rules (or vice versa). The original bug assigned ANON terminals to unicode
        keywords, which offsets the ANON terminal count in the unicode grammar and causes subsequent identical ANON
        tokens (e.g., `+=`) to mis-match between the two grammars.
        -->
		</testcase>
	</testsuite>
	<testsuite name="tests.test_tools.TestStandalone-20231122060405" tests="4" file="tests/test_tools.py" time="0.323" timestamp="2023-11-22T06:04:22" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_tools.TestStandalone" name="test_contextual" time="0.067" timestamp="2023-11-22T06:04:22" file="tests/test_tools.py" line="60"/>
		<testcase classname="tests.test_tools.TestStandalone" name="test_postlex" time="0.060" timestamp="2023-11-22T06:04:22" file="tests/test_tools.py" line="87"/>
		<testcase classname="tests.test_tools.TestStandalone" name="test_simple" time="0.138" timestamp="2023-11-22T06:04:22" file="tests/test_tools.py" line="31"/>
		<testcase classname="tests.test_tools.TestStandalone" name="test_transformer" time="0.058" timestamp="2023-11-22T06:04:22" file="tests/test_tools.py" line="112"/>
	</testsuite>
	<testsuite name="tests.test_tree_forest_transformer.TestTreeForestTransformer-20231122060405" tests="12" file="tests/test_tree_forest_transformer.py" time="0.017" timestamp="2023-11-22T06:04:22" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_aliases" time="0.004" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="165"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_default_ambig" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="114"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_default_rule" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="103"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_default_token" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="68"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_discard" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="146"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_handles_ambiguity" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="126"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_identity_explicit_ambiguity" time="0.003" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="29"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_identity_resolve_ambiguity" time="0.002" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="23"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_rule_calls" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="80"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_token_calls" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="47"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_transformation" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="205"/>
		<testcase classname="tests.test_tree_forest_transformer.TestTreeForestTransformer" name="test_tree_class" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_tree_forest_transformer.py" line="35"/>
	</testsuite>
	<testsuite name="tests.test_trees.TestTrees-20231122060405" tests="15" file="tests/test_trees.py" time="0.008" timestamp="2023-11-22T06:04:22" failures="0" errors="0" skipped="0">
		<testcase classname="tests.test_trees.TestTrees" name="test_deepcopy" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="19"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_discard" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="217"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_inline_static" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="174"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_interp" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="79"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_iter_subtrees" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="30"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_iter_subtrees_topdown" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="36"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_merge_transformers" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="251"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_partial" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="201"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_pickle" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="22"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_repr_runnable" time="0.000" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="27"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_transformer" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="116"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_transformer_variants" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="237"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_vargs" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="154"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_vargs_override" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="183"/>
		<testcase classname="tests.test_trees.TestTrees" name="test_visitor" time="0.001" timestamp="2023-11-22T06:04:22" file="tests/test_trees.py" line="42"/>
	</testsuite>
</testsuites>
