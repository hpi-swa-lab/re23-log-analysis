GLOB sdist-make: /workdir/pytest-flake8-1.1.1/setup.py
cpythonlibtest-unit-test-tests create: /workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests
cpythonlibtest-unit-test-tests installdeps: mock, pytest
cpythonlibtest-unit-test-tests inst: /workdir/pytest-flake8-1.1.1/.tox/.tmp/package/1/pytest-flake8-1.1.1.zip
cpythonlibtest-unit-test-tests installed: exceptiongroup==1.2.0,flake8==6.1.0,iniconfig==2.0.0,mccabe==0.7.0,mock==5.1.0,packaging==23.2,pluggy==1.3.0,pycodestyle==2.11.1,pyflakes==3.1.0,pytest==7.4.3,pytest-flake8 @ file:///workdir/pytest-flake8-1.1.1/.tox/.tmp/package/1/pytest-flake8-1.1.1.zip#sha256=9a9a9ca265149290ceeb97f951cb453dd1705ac6c9d111508459c0544155d6b0,tomli==2.0.1
cpythonlibtest-unit-test-tests run-test-pre: PYTHONHASHSEED='2647575487'
cpythonlibtest-unit-test-tests run-test: commands[0] | pytest -v --tb=native --junitxml /workdir/results/pytest-flake8/1.1.1/1/cpython-test-results.xml
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0 -- /workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/bin/python
cachedir: .tox/cpythonlibtest-unit-test-tests/.pytest_cache
rootdir: /workdir/pytest-flake8-1.1.1
configfile: tox.ini
plugins: flake8-1.1.1
collecting ... collected 16 items

pytest_flake8.py::flake-8::FLAKE8 FAILED                                 [  6%]
setup.py::flake-8::FLAKE8 FAILED                                         [ 12%]
test_flake8.py::flake-8::FLAKE8 FAILED                                   [ 18%]
test_flake8.py::test_version PASSED                                      [ 25%]
test_flake8.py::TestIgnores::test_ignores PASSED                         [ 31%]
test_flake8.py::TestIgnores::test_default_flake8_ignores FAILED          [ 37%]
test_flake8.py::TestIgnores::test_ignores_all FAILED                     [ 43%]
test_flake8.py::TestIgnores::test_w293w292 FAILED                        [ 50%]
test_flake8.py::TestIgnores::test_mtime_caching FAILED                   [ 56%]
test_flake8.py::test_extensions PASSED                                   [ 62%]
test_flake8.py::test_ok_verbose FAILED                                   [ 68%]
test_flake8.py::test_keyword_match FAILED                                [ 75%]
test_flake8.py::test_run_on_init_file FAILED                             [ 81%]
test_flake8.py::test_unicode_error FAILED                                [ 87%]
test_flake8.py::test_strict XFAIL (flake8 is not properly registered...) [ 93%]
test_flake8.py::test_junit_classname FAILED                              [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff2457b5b0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff28d9e6b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff245aa170>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/pytest_flake8.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24591900>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff28d9e6b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff242a0580>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/setup.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff2457b520>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff28d9e6b0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24ea4310>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/test_flake8.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
___________________ TestIgnores.test_default_flake8_ignores ____________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 53, in test_default_flake8_ignores
    result.assert_outcomes(passed=2)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 2} != {'failed': 0}
  {'passed': 0} != {'passed': 2}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_default_flake8_ignores0
configfile: tox.ini
plugins: flake8-1.1.1
collected 2 items

xy.py F
tests/hello.py F

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24251f30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff23fcd0c0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff241ea6b0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff24251fc0>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24222320>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_default_flake8_ignores0/xy.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24252f80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff23fcd0c0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24198fa0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff24252050>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24198d90>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_default_flake8_ignores0/tests/hello.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED xy.py::flake-8::FLAKE8 - AttributeError: 'Application' object has no a...
FAILED tests/hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object...
============================== 2 failed in 0.10s ===============================
_________________________ TestIgnores.test_ignores_all _________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 72, in test_ignores_all
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_ignores_all0
configfile: tox.ini
plugins: flake8-1.1.1
collected 1 item

xy.py F

=================================== FAILURES ===================================
_______________________ FLAKE8-check(ignoring E203 E300) _______________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24252440>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff23fc8b20>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff240d4bb0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff24147010>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff240d4490>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_ignores_all0/xy.py')
flake8ignore = ['E203', 'E300'], maxlength = '', maxdoclenght = ''
maxcomplexity = '', showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED xy.py::flake-8::FLAKE8 - AttributeError: 'Application' object has no a...
============================== 1 failed in 0.05s ===============================
__________________________ TestIgnores.test_w293w292 ___________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 81, in test_w293w292
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*W293*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_w293w2920'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 1 item'
    and: ''
    and: 'test_w293w292.py F                                                       [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff23b1e560>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -> "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '>           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -> Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0x7eff2424db40>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff245a7cd0>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1e4d0>'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '>           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '>               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff245a50c0>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '>           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_w293w2920/test_w293w292.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje..."
    and: '============================== 1 failed in 0.05s ==============================='
remains unmatched: '*W293*'
---------------------------- Captured stderr setup -----------------------------
/tmp/pytest-of-tester/pytest-4/test_w293w2920
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_w293w2920
plugins: flake8-1.1.1
collected 1 item

test_w293w292.py F                                                       [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff23b1e560>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff2424db40>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff245a7cd0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1e4d0>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff245a50c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_w293w2920/test_w293w292.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...
============================== 1 failed in 0.05s ===============================
________________________ TestIgnores.test_mtime_caching ________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 91, in test_mtime_caching
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*W293*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_mtime_caching0'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 2 items'
    and: ''
    and: 'hello.py F                                                               [ 50%]'
    and: 'test_mtime_caching.py F                                                  [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff23b1e560>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -> "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '>           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -> Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0x7eff24241bd0>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff23fcbc10>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1c550>'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '>           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '>               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff23fc9390>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '>           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/hello.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff23b1e4d0>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -> "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '>           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -> Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0x7eff24241bd0>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff24ea4940>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1c3a0>'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '>           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '>               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff24ea4cd0>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '>           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/test_mtime_caching.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n..."
    and: "FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
    and: '============================== 2 failed in 0.10s ==============================='
remains unmatched: '*W293*'
---------------------------- Captured stderr setup -----------------------------
/tmp/pytest-of-tester/pytest-4/test_mtime_caching0
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_mtime_caching0
plugins: flake8-1.1.1
collected 2 items

hello.py F                                                               [ 50%]
test_mtime_caching.py F                                                  [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff23b1e560>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff24241bd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff23fcbc10>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1c550>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff23fc9390>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/hello.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff23b1e4d0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff24241bd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24ea4940>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1c3a0>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24ea4cd0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/test_mtime_caching.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...
FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'...
============================== 2 failed in 0.10s ===============================
_______________________________ test_ok_verbose ________________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 139, in test_ok_verbose
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0 -- /workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/bin/python
cachedir: .pytest_cache
rootdir: /tmp/pytest-of-tester/pytest-4/test_ok_verbose0
plugins: flake8-1.1.1
collecting ... collected 1 item

test_ok_verbose.py::flake-8::FLAKE8 FAILED                               [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff241531c0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff23fd00a0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff2423d090>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff24251090>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff2423f670>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_ok_verbose0/test_ok_verbose.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED test_ok_verbose.py::flake-8::FLAKE8 - AttributeError: 'Application' ob...
============================== 1 failed in 0.05s ===============================
______________________________ test_keyword_match ______________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 149, in test_keyword_match
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*E201*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_keyword_match0'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 2 items / 1 deselected / 1 selected'
    and: ''
    and: 'test_keyword_match.py F                                                  [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24252d40>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -> "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '>           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -> Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0x7eff240ce8c0>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff240e5690>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff2406e8c0>'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '>           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '>               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7eff240e53f0>'
    and: ''
    and: '    def get_result(self) -> ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '>           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '>           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_keyword_match0/test_keyword_match.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
    and: '======================= 1 failed, 1 deselected in 0.06s ========================'
remains unmatched: '*E201*'
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_keyword_match0
plugins: flake8-1.1.1
collected 2 items / 1 deselected / 1 selected

test_keyword_match.py F                                                  [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24252d40>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff240ce8c0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff240e5690>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff2406e8c0>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff240e53f0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_keyword_match0/test_keyword_match.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'...
======================= 1 failed, 1 deselected in 0.06s ========================
____________________________ test_run_on_init_file _____________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 159, in test_run_on_init_file
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_run_on_init_file0
plugins: flake8-1.1.1
collected 1 item

tests/__init__.py F                                                      [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff242523b0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff245a27a0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24221600>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff24147490>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff24222f20>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_run_on_init_file0/tests/__init__.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED tests/__init__.py::flake-8::FLAKE8 - AttributeError: 'Application' obj...
============================== 1 failed in 0.05s ===============================
______________________________ test_unicode_error ______________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 167, in test_unicode_error
    f.write(py.builtin._totext("""
AttributeError: module 'py' has no attribute 'builtin'
_____________________________ test_junit_classname _____________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 192, in test_junit_classname
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-4/test_junit_classname0
plugins: flake8-1.1.1
collected 1 item

test_junit_classname.py F                                                [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7eff24150550>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7eff23fcfbb0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def traced_hookexec(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        before(hook_name, hook_impls, caller_kwargs)
        outcome = Result.from_call(
            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
        )
        after(outcome, hook_name, hook_impls, caller_kwargs)
>       return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff245ac4f0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7eff23b1cca0>

    @classmethod
    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
        """:meta private:"""
        __tracebackhide__ = True
        result = exception = None
        try:
>           result = func()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
    )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
>               return outcome.get_result()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7eff245ac4c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(exc.__traceback__)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
>           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-4/test_junit_classname0/test_junit_classname.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
- generated xml file: /tmp/pytest-of-tester/pytest-4/test_junit_classname0/TEST.xml -
=========================== short test summary info ============================
FAILED test_junit_classname.py::flake-8::FLAKE8 - AttributeError: 'Applicatio...
============================== 1 failed in 0.05s ===============================
- generated xml file: /workdir/results/pytest-flake8/1.1.1/1/cpython-test-results.xml -
=========================== short test summary info ============================
FAILED pytest_flake8.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...
FAILED setup.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...
FAILED test_flake8.py::flake-8::FLAKE8 - AttributeError: 'Application' object...
FAILED test_flake8.py::TestIgnores::test_default_flake8_ignores - AssertionEr...
FAILED test_flake8.py::TestIgnores::test_ignores_all - AssertionError: assert...
FAILED test_flake8.py::TestIgnores::test_w293w292 - Failed: nomatch: '*W293*'
FAILED test_flake8.py::TestIgnores::test_mtime_caching - Failed: nomatch: '*W...
FAILED test_flake8.py::test_ok_verbose - AssertionError: assert {'errors': 0,...
FAILED test_flake8.py::test_keyword_match - Failed: nomatch: '*E201*'
FAILED test_flake8.py::test_run_on_init_file - AssertionError: assert {'error...
FAILED test_flake8.py::test_unicode_error - AttributeError: module 'py' has n...
FAILED test_flake8.py::test_junit_classname - AssertionError: assert {'errors...
=================== 12 failed, 3 passed, 1 xfailed in 1.11s ====================
ERROR: InvocationError for command /workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/bin/pytest -v --tb=native --junitxml /workdir/results/pytest-flake8/1.1.1/1/cpython-test-results.xml (exited with code 1)
___________________________________ summary ____________________________________
ERROR:   cpythonlibtest-unit-test-tests: commands failed
