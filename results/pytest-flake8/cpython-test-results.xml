<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="12" skipped="1" tests="16" time="1.103" timestamp="2023-11-29T01:36:17.539226" hostname="a1f8948d47fc"><testcase classname="pytest_flake8.flake-8" name="FLAKE8" file="pytest_flake8.py" line="-1" time="0.001"><failure message="AttributeError: 'Application' object has no attribute 'parse_preliminary_options'">cls = &lt;class '_pytest.runner.CallInfo'&gt;
func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff2457b5b0&gt;
when = 'call'
reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -&gt; "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
&gt;           result: Optional[TResult] = func()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;HookCaller 'pytest_runtest_call'&gt;
kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def __call__(self, **kwargs: object) -&gt; Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7eff28d9e6b0&gt;
hook_name = 'pytest_runtest_call'
methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
&gt;               return outcome.get_result()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy._result.Result object at 0x7eff245aa170&gt;

    def get_result(self) -&gt; ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
&gt;           raise exc.with_traceback(exc.__traceback__)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
&gt;                       res = hook_impl.function(*args)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Flake8Item flake-8&gt;

    def pytest_runtest_call(item: Item) -&gt; None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
&gt;           raise e

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Flake8Item flake-8&gt;

    def pytest_runtest_call(item: Item) -&gt; None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
&gt;           item.runtest()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Flake8Item flake-8&gt;

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
&gt;           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/pytest_flake8.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError</failure></testcase><testcase classname="setup.flake-8" name="FLAKE8" file="setup.py" line="-1" time="0.001"><failure message="AttributeError: 'Application' object has no attribute 'parse_preliminary_options'">cls = &lt;class '_pytest.runner.CallInfo'&gt;
func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff24591900&gt;
when = 'call'
reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -&gt; "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
&gt;           result: Optional[TResult] = func()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;HookCaller 'pytest_runtest_call'&gt;
kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def __call__(self, **kwargs: object) -&gt; Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7eff28d9e6b0&gt;
hook_name = 'pytest_runtest_call'
methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
&gt;               return outcome.get_result()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy._result.Result object at 0x7eff242a0580&gt;

    def get_result(self) -&gt; ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
&gt;           raise exc.with_traceback(exc.__traceback__)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
&gt;                       res = hook_impl.function(*args)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Flake8Item flake-8&gt;

    def pytest_runtest_call(item: Item) -&gt; None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
&gt;           raise e

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Flake8Item flake-8&gt;

    def pytest_runtest_call(item: Item) -&gt; None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
&gt;           item.runtest()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Flake8Item flake-8&gt;

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
&gt;           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/setup.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError</failure></testcase><testcase classname="test_flake8.flake-8" name="FLAKE8" file="test_flake8.py" line="-1" time="0.001"><failure message="AttributeError: 'Application' object has no attribute 'parse_preliminary_options'">cls = &lt;class '_pytest.runner.CallInfo'&gt;
func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff2457b520&gt;
when = 'call'
reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -&gt; "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
&gt;           result: Optional[TResult] = func()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;HookCaller 'pytest_runtest_call'&gt;
kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def __call__(self, **kwargs: object) -&gt; Any:
        """Call the hook.
    
        Only accepts keyword arguments, which should match the hook
        specification.
    
        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert (
            not self.is_historic()
        ), "Cannot directly call a historic hook - use call_historic instead."
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7eff28d9e6b0&gt;
hook_name = 'pytest_runtest_call'
methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")
    
&gt;               return outcome.get_result()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy._result.Result object at 0x7eff24ea4310&gt;

    def get_result(self) -&gt; ResultType:
        """Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        if exc is None:
            return cast(ResultType, self._result)
        else:
&gt;           raise exc.with_traceback(exc.__traceback__)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]
caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -&gt; object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
&gt;                       res = hook_impl.function(*args)

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Flake8Item flake-8&gt;

    def pytest_runtest_call(item: Item) -&gt; None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
&gt;           raise e

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Flake8Item flake-8&gt;

    def pytest_runtest_call(item: Item) -&gt; None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
&gt;           item.runtest()

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Flake8Item flake-8&gt;

    def runtest(self):
        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
             redirect_stdout(to), redirect_stderr(te):
&gt;           found_errors = check_file(
                self.fspath,
                self.flake8ignore,
                self.maxlength,
                self.maxdoclength,
                self.maxcomplexity,
                self.showsource,
                self.statistics
            )

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/test_flake8.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError</failure></testcase><testcase classname="test_flake8" name="test_version" file="test_flake8.py" line="10" time="0.000" /><testcase classname="test_flake8.TestIgnores" name="test_ignores" file="test_flake8.py" line="30" time="0.004" /><testcase classname="test_flake8.TestIgnores" name="test_default_flake8_ignores" file="test_flake8.py" line="39" time="0.136"><failure message="AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}&#10;  Omitting 4 identical items, use -vv to show&#10;  Differing items:&#10;  {'failed': 2} != {'failed': 0}&#10;  {'passed': 0} != {'passed': 2}&#10;  Full diff:&#10;    {&#10;     'errors': 0,...&#10;  &#10;  ...Full output truncated (12 lines hidden), use '-vv' to show">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 53, in test_default_flake8_ignores
    result.assert_outcomes(passed=2)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 2} != {'failed': 0}
  {'passed': 0} != {'passed': 2}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show</failure></testcase><testcase classname="test_flake8.TestIgnores" name="test_ignores_all" file="test_flake8.py" line="59" time="0.085"><failure message="AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}&#10;  Omitting 4 identical items, use -vv to show&#10;  Differing items:&#10;  {'failed': 1} != {'failed': 0}&#10;  {'passed': 0} != {'passed': 1}&#10;  Full diff:&#10;    {&#10;     'errors': 0,...&#10;  &#10;  ...Full output truncated (12 lines hidden), use '-vv' to show">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 72, in test_ignores_all
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show</failure></testcase><testcase classname="test_flake8.TestIgnores" name="test_w293w292" file="test_flake8.py" line="78" time="0.089"><failure message="Failed: nomatch: '*W293*'&#10;    and: '============================= test session starts =============================='&#10;    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'&#10;    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_w293w2920'&#10;    and: 'plugins: flake8-1.1.1'&#10;    and: 'collected 1 item'&#10;    and: ''&#10;    and: 'test_w293w292.py F                                                       [100%]'&#10;    and: ''&#10;    and: '=================================== FAILURES ==================================='&#10;    and: '_________________________________ FLAKE8-check _________________________________'&#10;    and: ''&#10;    and: &quot;cls = &lt;class '_pytest.runner.CallInfo'&gt;&quot;&#10;    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e560&gt;'&#10;    and: &quot;when = 'call'&quot;&#10;    and: &quot;reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)&quot;&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call('&#10;    and: '        cls,'&#10;    and: '        func: &quot;Callable[[], TResult]&quot;,'&#10;    and: '        when: &quot;Literal[\'collect\', \'setup\', \'call\', \'teardown\']&quot;,'&#10;    and: '        reraise: Optional['&#10;    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'&#10;    and: '        ] = None,'&#10;    and: '    ) -&gt; &quot;CallInfo[TResult]&quot;:'&#10;    and: '        &quot;&quot;&quot;Call func, wrapping the result in a CallInfo.'&#10;    and: '    '&#10;    and: '        :param func:'&#10;    and: '            The function to call. Called without arguments.'&#10;    and: '        :param when:'&#10;    and: '            The phase in which the function is called.'&#10;    and: '        :param reraise:'&#10;    and: '            Exception or exceptions that shall propagate if raised by the'&#10;    and: '            function, instead of being wrapped in the CallInfo.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        excinfo = None'&#10;    and: '        start = timing.time()'&#10;    and: '        precise_start = timing.perf_counter()'&#10;    and: '        try:'&#10;    and: '&gt;           result: Optional[TResult] = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;self = &lt;HookCaller 'pytest_runtest_call'&gt;&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def __call__(self, **kwargs: object) -&gt; Any:'&#10;    and: '        &quot;&quot;&quot;Call the hook.'&#10;    and: '    '&#10;    and: '        Only accepts keyword arguments, which should match the hook'&#10;    and: '        specification.'&#10;    and: '    '&#10;    and: '        Returns the result(s) of calling all registered plugins, see'&#10;    and: '        :ref:`calling`.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        assert ('&#10;    and: '            not self.is_historic()'&#10;    and: '        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;'&#10;    and: '        self._verify_all_args_are_provided(kwargs)'&#10;    and: '        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False'&#10;    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff2424db40&gt;'&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _hookexec('&#10;    and: '        self,'&#10;    and: '        hook_name: str,'&#10;    and: '        methods: Sequence[HookImpl],'&#10;    and: '        kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        # called from all hookcaller instances.'&#10;    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'&#10;    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def traced_hookexec('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        before(hook_name, hook_impls, caller_kwargs)'&#10;    and: '        outcome = Result.from_call('&#10;    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '        )'&#10;    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'&#10;    and: '&gt;       return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff245a7cd0&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;cls = &lt;class 'pluggy._result.Result'&gt;&quot;&#10;    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e4d0&gt;'&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'&#10;    and: '        &quot;&quot;&quot;:meta private:&quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        result = exception = None'&#10;    and: '        try:'&#10;    and: '&gt;           result = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '                        res = hook_impl.function(*args)'&#10;    and: '                        if res is not None:'&#10;    and: '                            results.append(res)'&#10;    and: '                            if firstresult:  # halt further impl calls'&#10;    and: '                                break'&#10;    and: '            except BaseException as exc:'&#10;    and: '                exception = exc'&#10;    and: '        finally:'&#10;    and: '            # Fast path - only new-style wrappers, no Result.'&#10;    and: '            if only_new_style_wrappers:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    result = results[0] if results else None'&#10;    and: '                else:'&#10;    and: '                    result = results'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    try:'&#10;    and: '                        if exception is not None:'&#10;    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'&#10;    and: '                        else:'&#10;    and: '                            teardown.send(result)  # type: ignore[union-attr]'&#10;    and: '                        # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                        # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                        # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                        teardown.close()  # type: ignore[union-attr]'&#10;    and: '                    except StopIteration as si:'&#10;    and: '                        result = si.value'&#10;    and: '                        exception = None'&#10;    and: '                        continue'&#10;    and: '                    except BaseException as e:'&#10;    and: '                        exception = e'&#10;    and: '                        continue'&#10;    and: '                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]'&#10;    and: '    '&#10;    and: '                if exception is not None:'&#10;    and: '                    raise exception.with_traceback(exception.__traceback__)'&#10;    and: '                else:'&#10;    and: '                    return result'&#10;    and: '    '&#10;    and: '            # Slow path - need to support old-style wrappers.'&#10;    and: '            else:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    outcome: Result[object | list[object]] = Result('&#10;    and: '                        results[0] if results else None, exception'&#10;    and: '                    )'&#10;    and: '                else:'&#10;    and: '                    outcome = Result(results, exception)'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    if isinstance(teardown, tuple):'&#10;    and: '                        try:'&#10;    and: '                            teardown[0].send(outcome)'&#10;    and: '                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            pass'&#10;    and: '                    else:'&#10;    and: '                        try:'&#10;    and: '                            if outcome._exception is not None:'&#10;    and: '                                teardown.throw(outcome._exception)'&#10;    and: '                            else:'&#10;    and: '                                teardown.send(outcome._result)'&#10;    and: '                            # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                            # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                            # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                            teardown.close()'&#10;    and: '                        except StopIteration as si:'&#10;    and: '                            outcome.force_result(si.value)'&#10;    and: '                            continue'&#10;    and: '                        except BaseException as e:'&#10;    and: '                            outcome.force_exception(e)'&#10;    and: '                            continue'&#10;    and: '                        _raise_wrapfail(teardown, &quot;has second yield&quot;)'&#10;    and: '    '&#10;    and: '&gt;               return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff245a50c0&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '&gt;                       res = hook_impl.function(*args)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '            item.runtest()'&#10;    and: '        except Exception as e:'&#10;    and: '            # Store trace info to allow postmortem debugging'&#10;    and: '            sys.last_type = type(e)'&#10;    and: '            sys.last_value = e'&#10;    and: '            assert e.__traceback__ is not None'&#10;    and: '            # Skip *this* frame'&#10;    and: '            sys.last_traceback = e.__traceback__.tb_next'&#10;    and: '&gt;           raise e'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '&gt;           item.runtest()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def runtest(self):'&#10;    and: &quot;        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\&quot;&#10;    and: &quot;             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\&quot;&#10;    and: '             redirect_stdout(to), redirect_stderr(te):'&#10;    and: '&gt;           found_errors = check_file('&#10;    and: '                self.fspath,'&#10;    and: '                self.flake8ignore,'&#10;    and: '                self.maxlength,'&#10;    and: '                self.maxdoclength,'&#10;    and: '                self.maxcomplexity,'&#10;    and: '                self.showsource,'&#10;    and: '                self.statistics'&#10;    and: '            )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;path = local('/tmp/pytest-of-tester/pytest-4/test_w293w2920/test_w293w292.py')&quot;&#10;    and: &quot;flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''&quot;&#10;    and: 'showsource = [], statistics = []'&#10;    and: ''&#10;    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'&#10;    and: '                   showsource, statistics):'&#10;    and: '        &quot;&quot;&quot;Run flake8 over a single file, and return the number of failures.&quot;&quot;&quot;'&#10;    and: '        args = []'&#10;    and: '        if maxlength:'&#10;    and: &quot;            args += ['--max-line-length', maxlength]&quot;&#10;    and: '        if maxdoclenght:'&#10;    and: &quot;            args += ['--max-doc-length', maxdoclenght]&quot;&#10;    and: '        if maxcomplexity:'&#10;    and: &quot;            args += ['--max-complexity', maxcomplexity]&quot;&#10;    and: '        if showsource:'&#10;    and: &quot;            args += ['--show-source']&quot;&#10;    and: '        if statistics:'&#10;    and: &quot;            args += ['--statistics']&quot;&#10;    and: '        app = application.Application()'&#10;    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'&#10;    and: &quot;E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'&quot;&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'&#10;    and: '=========================== short test summary info ============================'&#10;    and: &quot;FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...&quot;&#10;    and: '============================== 1 failed in 0.05s ==============================='&#10;remains unmatched: '*W293*'">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 81, in test_w293w292
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*W293*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_w293w2920'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 1 item'
    and: ''
    and: 'test_w293w292.py F                                                       [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = &lt;class '_pytest.runner.CallInfo'&gt;"
    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e560&gt;'
    and: "when = 'call'"
    and: "reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -&gt; "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '&gt;           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = &lt;HookCaller 'pytest_runtest_call'&gt;"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -&gt; Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff2424db40&gt;'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '&gt;       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff245a7cd0&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = &lt;class 'pluggy._result.Result'&gt;"
    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e4d0&gt;'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '&gt;           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '&gt;               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff245a50c0&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '&gt;                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '&gt;           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '&gt;           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '&gt;           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_w293w2920/test_w293w292.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje..."
    and: '============================== 1 failed in 0.05s ==============================='
remains unmatched: '*W293*'</failure></testcase><testcase classname="test_flake8.TestIgnores" name="test_mtime_caching" file="test_flake8.py" line="87" time="0.147"><failure message="Failed: nomatch: '*W293*'&#10;    and: '============================= test session starts =============================='&#10;    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'&#10;    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_mtime_caching0'&#10;    and: 'plugins: flake8-1.1.1'&#10;    and: 'collected 2 items'&#10;    and: ''&#10;    and: 'hello.py F                                                               [ 50%]'&#10;    and: 'test_mtime_caching.py F                                                  [100%]'&#10;    and: ''&#10;    and: '=================================== FAILURES ==================================='&#10;    and: '_________________________________ FLAKE8-check _________________________________'&#10;    and: ''&#10;    and: &quot;cls = &lt;class '_pytest.runner.CallInfo'&gt;&quot;&#10;    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e560&gt;'&#10;    and: &quot;when = 'call'&quot;&#10;    and: &quot;reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)&quot;&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call('&#10;    and: '        cls,'&#10;    and: '        func: &quot;Callable[[], TResult]&quot;,'&#10;    and: '        when: &quot;Literal[\'collect\', \'setup\', \'call\', \'teardown\']&quot;,'&#10;    and: '        reraise: Optional['&#10;    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'&#10;    and: '        ] = None,'&#10;    and: '    ) -&gt; &quot;CallInfo[TResult]&quot;:'&#10;    and: '        &quot;&quot;&quot;Call func, wrapping the result in a CallInfo.'&#10;    and: '    '&#10;    and: '        :param func:'&#10;    and: '            The function to call. Called without arguments.'&#10;    and: '        :param when:'&#10;    and: '            The phase in which the function is called.'&#10;    and: '        :param reraise:'&#10;    and: '            Exception or exceptions that shall propagate if raised by the'&#10;    and: '            function, instead of being wrapped in the CallInfo.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        excinfo = None'&#10;    and: '        start = timing.time()'&#10;    and: '        precise_start = timing.perf_counter()'&#10;    and: '        try:'&#10;    and: '&gt;           result: Optional[TResult] = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;self = &lt;HookCaller 'pytest_runtest_call'&gt;&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def __call__(self, **kwargs: object) -&gt; Any:'&#10;    and: '        &quot;&quot;&quot;Call the hook.'&#10;    and: '    '&#10;    and: '        Only accepts keyword arguments, which should match the hook'&#10;    and: '        specification.'&#10;    and: '    '&#10;    and: '        Returns the result(s) of calling all registered plugins, see'&#10;    and: '        :ref:`calling`.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        assert ('&#10;    and: '            not self.is_historic()'&#10;    and: '        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;'&#10;    and: '        self._verify_all_args_are_provided(kwargs)'&#10;    and: '        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False'&#10;    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff24241bd0&gt;'&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _hookexec('&#10;    and: '        self,'&#10;    and: '        hook_name: str,'&#10;    and: '        methods: Sequence[HookImpl],'&#10;    and: '        kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        # called from all hookcaller instances.'&#10;    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'&#10;    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def traced_hookexec('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        before(hook_name, hook_impls, caller_kwargs)'&#10;    and: '        outcome = Result.from_call('&#10;    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '        )'&#10;    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'&#10;    and: '&gt;       return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff23fcbc10&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;cls = &lt;class 'pluggy._result.Result'&gt;&quot;&#10;    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1c550&gt;'&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'&#10;    and: '        &quot;&quot;&quot;:meta private:&quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        result = exception = None'&#10;    and: '        try:'&#10;    and: '&gt;           result = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '                        res = hook_impl.function(*args)'&#10;    and: '                        if res is not None:'&#10;    and: '                            results.append(res)'&#10;    and: '                            if firstresult:  # halt further impl calls'&#10;    and: '                                break'&#10;    and: '            except BaseException as exc:'&#10;    and: '                exception = exc'&#10;    and: '        finally:'&#10;    and: '            # Fast path - only new-style wrappers, no Result.'&#10;    and: '            if only_new_style_wrappers:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    result = results[0] if results else None'&#10;    and: '                else:'&#10;    and: '                    result = results'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    try:'&#10;    and: '                        if exception is not None:'&#10;    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'&#10;    and: '                        else:'&#10;    and: '                            teardown.send(result)  # type: ignore[union-attr]'&#10;    and: '                        # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                        # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                        # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                        teardown.close()  # type: ignore[union-attr]'&#10;    and: '                    except StopIteration as si:'&#10;    and: '                        result = si.value'&#10;    and: '                        exception = None'&#10;    and: '                        continue'&#10;    and: '                    except BaseException as e:'&#10;    and: '                        exception = e'&#10;    and: '                        continue'&#10;    and: '                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]'&#10;    and: '    '&#10;    and: '                if exception is not None:'&#10;    and: '                    raise exception.with_traceback(exception.__traceback__)'&#10;    and: '                else:'&#10;    and: '                    return result'&#10;    and: '    '&#10;    and: '            # Slow path - need to support old-style wrappers.'&#10;    and: '            else:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    outcome: Result[object | list[object]] = Result('&#10;    and: '                        results[0] if results else None, exception'&#10;    and: '                    )'&#10;    and: '                else:'&#10;    and: '                    outcome = Result(results, exception)'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    if isinstance(teardown, tuple):'&#10;    and: '                        try:'&#10;    and: '                            teardown[0].send(outcome)'&#10;    and: '                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            pass'&#10;    and: '                    else:'&#10;    and: '                        try:'&#10;    and: '                            if outcome._exception is not None:'&#10;    and: '                                teardown.throw(outcome._exception)'&#10;    and: '                            else:'&#10;    and: '                                teardown.send(outcome._result)'&#10;    and: '                            # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                            # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                            # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                            teardown.close()'&#10;    and: '                        except StopIteration as si:'&#10;    and: '                            outcome.force_result(si.value)'&#10;    and: '                            continue'&#10;    and: '                        except BaseException as e:'&#10;    and: '                            outcome.force_exception(e)'&#10;    and: '                            continue'&#10;    and: '                        _raise_wrapfail(teardown, &quot;has second yield&quot;)'&#10;    and: '    '&#10;    and: '&gt;               return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff23fc9390&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '&gt;                       res = hook_impl.function(*args)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '            item.runtest()'&#10;    and: '        except Exception as e:'&#10;    and: '            # Store trace info to allow postmortem debugging'&#10;    and: '            sys.last_type = type(e)'&#10;    and: '            sys.last_value = e'&#10;    and: '            assert e.__traceback__ is not None'&#10;    and: '            # Skip *this* frame'&#10;    and: '            sys.last_traceback = e.__traceback__.tb_next'&#10;    and: '&gt;           raise e'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '&gt;           item.runtest()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def runtest(self):'&#10;    and: &quot;        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\&quot;&#10;    and: &quot;             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\&quot;&#10;    and: '             redirect_stdout(to), redirect_stderr(te):'&#10;    and: '&gt;           found_errors = check_file('&#10;    and: '                self.fspath,'&#10;    and: '                self.flake8ignore,'&#10;    and: '                self.maxlength,'&#10;    and: '                self.maxdoclength,'&#10;    and: '                self.maxcomplexity,'&#10;    and: '                self.showsource,'&#10;    and: '                self.statistics'&#10;    and: '            )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/hello.py')&quot;&#10;    and: &quot;flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''&quot;&#10;    and: 'showsource = [], statistics = []'&#10;    and: ''&#10;    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'&#10;    and: '                   showsource, statistics):'&#10;    and: '        &quot;&quot;&quot;Run flake8 over a single file, and return the number of failures.&quot;&quot;&quot;'&#10;    and: '        args = []'&#10;    and: '        if maxlength:'&#10;    and: &quot;            args += ['--max-line-length', maxlength]&quot;&#10;    and: '        if maxdoclenght:'&#10;    and: &quot;            args += ['--max-doc-length', maxdoclenght]&quot;&#10;    and: '        if maxcomplexity:'&#10;    and: &quot;            args += ['--max-complexity', maxcomplexity]&quot;&#10;    and: '        if showsource:'&#10;    and: &quot;            args += ['--show-source']&quot;&#10;    and: '        if statistics:'&#10;    and: &quot;            args += ['--statistics']&quot;&#10;    and: '        app = application.Application()'&#10;    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'&#10;    and: &quot;E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'&quot;&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'&#10;    and: '_________________________________ FLAKE8-check _________________________________'&#10;    and: ''&#10;    and: &quot;cls = &lt;class '_pytest.runner.CallInfo'&gt;&quot;&#10;    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e4d0&gt;'&#10;    and: &quot;when = 'call'&quot;&#10;    and: &quot;reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)&quot;&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call('&#10;    and: '        cls,'&#10;    and: '        func: &quot;Callable[[], TResult]&quot;,'&#10;    and: '        when: &quot;Literal[\'collect\', \'setup\', \'call\', \'teardown\']&quot;,'&#10;    and: '        reraise: Optional['&#10;    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'&#10;    and: '        ] = None,'&#10;    and: '    ) -&gt; &quot;CallInfo[TResult]&quot;:'&#10;    and: '        &quot;&quot;&quot;Call func, wrapping the result in a CallInfo.'&#10;    and: '    '&#10;    and: '        :param func:'&#10;    and: '            The function to call. Called without arguments.'&#10;    and: '        :param when:'&#10;    and: '            The phase in which the function is called.'&#10;    and: '        :param reraise:'&#10;    and: '            Exception or exceptions that shall propagate if raised by the'&#10;    and: '            function, instead of being wrapped in the CallInfo.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        excinfo = None'&#10;    and: '        start = timing.time()'&#10;    and: '        precise_start = timing.perf_counter()'&#10;    and: '        try:'&#10;    and: '&gt;           result: Optional[TResult] = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;self = &lt;HookCaller 'pytest_runtest_call'&gt;&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def __call__(self, **kwargs: object) -&gt; Any:'&#10;    and: '        &quot;&quot;&quot;Call the hook.'&#10;    and: '    '&#10;    and: '        Only accepts keyword arguments, which should match the hook'&#10;    and: '        specification.'&#10;    and: '    '&#10;    and: '        Returns the result(s) of calling all registered plugins, see'&#10;    and: '        :ref:`calling`.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        assert ('&#10;    and: '            not self.is_historic()'&#10;    and: '        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;'&#10;    and: '        self._verify_all_args_are_provided(kwargs)'&#10;    and: '        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False'&#10;    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff24241bd0&gt;'&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _hookexec('&#10;    and: '        self,'&#10;    and: '        hook_name: str,'&#10;    and: '        methods: Sequence[HookImpl],'&#10;    and: '        kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        # called from all hookcaller instances.'&#10;    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'&#10;    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def traced_hookexec('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        before(hook_name, hook_impls, caller_kwargs)'&#10;    and: '        outcome = Result.from_call('&#10;    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '        )'&#10;    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'&#10;    and: '&gt;       return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff24ea4940&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;cls = &lt;class 'pluggy._result.Result'&gt;&quot;&#10;    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1c3a0&gt;'&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'&#10;    and: '        &quot;&quot;&quot;:meta private:&quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        result = exception = None'&#10;    and: '        try:'&#10;    and: '&gt;           result = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '                        res = hook_impl.function(*args)'&#10;    and: '                        if res is not None:'&#10;    and: '                            results.append(res)'&#10;    and: '                            if firstresult:  # halt further impl calls'&#10;    and: '                                break'&#10;    and: '            except BaseException as exc:'&#10;    and: '                exception = exc'&#10;    and: '        finally:'&#10;    and: '            # Fast path - only new-style wrappers, no Result.'&#10;    and: '            if only_new_style_wrappers:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    result = results[0] if results else None'&#10;    and: '                else:'&#10;    and: '                    result = results'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    try:'&#10;    and: '                        if exception is not None:'&#10;    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'&#10;    and: '                        else:'&#10;    and: '                            teardown.send(result)  # type: ignore[union-attr]'&#10;    and: '                        # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                        # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                        # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                        teardown.close()  # type: ignore[union-attr]'&#10;    and: '                    except StopIteration as si:'&#10;    and: '                        result = si.value'&#10;    and: '                        exception = None'&#10;    and: '                        continue'&#10;    and: '                    except BaseException as e:'&#10;    and: '                        exception = e'&#10;    and: '                        continue'&#10;    and: '                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]'&#10;    and: '    '&#10;    and: '                if exception is not None:'&#10;    and: '                    raise exception.with_traceback(exception.__traceback__)'&#10;    and: '                else:'&#10;    and: '                    return result'&#10;    and: '    '&#10;    and: '            # Slow path - need to support old-style wrappers.'&#10;    and: '            else:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    outcome: Result[object | list[object]] = Result('&#10;    and: '                        results[0] if results else None, exception'&#10;    and: '                    )'&#10;    and: '                else:'&#10;    and: '                    outcome = Result(results, exception)'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    if isinstance(teardown, tuple):'&#10;    and: '                        try:'&#10;    and: '                            teardown[0].send(outcome)'&#10;    and: '                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            pass'&#10;    and: '                    else:'&#10;    and: '                        try:'&#10;    and: '                            if outcome._exception is not None:'&#10;    and: '                                teardown.throw(outcome._exception)'&#10;    and: '                            else:'&#10;    and: '                                teardown.send(outcome._result)'&#10;    and: '                            # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                            # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                            # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                            teardown.close()'&#10;    and: '                        except StopIteration as si:'&#10;    and: '                            outcome.force_result(si.value)'&#10;    and: '                            continue'&#10;    and: '                        except BaseException as e:'&#10;    and: '                            outcome.force_exception(e)'&#10;    and: '                            continue'&#10;    and: '                        _raise_wrapfail(teardown, &quot;has second yield&quot;)'&#10;    and: '    '&#10;    and: '&gt;               return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff24ea4cd0&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '&gt;                       res = hook_impl.function(*args)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '            item.runtest()'&#10;    and: '        except Exception as e:'&#10;    and: '            # Store trace info to allow postmortem debugging'&#10;    and: '            sys.last_type = type(e)'&#10;    and: '            sys.last_value = e'&#10;    and: '            assert e.__traceback__ is not None'&#10;    and: '            # Skip *this* frame'&#10;    and: '            sys.last_traceback = e.__traceback__.tb_next'&#10;    and: '&gt;           raise e'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '&gt;           item.runtest()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def runtest(self):'&#10;    and: &quot;        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\&quot;&#10;    and: &quot;             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\&quot;&#10;    and: '             redirect_stdout(to), redirect_stderr(te):'&#10;    and: '&gt;           found_errors = check_file('&#10;    and: '                self.fspath,'&#10;    and: '                self.flake8ignore,'&#10;    and: '                self.maxlength,'&#10;    and: '                self.maxdoclength,'&#10;    and: '                self.maxcomplexity,'&#10;    and: '                self.showsource,'&#10;    and: '                self.statistics'&#10;    and: '            )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/test_mtime_caching.py')&quot;&#10;    and: &quot;flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''&quot;&#10;    and: 'showsource = [], statistics = []'&#10;    and: ''&#10;    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'&#10;    and: '                   showsource, statistics):'&#10;    and: '        &quot;&quot;&quot;Run flake8 over a single file, and return the number of failures.&quot;&quot;&quot;'&#10;    and: '        args = []'&#10;    and: '        if maxlength:'&#10;    and: &quot;            args += ['--max-line-length', maxlength]&quot;&#10;    and: '        if maxdoclenght:'&#10;    and: &quot;            args += ['--max-doc-length', maxdoclenght]&quot;&#10;    and: '        if maxcomplexity:'&#10;    and: &quot;            args += ['--max-complexity', maxcomplexity]&quot;&#10;    and: '        if showsource:'&#10;    and: &quot;            args += ['--show-source']&quot;&#10;    and: '        if statistics:'&#10;    and: &quot;            args += ['--statistics']&quot;&#10;    and: '        app = application.Application()'&#10;    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'&#10;    and: &quot;E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'&quot;&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'&#10;    and: '=========================== short test summary info ============================'&#10;    and: &quot;FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...&quot;&#10;    and: &quot;FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'...&quot;&#10;    and: '============================== 2 failed in 0.10s ==============================='&#10;remains unmatched: '*W293*'">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 91, in test_mtime_caching
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*W293*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_mtime_caching0'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 2 items'
    and: ''
    and: 'hello.py F                                                               [ 50%]'
    and: 'test_mtime_caching.py F                                                  [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = &lt;class '_pytest.runner.CallInfo'&gt;"
    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e560&gt;'
    and: "when = 'call'"
    and: "reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -&gt; "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '&gt;           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = &lt;HookCaller 'pytest_runtest_call'&gt;"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -&gt; Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff24241bd0&gt;'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '&gt;       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff23fcbc10&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = &lt;class 'pluggy._result.Result'&gt;"
    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1c550&gt;'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '&gt;           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '&gt;               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff23fc9390&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '&gt;                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '&gt;           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '&gt;           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '&gt;           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/hello.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = &lt;class '_pytest.runner.CallInfo'&gt;"
    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1e4d0&gt;'
    and: "when = 'call'"
    and: "reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -&gt; "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '&gt;           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = &lt;HookCaller 'pytest_runtest_call'&gt;"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -&gt; Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff24241bd0&gt;'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '&gt;       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff24ea4940&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = &lt;class 'pluggy._result.Result'&gt;"
    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff23b1c3a0&gt;'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '&gt;           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '&gt;               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff24ea4cd0&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '&gt;                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '&gt;           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '&gt;           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '&gt;           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_mtime_caching0/test_mtime_caching.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n..."
    and: "FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
    and: '============================== 2 failed in 0.10s ==============================='
remains unmatched: '*W293*'</failure></testcase><testcase classname="test_flake8" name="test_extensions" file="test_flake8.py" line="110" time="0.080" /><testcase classname="test_flake8" name="test_ok_verbose" file="test_flake8.py" line="128" time="0.079"><failure message="AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}&#10;  Omitting 4 identical items, use -vv to show&#10;  Differing items:&#10;  {'failed': 1} != {'failed': 0}&#10;  {'passed': 0} != {'passed': 1}&#10;  Full diff:&#10;    {&#10;     'errors': 0,...&#10;  &#10;  ...Full output truncated (12 lines hidden), use '-vv' to show">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 139, in test_ok_verbose
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show</failure></testcase><testcase classname="test_flake8" name="test_keyword_match" file="test_flake8.py" line="141" time="0.092"><failure message="Failed: nomatch: '*E201*'&#10;    and: '============================= test session starts =============================='&#10;    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'&#10;    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_keyword_match0'&#10;    and: 'plugins: flake8-1.1.1'&#10;    and: 'collected 2 items / 1 deselected / 1 selected'&#10;    and: ''&#10;    and: 'test_keyword_match.py F                                                  [100%]'&#10;    and: ''&#10;    and: '=================================== FAILURES ==================================='&#10;    and: '_________________________________ FLAKE8-check _________________________________'&#10;    and: ''&#10;    and: &quot;cls = &lt;class '_pytest.runner.CallInfo'&gt;&quot;&#10;    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff24252d40&gt;'&#10;    and: &quot;when = 'call'&quot;&#10;    and: &quot;reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)&quot;&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call('&#10;    and: '        cls,'&#10;    and: '        func: &quot;Callable[[], TResult]&quot;,'&#10;    and: '        when: &quot;Literal[\'collect\', \'setup\', \'call\', \'teardown\']&quot;,'&#10;    and: '        reraise: Optional['&#10;    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'&#10;    and: '        ] = None,'&#10;    and: '    ) -&gt; &quot;CallInfo[TResult]&quot;:'&#10;    and: '        &quot;&quot;&quot;Call func, wrapping the result in a CallInfo.'&#10;    and: '    '&#10;    and: '        :param func:'&#10;    and: '            The function to call. Called without arguments.'&#10;    and: '        :param when:'&#10;    and: '            The phase in which the function is called.'&#10;    and: '        :param reraise:'&#10;    and: '            Exception or exceptions that shall propagate if raised by the'&#10;    and: '            function, instead of being wrapped in the CallInfo.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        excinfo = None'&#10;    and: '        start = timing.time()'&#10;    and: '        precise_start = timing.perf_counter()'&#10;    and: '        try:'&#10;    and: '&gt;           result: Optional[TResult] = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;self = &lt;HookCaller 'pytest_runtest_call'&gt;&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def __call__(self, **kwargs: object) -&gt; Any:'&#10;    and: '        &quot;&quot;&quot;Call the hook.'&#10;    and: '    '&#10;    and: '        Only accepts keyword arguments, which should match the hook'&#10;    and: '        specification.'&#10;    and: '    '&#10;    and: '        Returns the result(s) of calling all registered plugins, see'&#10;    and: '        :ref:`calling`.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        assert ('&#10;    and: '            not self.is_historic()'&#10;    and: '        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;'&#10;    and: '        self._verify_all_args_are_provided(kwargs)'&#10;    and: '        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False'&#10;    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff240ce8c0&gt;'&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _hookexec('&#10;    and: '        self,'&#10;    and: '        hook_name: str,'&#10;    and: '        methods: Sequence[HookImpl],'&#10;    and: '        kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        # called from all hookcaller instances.'&#10;    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'&#10;    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def traced_hookexec('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        before(hook_name, hook_impls, caller_kwargs)'&#10;    and: '        outcome = Result.from_call('&#10;    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '        )'&#10;    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'&#10;    and: '&gt;       return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff240e5690&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;cls = &lt;class 'pluggy._result.Result'&gt;&quot;&#10;    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff2406e8c0&gt;'&#10;    and: ''&#10;    and: '    @classmethod'&#10;    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'&#10;    and: '        &quot;&quot;&quot;:meta private:&quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        result = exception = None'&#10;    and: '        try:'&#10;    and: '&gt;           result = func()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'&#10;    and: '    )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '                        res = hook_impl.function(*args)'&#10;    and: '                        if res is not None:'&#10;    and: '                            results.append(res)'&#10;    and: '                            if firstresult:  # halt further impl calls'&#10;    and: '                                break'&#10;    and: '            except BaseException as exc:'&#10;    and: '                exception = exc'&#10;    and: '        finally:'&#10;    and: '            # Fast path - only new-style wrappers, no Result.'&#10;    and: '            if only_new_style_wrappers:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    result = results[0] if results else None'&#10;    and: '                else:'&#10;    and: '                    result = results'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    try:'&#10;    and: '                        if exception is not None:'&#10;    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'&#10;    and: '                        else:'&#10;    and: '                            teardown.send(result)  # type: ignore[union-attr]'&#10;    and: '                        # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                        # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                        # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                        teardown.close()  # type: ignore[union-attr]'&#10;    and: '                    except StopIteration as si:'&#10;    and: '                        result = si.value'&#10;    and: '                        exception = None'&#10;    and: '                        continue'&#10;    and: '                    except BaseException as e:'&#10;    and: '                        exception = e'&#10;    and: '                        continue'&#10;    and: '                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]'&#10;    and: '    '&#10;    and: '                if exception is not None:'&#10;    and: '                    raise exception.with_traceback(exception.__traceback__)'&#10;    and: '                else:'&#10;    and: '                    return result'&#10;    and: '    '&#10;    and: '            # Slow path - need to support old-style wrappers.'&#10;    and: '            else:'&#10;    and: '                if firstresult:  # first result hooks return a single value'&#10;    and: '                    outcome: Result[object | list[object]] = Result('&#10;    and: '                        results[0] if results else None, exception'&#10;    and: '                    )'&#10;    and: '                else:'&#10;    and: '                    outcome = Result(results, exception)'&#10;    and: '    '&#10;    and: '                # run all wrapper post-yield blocks'&#10;    and: '                for teardown in reversed(teardowns):'&#10;    and: '                    if isinstance(teardown, tuple):'&#10;    and: '                        try:'&#10;    and: '                            teardown[0].send(outcome)'&#10;    and: '                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            pass'&#10;    and: '                    else:'&#10;    and: '                        try:'&#10;    and: '                            if outcome._exception is not None:'&#10;    and: '                                teardown.throw(outcome._exception)'&#10;    and: '                            else:'&#10;    and: '                                teardown.send(outcome._result)'&#10;    and: '                            # Following is unreachable for a well behaved hook wrapper.'&#10;    and: '                            # Try to force finalizers otherwise postponed till GC action.'&#10;    and: '                            # Note: close() may raise if generator handles GeneratorExit.'&#10;    and: '                            teardown.close()'&#10;    and: '                        except StopIteration as si:'&#10;    and: '                            outcome.force_result(si.value)'&#10;    and: '                            continue'&#10;    and: '                        except BaseException as e:'&#10;    and: '                            outcome.force_exception(e)'&#10;    and: '                            continue'&#10;    and: '                        _raise_wrapfail(teardown, &quot;has second yield&quot;)'&#10;    and: '    '&#10;    and: '&gt;               return outcome.get_result()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;pluggy._result.Result object at 0x7eff240e53f0&gt;'&#10;    and: ''&#10;    and: '    def get_result(self) -&gt; ResultType:'&#10;    and: '        &quot;&quot;&quot;Get the result(s) for this hook call.'&#10;    and: '    '&#10;    and: '        If the hook was marked as a ``firstresult`` only a single value'&#10;    and: '        will be returned, otherwise a list of results.'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        exc = self._exception'&#10;    and: '        if exc is None:'&#10;    and: '            return cast(ResultType, self._result)'&#10;    and: '        else:'&#10;    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;hook_name = 'pytest_runtest_call'&quot;&#10;    and: &quot;hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]&quot;&#10;    and: &quot;caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False&quot;&#10;    and: ''&#10;    and: '    def _multicall('&#10;    and: '        hook_name: str,'&#10;    and: '        hook_impls: Sequence[HookImpl],'&#10;    and: '        caller_kwargs: Mapping[str, object],'&#10;    and: '        firstresult: bool,'&#10;    and: '    ) -&gt; object | list[object]:'&#10;    and: '        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the'&#10;    and: '        result(s).'&#10;    and: '    '&#10;    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'&#10;    and: '        &quot;&quot;&quot;'&#10;    and: '        __tracebackhide__ = True'&#10;    and: '        results: list[object] = []'&#10;    and: '        exception = None'&#10;    and: '        only_new_style_wrappers = True'&#10;    and: '        try:  # run impl and wrapper setup functions in a loop'&#10;    and: '            teardowns: list[Teardown] = []'&#10;    and: '            try:'&#10;    and: '                for hook_impl in reversed(hook_impls):'&#10;    and: '                    try:'&#10;    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'&#10;    and: '                    except KeyError:'&#10;    and: '                        for argname in hook_impl.argnames:'&#10;    and: '                            if argname not in caller_kwargs:'&#10;    and: '                                raise HookCallError('&#10;    and: '                                    f&quot;hook call must provide argument {argname!r}&quot;'&#10;    and: '                                )'&#10;    and: '    '&#10;    and: '                    if hook_impl.hookwrapper:'&#10;    and: '                        only_new_style_wrappers = False'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'&#10;    and: '                            next(wrapper_gen)  # first yield'&#10;    and: '                            teardowns.append((wrapper_gen,))'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)'&#10;    and: '                    elif hook_impl.wrapper:'&#10;    and: '                        try:'&#10;    and: '                            # If this cast is not valid, a type error is raised below,'&#10;    and: '                            # which is the desired response.'&#10;    and: '                            res = hook_impl.function(*args)'&#10;    and: '                            function_gen = cast(Generator[None, object, object], res)'&#10;    and: '                            next(function_gen)  # first yield'&#10;    and: '                            teardowns.append(function_gen)'&#10;    and: '                        except StopIteration:'&#10;    and: '                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)'&#10;    and: '                    else:'&#10;    and: '&gt;                       res = hook_impl.function(*args)'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '            item.runtest()'&#10;    and: '        except Exception as e:'&#10;    and: '            # Store trace info to allow postmortem debugging'&#10;    and: '            sys.last_type = type(e)'&#10;    and: '            sys.last_value = e'&#10;    and: '            assert e.__traceback__ is not None'&#10;    and: '            # Skip *this* frame'&#10;    and: '            sys.last_traceback = e.__traceback__.tb_next'&#10;    and: '&gt;           raise e'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'item = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def pytest_runtest_call(item: Item) -&gt; None:'&#10;    and: '        _update_current_test_var(item, &quot;call&quot;)'&#10;    and: '        try:'&#10;    and: '            del sys.last_type'&#10;    and: '            del sys.last_value'&#10;    and: '            del sys.last_traceback'&#10;    and: '        except AttributeError:'&#10;    and: '            pass'&#10;    and: '        try:'&#10;    and: '&gt;           item.runtest()'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: 'self = &lt;Flake8Item flake-8&gt;'&#10;    and: ''&#10;    and: '    def runtest(self):'&#10;    and: &quot;        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\&quot;&#10;    and: &quot;             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\&quot;&#10;    and: '             redirect_stdout(to), redirect_stderr(te):'&#10;    and: '&gt;           found_errors = check_file('&#10;    and: '                self.fspath,'&#10;    and: '                self.flake8ignore,'&#10;    and: '                self.maxlength,'&#10;    and: '                self.maxdoclength,'&#10;    and: '                self.maxcomplexity,'&#10;    and: '                self.showsource,'&#10;    and: '                self.statistics'&#10;    and: '            )'&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '&#10;    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '&#10;    and: ''&#10;    and: &quot;path = local('/tmp/pytest-of-tester/pytest-4/test_keyword_match0/test_keyword_match.py')&quot;&#10;    and: &quot;flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''&quot;&#10;    and: 'showsource = [], statistics = []'&#10;    and: ''&#10;    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'&#10;    and: '                   showsource, statistics):'&#10;    and: '        &quot;&quot;&quot;Run flake8 over a single file, and return the number of failures.&quot;&quot;&quot;'&#10;    and: '        args = []'&#10;    and: '        if maxlength:'&#10;    and: &quot;            args += ['--max-line-length', maxlength]&quot;&#10;    and: '        if maxdoclenght:'&#10;    and: &quot;            args += ['--max-doc-length', maxdoclenght]&quot;&#10;    and: '        if maxcomplexity:'&#10;    and: &quot;            args += ['--max-complexity', maxcomplexity]&quot;&#10;    and: '        if showsource:'&#10;    and: &quot;            args += ['--show-source']&quot;&#10;    and: '        if statistics:'&#10;    and: &quot;            args += ['--statistics']&quot;&#10;    and: '        app = application.Application()'&#10;    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'&#10;    and: &quot;E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'&quot;&#10;    and: ''&#10;    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'&#10;    and: '=========================== short test summary info ============================'&#10;    and: &quot;FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'...&quot;&#10;    and: '======================= 1 failed, 1 deselected in 0.06s ========================'&#10;remains unmatched: '*E201*'">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 149, in test_keyword_match
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*E201*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-4/test_keyword_match0'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 2 items / 1 deselected / 1 selected'
    and: ''
    and: 'test_keyword_match.py F                                                  [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = &lt;class '_pytest.runner.CallInfo'&gt;"
    and: 'func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff24252d40&gt;'
    and: "when = 'call'"
    and: "reraise = (&lt;class '_pytest.outcomes.Exit'&gt;, &lt;class 'KeyboardInterrupt'&gt;)"
    and: ''
    and: '    @classmethod'
    and: '    def from_call('
    and: '        cls,'
    and: '        func: "Callable[[], TResult]",'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '        reraise: Optional['
    and: '            Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '        ] = None,'
    and: '    ) -&gt; "CallInfo[TResult]":'
    and: '        """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '        :param func:'
    and: '            The function to call. Called without arguments.'
    and: '        :param when:'
    and: '            The phase in which the function is called.'
    and: '        :param reraise:'
    and: '            Exception or exceptions that shall propagate if raised by the'
    and: '            function, instead of being wrapped in the CallInfo.'
    and: '        """'
    and: '        excinfo = None'
    and: '        start = timing.time()'
    and: '        precise_start = timing.perf_counter()'
    and: '        try:'
    and: '&gt;           result: Optional[TResult] = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = &lt;HookCaller 'pytest_runtest_call'&gt;"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def __call__(self, **kwargs: object) -&gt; Any:'
    and: '        """Call the hook.'
    and: '    '
    and: '        Only accepts keyword arguments, which should match the hook'
    and: '        specification.'
    and: '    '
    and: '        Returns the result(s) of calling all registered plugins, see'
    and: '        :ref:`calling`.'
    and: '        """'
    and: '        assert ('
    and: '            not self.is_historic()'
    and: '        ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '        self._verify_all_args_are_provided(kwargs)'
    and: '        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;_pytest.config.PytestPluginManager object at 0x7eff240ce8c0&gt;'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _hookexec('
    and: '        self,'
    and: '        hook_name: str,'
    and: '        methods: Sequence[HookImpl],'
    and: '        kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        # called from all hookcaller instances.'
    and: '        # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def traced_hookexec('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        before(hook_name, hook_impls, caller_kwargs)'
    and: '        outcome = Result.from_call('
    and: '            lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '        )'
    and: '        after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '&gt;       return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff240e5690&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = &lt;class 'pluggy._result.Result'&gt;"
    and: 'func = &lt;function PluginManager.add_hookcall_monitoring.&lt;locals&gt;.traced_hookexec.&lt;locals&gt;.&lt;lambda&gt; at 0x7eff2406e8c0&gt;'
    and: ''
    and: '    @classmethod'
    and: '    def from_call(cls, func: Callable[[], ResultType]) -&gt; Result[ResultType]:'
    and: '        """:meta private:"""'
    and: '        __tracebackhide__ = True'
    and: '        result = exception = None'
    and: '        try:'
    and: '&gt;           result = func()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '&gt;       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '    )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '                        res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: '    '
    and: '&gt;               return outcome.get_result()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;pluggy._result.Result object at 0x7eff240e53f0&gt;'
    and: ''
    and: '    def get_result(self) -&gt; ResultType:'
    and: '        """Get the result(s) for this hook call.'
    and: '    '
    and: '        If the hook was marked as a ``firstresult`` only a single value'
    and: '        will be returned, otherwise a list of results.'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        exc = self._exception'
    and: '        if exc is None:'
    and: '            return cast(ResultType, self._result)'
    and: '        else:'
    and: '&gt;           raise exc.with_traceback(exc.__traceback__)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [&lt;HookImpl plugin_name='runner', plugin=&lt;module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtes...dir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'&gt;&gt;]"
    and: "caller_kwargs = {'item': &lt;Flake8Item flake-8&gt;}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -&gt; object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '&gt;                       res = hook_impl.function(*args)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '&gt;           raise e'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -&gt; None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '&gt;           item.runtest()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = &lt;Flake8Item flake-8&gt;'
    and: ''
    and: '    def runtest(self):'
    and: "        with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "             BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '             redirect_stdout(to), redirect_stderr(te):'
    and: '&gt;           found_errors = check_file('
    and: '                self.fspath,'
    and: '                self.flake8ignore,'
    and: '                self.maxlength,'
    and: '                self.maxdoclength,'
    and: '                self.maxcomplexity,'
    and: '                self.showsource,'
    and: '                self.statistics'
    and: '            )'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-4/test_keyword_match0/test_keyword_match.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '&gt;       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
    and: '======================= 1 failed, 1 deselected in 0.06s ========================'
remains unmatched: '*E201*'</failure></testcase><testcase classname="test_flake8" name="test_run_on_init_file" file="test_flake8.py" line="155" time="0.077"><failure message="AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}&#10;  Omitting 4 identical items, use -vv to show&#10;  Differing items:&#10;  {'failed': 1} != {'failed': 0}&#10;  {'passed': 0} != {'passed': 1}&#10;  Full diff:&#10;    {&#10;     'errors': 0,...&#10;  &#10;  ...Full output truncated (12 lines hidden), use '-vv' to show">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 159, in test_run_on_init_file
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show</failure></testcase><testcase classname="test_flake8" name="test_unicode_error" file="test_flake8.py" line="161" time="0.002"><failure message="AttributeError: module 'py' has no attribute 'builtin'">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 167, in test_unicode_error
    f.write(py.builtin._totext("""
AttributeError: module 'py' has no attribute 'builtin'</failure></testcase><testcase classname="test_flake8" name="test_strict" file="test_flake8.py" line="178" time="0.034"><skipped type="pytest.xfail" message="flake8 is not properly registered as a marker" /></testcase><testcase classname="test_flake8" name="test_junit_classname" file="test_flake8.py" line="185" time="0.084"><failure message="AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}&#10;  Omitting 4 identical items, use -vv to show&#10;  Differing items:&#10;  {'failed': 1} != {'failed': 0}&#10;  {'passed': 0} != {'passed': 1}&#10;  Full diff:&#10;    {&#10;     'errors': 0,...&#10;  &#10;  ...Full output truncated (12 lines hidden), use '-vv' to show">Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in &lt;lambda&gt;
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 192, in test_junit_classname
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/cpythonlibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError: assert {'errors': 0,...pped': 0, ...} == {'errors': 0,...pped': 0, ...}
  Omitting 4 identical items, use -vv to show
  Differing items:
  {'failed': 1} != {'failed': 0}
  {'passed': 0} != {'passed': 1}
  Full diff:
    {
     'errors': 0,...
  
  ...Full output truncated (12 lines hidden), use '-vv' to show</failure></testcase></testsuite></testsuites>