GLOB sdist-make: /workdir/pytest-flake8-1.1.1/setup.py
graalpylibtest-unit-test-tests create: /workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests
graalpylibtest-unit-test-tests installdeps: mock, pytest
graalpylibtest-unit-test-tests inst: /workdir/pytest-flake8-1.1.1/.tox/.tmp/package/1/pytest-flake8-1.1.1.zip
graalpylibtest-unit-test-tests installed: exceptiongroup==1.2.0,flake8==6.1.0,graalpy-virtualenv==0.0.1,hpy==0.9.0rc2,iniconfig==2.0.0,mccabe==0.7.0,mock==5.1.0,packaging==23.2,pluggy==1.3.0,pycodestyle==2.11.1,pyflakes==3.1.0,pytest==7.4.3,pytest-flake8 @ file:///workdir/pytest-flake8-1.1.1/.tox/.tmp/package/1/pytest-flake8-1.1.1.zip,tomli==2.0.1
graalpylibtest-unit-test-tests run-test-pre: PYTHONHASHSEED='3552318162'
graalpylibtest-unit-test-tests run-test: commands[0] | pytest -v --tb=native --junitxml /workdir/results/pytest-flake8/1.1.1/1/graalpy-test-results.xml
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0 -- /workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/bin/python
cachedir: .tox/graalpylibtest-unit-test-tests/.pytest_cache
rootdir: /workdir/pytest-flake8-1.1.1
configfile: tox.ini
plugins: flake8-1.1.1
collecting ... collected 16 items

pytest_flake8.py::flake-8::FLAKE8 FAILED                                 [  6%]
setup.py::flake-8::FLAKE8 FAILED                                         [ 12%]
test_flake8.py::flake-8::FLAKE8 FAILED                                   [ 18%]
test_flake8.py::test_version PASSED                                      [ 25%]
test_flake8.py::TestIgnores::test_ignores PASSED                         [ 31%]
test_flake8.py::TestIgnores::test_default_flake8_ignores FAILED          [ 37%]
test_flake8.py::TestIgnores::test_ignores_all FAILED                     [ 43%]
test_flake8.py::TestIgnores::test_w293w292 FAILED                        [ 50%]
test_flake8.py::TestIgnores::test_mtime_caching FAILED                   [ 56%]
test_flake8.py::test_extensions PASSED                                   [ 62%]
test_flake8.py::test_ok_verbose FAILED                                   [ 68%]
test_flake8.py::test_keyword_match FAILED                                [ 75%]
test_flake8.py::test_run_on_init_file FAILED                             [ 81%]
test_flake8.py::test_unicode_error FAILED                                [ 87%]
test_flake8.py::test_strict XFAIL (flake8 is not properly registered...) [ 93%]
test_flake8.py::test_junit_classname FAILED                              [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x34c27710>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x1722e0be>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x3fcde391>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/pytest_flake8.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7ba0edcc>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x1722e0be>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x1326594c>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/setup.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x39626207>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x1722e0be>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x6105eec0>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/workdir/pytest-flake8-1.1.1/test_flake8.py'), flake8ignore = []
maxlength = '', maxdoclenght = '', maxcomplexity = '', showsource = []
statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
___________________ TestIgnores.test_default_flake8_ignores ____________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 53, in test_default_flake8_ignores
    result.assert_outcomes(passed=2)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_default_flake8_ignores0
configfile: tox.ini
plugins: flake8-1.1.1
collected 2 items

xy.py F
tests/hello.py F

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x728ddb61>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x29937888>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x4b56267d>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x6b08caef>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x6786c152>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_default_flake8_ignores0/xy.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x1a9a9eb8>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x29937888>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x501bf1f3>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x1fde036a>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7ec67f21>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_default_flake8_ignores0/tests/hello.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED xy.py::flake-8::FLAKE8 - AttributeError: 'Application' object has no a...
FAILED tests/hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object...
============================== 2 failed in 0.49s ===============================
_________________________ TestIgnores.test_ignores_all _________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 72, in test_ignores_all
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_ignores_all0
configfile: tox.ini
plugins: flake8-1.1.1
collected 1 item

xy.py F

=================================== FAILURES ===================================
_______________________ FLAKE8-check(ignoring E203 E300) _______________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x2c64a7c9>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x11e1610d>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x97d3d5e>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x1be45e14>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x6c37cd1b>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_ignores_all0/xy.py')
flake8ignore = ['E203', 'E300'], maxlength = '', maxdoclenght = ''
maxcomplexity = '', showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED xy.py::flake-8::FLAKE8 - AttributeError: 'Application' object has no a...
============================== 1 failed in 0.19s ===============================
__________________________ TestIgnores.test_w293w292 ___________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 81, in test_w293w292
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*W293*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-5/test_w293w2920'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 1 item'
    and: ''
    and: 'test_w293w292.py F                                                       [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x160eb439>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '>               result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def __call__(self, **kwargs: object) -> Any:'
    and: '            """Call the hook.'
    and: '    '
    and: '            Only accepts keyword arguments, which should match the hook'
    and: '            specification.'
    and: '    '
    and: '            Returns the result(s) of calling all registered plugins, see'
    and: '            :ref:`calling`.'
    and: '            """'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def call_historic('
    and: '            self,'
    and: '            result_callback: Callable[[Any], None] | None = None,'
    and: '            kwargs: Mapping[str, object] | None = None,'
    and: '        ) -> None:'
    and: '            """Call the hook with given ``kwargs`` for all registered plugins and'
    and: '            for all plugins which will be registered afterwards, see'
    and: '            :ref:`historic`.'
    and: '    '
    and: '            :param result_callback:'
    and: '                If provided, will be called for each non-``None`` result obtained'
    and: '                from a hook implementation.'
    and: '            """'
    and: '            assert self._call_history is not None'
    and: '            kwargs = kwargs or {}'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            self._call_history.append((kwargs, result_callback))'
    and: "            # Historizing hooks don't return results."
    and: "            # Remember firstresult isn't compatible with historic."
    and: '            res = self._hookexec(self.name, self._hookimpls, kwargs, False)'
    and: '            if result_callback is None:'
    and: '                return'
    and: '            if isinstance(res, list):'
    and: '                for x in res:'
    and: '                    result_callback(x)'
    and: '    '
    and: '        def call_extra('
    and: '            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]'
    and: '        ) -> Any:'
    and: '            """Call the hook with some additional temporarily participating'
    and: '            methods using the specified ``kwargs`` as call parameters, see'
    and: '            :ref:`call_extra`."""'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            opts: HookimplOpts = {'
    and: '                "wrapper": False,'
    and: '                "hookwrapper": False,'
    and: '                "optionalhook": False,'
    and: '                "trylast": False,'
    and: '                "tryfirst": False,'
    and: '                "specname": None,'
    and: '            }'
    and: '            hookimpls = self._hookimpls.copy()'
    and: '            for method in methods:'
    and: '                hookimpl = HookImpl(None, "<temp>", method, opts)'
    and: '                # Find last non-tryfirst nonwrapper method.'
    and: '                i = len(hookimpls) - 1'
    and: '                while ('
    and: '                    i >= 0'
    and: '                    and hookimpls[i].tryfirst'
    and: '                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)'
    and: '                ):'
    and: '                    i -= 1'
    and: '                hookimpls.insert(i + 1, hookimpl)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '            return self._hookexec(self.name, hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def _maybe_apply_history(self, method: HookImpl) -> None:'
    and: '            """Apply call history to a new hookimpl if it is marked as historic."""'
    and: '            if self.is_historic():'
    and: '                assert self._call_history is not None'
    and: '                for kwargs, result_callback in self._call_history:'
    and: '                    res = self._hookexec(self.name, [method], kwargs, False)'
    and: '                    if res and result_callback is not None:'
    and: "                        # XXX: remember firstresult isn't compat with historic"
    and: '                        assert isinstance(res, list)'
    and: '                        result_callback(res[0])'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: '    _HookCaller = HookCaller'
    and: '    '
    and: '    '
    and: '    class _SubsetHookCaller(HookCaller):'
    and: '        """A proxy to another HookCaller which manages calls to all registered'
    and: '        plugins except the ones from remove_plugins."""'
    and: '    '
    and: '        # This class is unusual: in inhertits from `HookCaller` so all of'
    and: '        # the *code* runs in the class, but it delegates all underlying *data*'
    and: '        # to the original HookCaller.'
    and: '        # `subset_hook_caller` used to be implemented by creating a full-fledged'
    and: '        # HookCaller, copying all hookimpls from the original. This had problems'
    and: '        # with memory leaks (#346) and historic calls (#347), which make a proxy'
    and: '        # approach better.'
    and: '        # An alternative implementation is to use a `_getattr__`/`__getattribute__`'
    and: '        # proxy, however that adds more overhead and is more tricky to implement.'
    and: '    '
    and: '        __slots__ = ('
    and: '            "_orig",'
    and: '            "_remove_plugins",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:'
    and: '            self._orig = orig'
    and: '            self._remove_plugins = remove_plugins'
    and: '            self.name = orig.name  # type: ignore[misc]'
    and: '            self._hookexec = orig._hookexec  # type: ignore[misc]'
    and: '    '
    and: '        @property  # type: ignore[misc]'
    and: '        def _hookimpls(self) -> list[HookImpl]:'
    and: '            return ['
    and: '                impl'
    and: '                for impl in self._orig._hookimpls'
    and: '                if impl.plugin not in self._remove_plugins'
    and: '            ]'
    and: '    '
    and: '        @property'
    and: '        def spec(self) -> HookSpec | None:  # type: ignore[override]'
    and: '            return self._orig.spec'
    and: '    '
    and: '        @property'
    and: '        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]'
    and: '            return self._orig._call_history'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<_SubsetHookCaller {self.name!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookImpl:'
    and: '        """A hook implementation in a :class:`HookCaller`."""'
    and: '    '
    and: '        __slots__ = ('
    and: '            "function",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "plugin",'
    and: '            "opts",'
    and: '            "plugin_name",'
    and: '            "wrapper",'
    and: '            "hookwrapper",'
    and: '            "optionalhook",'
    and: '            "tryfirst",'
    and: '            "trylast",'
    and: '        )'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            plugin: _Plugin,'
    and: '            plugin_name: str,'
    and: '            function: _HookImplFunction[object],'
    and: '            hook_impl_opts: HookimplOpts,'
    and: '        ) -> None:'
    and: '            """:meta private:"""'
    and: '            #: The hook implementation function.'
    and: '            self.function: Final = function'
    and: '            argnames, kwargnames = varnames(self.function)'
    and: '            #: The positional parameter names of ``function```.'
    and: '            self.argnames: Final = argnames'
    and: '            #: The keyword parameter names of ``function```.'
    and: '            self.kwargnames: Final = kwargnames'
    and: '            #: The plugin which defined this hook implementation.'
    and: '            self.plugin: Final = plugin'
    and: '            #: The :class:`HookimplOpts` used to configure this hook implementation.'
    and: '            self.opts: Final = hook_impl_opts'
    and: '            #: The name of the plugin which defined this hook implementation.'
    and: '            self.plugin_name: Final = plugin_name'
    and: '            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.'
    and: '            self.wrapper: Final = hook_impl_opts["wrapper"]'
    and: '            #: Whether the hook implementation is an :ref:`old-style wrapper'
    and: '            #: <old_style_hookwrappers>`.'
    and: '            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]'
    and: '            #: Whether validation against a hook specification is :ref:`optional'
    and: '            #: <optionalhook>`.'
    and: '            self.optionalhook: Final = hook_impl_opts["optionalhook"]'
    and: '            #: Whether to try to order this hook implementation :ref:`first'
    and: '            #: <callorder>`.'
    and: '            self.tryfirst: Final = hook_impl_opts["tryfirst"]'
    and: '            #: Whether to try to order this hook implementation :ref:`last'
    and: '            #: <callorder>`.'
    and: '            self.trylast: Final = hook_impl_opts["trylast"]'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookSpec:'
    and: '        __slots__ = ('
    and: '            "namespace",'
    and: '            "function",'
    and: '            "name",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "opts",'
    and: '            "warn_on_impl",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:'
    and: '            self.namespace = namespace'
    and: '            self.function: Callable[..., object] = getattr(namespace, name)'
    and: '            self.name = name'
    and: '            self.argnames, self.kwargnames = varnames(self.function)'
    and: '            self.opts = opts'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0x40d52cbb>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def _hookexec('
    and: '            self,'
    and: '            hook_name: str,'
    and: '            methods: Sequence[HookImpl],'
    and: '            kwargs: Mapping[str, object],'
    and: '            firstresult: bool,'
    and: '        ) -> object | list[object]:'
    and: '            # called from all hookcaller instances.'
    and: '            # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: '    '
    and: '        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:'
    and: '            """Register a plugin and return its name.'
    and: '    '
    and: '            :param name:'
    and: '                The name under which to register the plugin. If not specified, a'
    and: '                name is generated using :func:`get_canonical_name`.'
    and: '    '
    and: '            :returns:'
    and: '                The plugin name. If the name is blocked from registering, returns'
    and: '                ``None``.'
    and: '    '
    and: '            If the plugin is already registered, raises a :exc:`ValueError`.'
    and: '            """'
    and: '            plugin_name = name or self.get_canonical_name(plugin)'
    and: '    '
    and: '            if plugin_name in self._name2plugin:'
    and: '                if self._name2plugin.get(plugin_name, -1) is None:'
    and: '                    return None  # blocked plugin, return None to indicate no registration'
    and: '                raise ValueError('
    and: '                    "Plugin name already registered: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            if plugin in self._name2plugin.values():'
    and: '                raise ValueError('
    and: '                    "Plugin already registered under a different name: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            # XXX if an error happens we should make sure no state has been'
    and: '            # changed at point of return'
    and: '            self._name2plugin[plugin_name] = plugin'
    and: '    '
    and: '            # register matching hook implementations of the plugin'
    and: '            for name in dir(plugin):'
    and: '                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)'
    and: '                if hookimpl_opts is not None:'
    and: '                    normalize_hookimpl_opts(hookimpl_opts)'
    and: '                    method: _HookImplFunction[object] = getattr(plugin, name)'
    and: '                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)'
    and: '                    name = hookimpl_opts.get("specname") or name'
    and: '                    hook: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hook is None:'
    and: '                        hook = HookCaller(name, self._hookexec)'
    and: '                        setattr(self.hook, name, hook)'
    and: '                    elif hook.has_spec():'
    and: '                        self._verify_hook(hook, hookimpl)'
    and: '                        hook._maybe_apply_history(hookimpl)'
    and: '                    hook._add_hookimpl(hookimpl)'
    and: '            return plugin_name'
    and: '    '
    and: '        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:'
    and: '            """Try to obtain a hook implementation from an item with the given name'
    and: '            in the given plugin which is being searched for hook impls.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookimpl options, or None to skip the given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook implementation are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookimplMarker`.'
    and: '            """'
    and: '            method: object = getattr(plugin, name)'
    and: '            if not inspect.isroutine(method):'
    and: '                return None'
    and: '            try:'
    and: '                res: HookimplOpts | None = getattr('
    and: '                    method, self.project_name + "_impl", None'
    and: '                )'
    and: '            except Exception:'
    and: '                res = {}  # type: ignore[assignment]'
    and: '            if res is not None and not isinstance(res, dict):'
    and: '                # false positive'
    and: '                res = None  # type:ignore[unreachable]'
    and: '            return res'
    and: '    '
    and: '        def unregister('
    and: '            self, plugin: _Plugin | None = None, name: str | None = None'
    and: '        ) -> Any | None:'
    and: '            """Unregister a plugin and all of its hook implementations.'
    and: '    '
    and: '            The plugin can be specified either by the plugin object or the plugin'
    and: '            name. If both are specified, they must agree.'
    and: '    '
    and: '            Returns the unregistered plugin, or ``None`` if not found.'
    and: '            """'
    and: '            if name is None:'
    and: '                assert plugin is not None, "one of name or plugin needs to be specified"'
    and: '                name = self.get_name(plugin)'
    and: '                assert name is not None, "plugin is not registered"'
    and: '    '
    and: '            if plugin is None:'
    and: '                plugin = self.get_plugin(name)'
    and: '                if plugin is None:'
    and: '                    return None'
    and: '    '
    and: '            hookcallers = self.get_hookcallers(plugin)'
    and: '            if hookcallers:'
    and: '                for hookcaller in hookcallers:'
    and: '                    hookcaller._remove_plugin(plugin)'
    and: '    '
    and: '            # if self._name2plugin[name] == None registration was blocked: ignore'
    and: '            if self._name2plugin.get(name):'
    and: '                assert name is not None'
    and: '                del self._name2plugin[name]'
    and: '    '
    and: '            return plugin'
    and: '    '
    and: '        def set_blocked(self, name: str) -> None:'
    and: '            """Block registrations of the given name, unregister if already registered."""'
    and: '            self.unregister(name=name)'
    and: '            self._name2plugin[name] = None'
    and: '    '
    and: '        def is_blocked(self, name: str) -> bool:'
    and: '            """Return whether the given plugin name is blocked."""'
    and: '            return name in self._name2plugin and self._name2plugin[name] is None'
    and: '    '
    and: '        def add_hookspecs(self, module_or_class: _Namespace) -> None:'
    and: '            """Add new hook specifications defined in the given ``module_or_class``.'
    and: '    '
    and: '            Functions are recognized as hook specifications if they have been'
    and: '            decorated with a matching :class:`HookspecMarker`.'
    and: '            """'
    and: '            names = []'
    and: '            for name in dir(module_or_class):'
    and: '                spec_opts = self.parse_hookspec_opts(module_or_class, name)'
    and: '                if spec_opts is not None:'
    and: '                    hc: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hc is None:'
    and: '                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)'
    and: '                        setattr(self.hook, name, hc)'
    and: '                    else:'
    and: '                        # Plugins registered this hook without knowing the spec.'
    and: '                        hc.set_specification(module_or_class, spec_opts)'
    and: '                        for hookfunction in hc.get_hookimpls():'
    and: '                            self._verify_hook(hc, hookfunction)'
    and: '                    names.append(name)'
    and: '    '
    and: '            if not names:'
    and: '                raise ValueError('
    and: '                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"'
    and: '                )'
    and: '    '
    and: '        def parse_hookspec_opts('
    and: '            self, module_or_class: _Namespace, name: str'
    and: '        ) -> HookspecOpts | None:'
    and: '            """Try to obtain a hook specification from an item with the given name'
    and: '            in the given module or class which is being searched for hook specs.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookspec options for defining a hook, or None to skip the'
    and: '                given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook specifications are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookspecMarker`.'
    and: '            """'
    and: '            method = getattr(module_or_class, name)'
    and: '            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)'
    and: '            return opts'
    and: '    '
    and: '        def get_plugins(self) -> set[Any]:'
    and: '            """Return a set of all registered plugin objects."""'
    and: '            return set(self._name2plugin.values())'
    and: '    '
    and: '        def is_registered(self, plugin: _Plugin) -> bool:'
    and: '            """Return whether the plugin is already registered."""'
    and: '            return any(plugin == val for val in self._name2plugin.values())'
    and: '    '
    and: '        def get_canonical_name(self, plugin: _Plugin) -> str:'
    and: '            """Return a canonical name for a plugin object.'
    and: '    '
    and: '            Note that a plugin may be registered under a different name'
    and: '            specified by the caller of :meth:`register(plugin, name) <register>`.'
    and: '            To obtain the name of a registered plugin use :meth:`get_name(plugin)'
    and: '            <get_name>` instead.'
    and: '            """'
    and: '            name: str | None = getattr(plugin, "__name__", None)'
    and: '            return name or str(id(plugin))'
    and: '    '
    and: '        def get_plugin(self, name: str) -> Any | None:'
    and: '            """Return the plugin registered under the given name, if any."""'
    and: '            return self._name2plugin.get(name)'
    and: '    '
    and: '        def has_plugin(self, name: str) -> bool:'
    and: '            """Return whether a plugin with the given name is registered."""'
    and: '            return self.get_plugin(name) is not None'
    and: '    '
    and: '        def get_name(self, plugin: _Plugin) -> str | None:'
    and: '            """Return the name the plugin is registered under, or ``None`` if'
    and: '            is isn\'t."""'
    and: '            for name, val in self._name2plugin.items():'
    and: '                if plugin == val:'
    and: '                    return name'
    and: '            return None'
    and: '    '
    and: '        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:'
    and: '            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r\\nhook %r\\nhistoric incompatible with yield/wrapper/hookwrapper"'
    and: '                    % (hookimpl.plugin_name, hook.name),'
    and: '                )'
    and: '    '
    and: '            assert hook.spec is not None'
    and: '            if hook.spec.warn_on_impl:'
    and: '                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)'
    and: '    '
    and: '            # positional arg checking'
    and: '            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)'
    and: '            if notinspec:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Argument(s) %s are declared in the hookimpl but "'
    and: '                    "can not be found in the hookspec"'
    and: '                    % ('
    and: '                        hookimpl.plugin_name,'
    and: '                        hook.name,'
    and: '                        _formatdef(hookimpl.function),'
    and: '                        notinspec,'
    and: '                    ),'
    and: '                )'
    and: '    '
    and: '            if ('
    and: '                hookimpl.wrapper or hookimpl.hookwrapper'
    and: '            ) and not inspect.isgeneratorfunction(hookimpl.function):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Declared as wrapper=True or hookwrapper=True "'
    and: '                    "but function is not a generator function"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '            if hookimpl.wrapper and hookimpl.hookwrapper:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "The wrapper=True and hookwrapper=True options are mutually exclusive"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '        def check_pending(self) -> None:'
    and: '            """Verify that all hooks which have not been verified against a'
    and: '            hook specification are optional, otherwise raise'
    and: '            :exc:`PluginValidationError`."""'
    and: '            for name in self.hook.__dict__:'
    and: '                if name[0] != "_":'
    and: '                    hook: HookCaller = getattr(self.hook, name)'
    and: '                    if not hook.has_spec():'
    and: '                        for hookimpl in hook.get_hookimpls():'
    and: '                            if not hookimpl.optionalhook:'
    and: '                                raise PluginValidationError('
    and: '                                    hookimpl.plugin,'
    and: '                                    "unknown hook %r in plugin %r"'
    and: '                                    % (name, hookimpl.plugin),'
    and: '                                )'
    and: '    '
    and: '        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:'
    and: '            """Load modules from querying the specified setuptools ``group``.'
    and: '    '
    and: '            :param group:'
    and: '                Entry point group to load plugins.'
    and: '            :param name:'
    and: '                If given, loads only plugins with the given ``name``.'
    and: '    '
    and: '            :return:'
    and: '                The number of plugins loaded by this call.'
    and: '            """'
    and: '            count = 0'
    and: '            for dist in list(importlib.metadata.distributions()):'
    and: '                for ep in dist.entry_points:'
    and: '                    if ('
    and: '                        ep.group != group'
    and: '                        or (name is not None and ep.name != name)'
    and: '                        # already registered'
    and: '                        or self.get_plugin(ep.name)'
    and: '                        or self.is_blocked(ep.name)'
    and: '                    ):'
    and: '                        continue'
    and: '                    plugin = ep.load()'
    and: '                    self.register(plugin, name=ep.name)'
    and: '                    self._plugin_distinfo.append((plugin, DistFacade(dist)))'
    and: '                    count += 1'
    and: '            return count'
    and: '    '
    and: '        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:'
    and: '            """Return a list of (plugin, distinfo) pairs for all'
    and: '            setuptools-registered plugins."""'
    and: '            return list(self._plugin_distinfo)'
    and: '    '
    and: '        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:'
    and: '            """Return a list of (name, plugin) pairs for all registered plugins."""'
    and: '            return list(self._name2plugin.items())'
    and: '    '
    and: '        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:'
    and: '            """Get all hook callers for the specified plugin.'
    and: '    '
    and: '            :returns:'
    and: '                The hook callers, or ``None`` if ``plugin`` is not registered in'
    and: '                this plugin manager.'
    and: '            """'
    and: '            if self.get_name(plugin) is None:'
    and: '                return None'
    and: '            hookcallers = []'
    and: '            for hookcaller in self.hook.__dict__.values():'
    and: '                for hookimpl in hookcaller.get_hookimpls():'
    and: '                    if hookimpl.plugin is plugin:'
    and: '                        hookcallers.append(hookcaller)'
    and: '            return hookcallers'
    and: '    '
    and: '        def add_hookcall_monitoring('
    and: '            self, before: _BeforeTrace, after: _AfterTrace'
    and: '        ) -> Callable[[], None]:'
    and: '            """Add before/after tracing functions for all hooks.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracers.'
    and: '    '
    and: '            ``before(hook_name, hook_impls, kwargs)`` will be called ahead'
    and: '            of all hook calls and receive a hookcaller instance, a list'
    and: '            of HookImpl instances and the keyword arguments for the hook call.'
    and: '    '
    and: '            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the'
    and: '            same arguments as ``before`` but also a :class:`~pluggy.Result` object'
    and: '            which represents the result of the overall hook call.'
    and: '            """'
    and: '            oldcall = self._inner_hookexec'
    and: '    '
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>               return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x5fbc3252>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x6442216c>'
    and: ''
    and: '        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '            """:meta private:"""'
    and: '            __tracebackhide__ = True'
    and: '            result = exception = None'
    and: '            try:'
    and: '>               result = func()'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '            return cls(result, exception)'
    and: '    '
    and: '        def force_result(self, result: ResultType) -> None:'
    and: '            """Force the result(s) to ``result``.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` a single value should'
    and: '            be set, otherwise set a (modified) list of results. Any exceptions'
    and: '            found during invocation will be deleted.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '            """'
    and: '            self._result = result'
    and: '            self._exception = None'
    and: '    '
    and: '        def force_exception(self, exception: BaseException) -> None:'
    and: '            """Force the result to fail with ``exception``.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '    '
    and: '            .. versionadded:: 1.1.0'
    and: '            """'
    and: '            self._result = None'
    and: '            self._exception = exception'
    and: '    '
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '                raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '>   ???'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x2bbc3ff5>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '            raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '        def runtest(self):'
    and: "            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '                 redirect_stdout(to), redirect_stderr(te):'
    and: '>               found_errors = check_file('
    and: '                    self.fspath,'
    and: '                    self.flake8ignore,'
    and: '                    self.maxlength,'
    and: '                    self.maxdoclength,'
    and: '                    self.maxcomplexity,'
    and: '                    self.showsource,'
    and: '                    self.statistics'
    and: '                )'
    and: '                to.flush()'
    and: '                te.flush()'
    and: "                out = bo.getvalue().decode('utf-8')"
    and: "                err = be.getvalue().decode('utf-8')"
    and: '    '
    and: '            if found_errors:'
    and: '                raise Flake8Error(out, err)'
    and: '            # update mtime only if test passed'
    and: '            # otherwise failures would not be re-run next time'
    and: '            if hasattr(self.config, "_flake8mtimes"):'
    and: '                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,'
    and: '                                                               self.flake8ignore)'
    and: '    '
    and: '        def repr_failure(self, excinfo):'
    and: '            if excinfo.errisinstance(Flake8Error):'
    and: '                return excinfo.value.args[0]'
    and: '            return super(Flake8Item, self).repr_failure(excinfo)'
    and: '    '
    and: '        def reportinfo(self):'
    and: '            if self.flake8ignore:'
    and: '                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)'
    and: '            else:'
    and: '                ignores = ""'
    and: '            return (self.fspath, -1, "FLAKE8-check%s" % ignores)'
    and: '    '
    and: '    '
    and: '    class Ignorer:'
    and: '        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\\d\\d\\d")):'
    and: '            self.ignores = ignores = []'
    and: '            for line in ignorelines:'
    and: '                i = line.find("#")'
    and: '                if i != -1:'
    and: '                    line = line[:i]'
    and: '                try:'
    and: '                    glob, ign = line.split(None, 1)'
    and: '                except ValueError:'
    and: '                    glob, ign = None, line'
    and: '                if glob and coderex.match(glob):'
    and: '                    glob, ign = None, line'
    and: '                ign = ign.split()'
    and: '                if "ALL" in ign:'
    and: '                    ign = None'
    and: '                if glob and "/" != os.sep and "/" in glob:'
    and: '                    glob = glob.replace("/", os.sep)'
    and: '                ignores.append((glob, ign))'
    and: '    '
    and: '        def __call__(self, path):'
    and: '            l = []  # noqa: E741'
    and: '            for (glob, ignlist) in self.ignores:'
    and: '                if not glob or path.fnmatch(glob):'
    and: '                    if ignlist is None:'
    and: '                        return None'
    and: '                    l.extend(ignlist)'
    and: '            return l'
    and: '    '
    and: '    '
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '        prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-5/test_w293w2920/test_w293w292.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje..."
    and: '============================== 1 failed in 0.16s ==============================='
remains unmatched: '*W293*'
---------------------------- Captured stderr setup -----------------------------
/tmp/pytest-of-tester/pytest-5/test_w293w2920
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_w293w2920
plugins: flake8-1.1.1
collected 1 item

test_w293w292.py F                                                       [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x160eb439>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x40d52cbb>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x5fbc3252>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x6442216c>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x2bbc3ff5>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_w293w2920/test_w293w292.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED test_w293w292.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...
============================== 1 failed in 0.16s ===============================
________________________ TestIgnores.test_mtime_caching ________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 91, in test_mtime_caching
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*W293*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-5/test_mtime_caching0'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 2 items'
    and: ''
    and: 'hello.py F                                                               [ 50%]'
    and: 'test_mtime_caching.py F                                                  [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x70a5d852>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '>               result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def __call__(self, **kwargs: object) -> Any:'
    and: '            """Call the hook.'
    and: '    '
    and: '            Only accepts keyword arguments, which should match the hook'
    and: '            specification.'
    and: '    '
    and: '            Returns the result(s) of calling all registered plugins, see'
    and: '            :ref:`calling`.'
    and: '            """'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def call_historic('
    and: '            self,'
    and: '            result_callback: Callable[[Any], None] | None = None,'
    and: '            kwargs: Mapping[str, object] | None = None,'
    and: '        ) -> None:'
    and: '            """Call the hook with given ``kwargs`` for all registered plugins and'
    and: '            for all plugins which will be registered afterwards, see'
    and: '            :ref:`historic`.'
    and: '    '
    and: '            :param result_callback:'
    and: '                If provided, will be called for each non-``None`` result obtained'
    and: '                from a hook implementation.'
    and: '            """'
    and: '            assert self._call_history is not None'
    and: '            kwargs = kwargs or {}'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            self._call_history.append((kwargs, result_callback))'
    and: "            # Historizing hooks don't return results."
    and: "            # Remember firstresult isn't compatible with historic."
    and: '            res = self._hookexec(self.name, self._hookimpls, kwargs, False)'
    and: '            if result_callback is None:'
    and: '                return'
    and: '            if isinstance(res, list):'
    and: '                for x in res:'
    and: '                    result_callback(x)'
    and: '    '
    and: '        def call_extra('
    and: '            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]'
    and: '        ) -> Any:'
    and: '            """Call the hook with some additional temporarily participating'
    and: '            methods using the specified ``kwargs`` as call parameters, see'
    and: '            :ref:`call_extra`."""'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            opts: HookimplOpts = {'
    and: '                "wrapper": False,'
    and: '                "hookwrapper": False,'
    and: '                "optionalhook": False,'
    and: '                "trylast": False,'
    and: '                "tryfirst": False,'
    and: '                "specname": None,'
    and: '            }'
    and: '            hookimpls = self._hookimpls.copy()'
    and: '            for method in methods:'
    and: '                hookimpl = HookImpl(None, "<temp>", method, opts)'
    and: '                # Find last non-tryfirst nonwrapper method.'
    and: '                i = len(hookimpls) - 1'
    and: '                while ('
    and: '                    i >= 0'
    and: '                    and hookimpls[i].tryfirst'
    and: '                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)'
    and: '                ):'
    and: '                    i -= 1'
    and: '                hookimpls.insert(i + 1, hookimpl)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '            return self._hookexec(self.name, hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def _maybe_apply_history(self, method: HookImpl) -> None:'
    and: '            """Apply call history to a new hookimpl if it is marked as historic."""'
    and: '            if self.is_historic():'
    and: '                assert self._call_history is not None'
    and: '                for kwargs, result_callback in self._call_history:'
    and: '                    res = self._hookexec(self.name, [method], kwargs, False)'
    and: '                    if res and result_callback is not None:'
    and: "                        # XXX: remember firstresult isn't compat with historic"
    and: '                        assert isinstance(res, list)'
    and: '                        result_callback(res[0])'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: '    _HookCaller = HookCaller'
    and: '    '
    and: '    '
    and: '    class _SubsetHookCaller(HookCaller):'
    and: '        """A proxy to another HookCaller which manages calls to all registered'
    and: '        plugins except the ones from remove_plugins."""'
    and: '    '
    and: '        # This class is unusual: in inhertits from `HookCaller` so all of'
    and: '        # the *code* runs in the class, but it delegates all underlying *data*'
    and: '        # to the original HookCaller.'
    and: '        # `subset_hook_caller` used to be implemented by creating a full-fledged'
    and: '        # HookCaller, copying all hookimpls from the original. This had problems'
    and: '        # with memory leaks (#346) and historic calls (#347), which make a proxy'
    and: '        # approach better.'
    and: '        # An alternative implementation is to use a `_getattr__`/`__getattribute__`'
    and: '        # proxy, however that adds more overhead and is more tricky to implement.'
    and: '    '
    and: '        __slots__ = ('
    and: '            "_orig",'
    and: '            "_remove_plugins",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:'
    and: '            self._orig = orig'
    and: '            self._remove_plugins = remove_plugins'
    and: '            self.name = orig.name  # type: ignore[misc]'
    and: '            self._hookexec = orig._hookexec  # type: ignore[misc]'
    and: '    '
    and: '        @property  # type: ignore[misc]'
    and: '        def _hookimpls(self) -> list[HookImpl]:'
    and: '            return ['
    and: '                impl'
    and: '                for impl in self._orig._hookimpls'
    and: '                if impl.plugin not in self._remove_plugins'
    and: '            ]'
    and: '    '
    and: '        @property'
    and: '        def spec(self) -> HookSpec | None:  # type: ignore[override]'
    and: '            return self._orig.spec'
    and: '    '
    and: '        @property'
    and: '        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]'
    and: '            return self._orig._call_history'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<_SubsetHookCaller {self.name!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookImpl:'
    and: '        """A hook implementation in a :class:`HookCaller`."""'
    and: '    '
    and: '        __slots__ = ('
    and: '            "function",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "plugin",'
    and: '            "opts",'
    and: '            "plugin_name",'
    and: '            "wrapper",'
    and: '            "hookwrapper",'
    and: '            "optionalhook",'
    and: '            "tryfirst",'
    and: '            "trylast",'
    and: '        )'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            plugin: _Plugin,'
    and: '            plugin_name: str,'
    and: '            function: _HookImplFunction[object],'
    and: '            hook_impl_opts: HookimplOpts,'
    and: '        ) -> None:'
    and: '            """:meta private:"""'
    and: '            #: The hook implementation function.'
    and: '            self.function: Final = function'
    and: '            argnames, kwargnames = varnames(self.function)'
    and: '            #: The positional parameter names of ``function```.'
    and: '            self.argnames: Final = argnames'
    and: '            #: The keyword parameter names of ``function```.'
    and: '            self.kwargnames: Final = kwargnames'
    and: '            #: The plugin which defined this hook implementation.'
    and: '            self.plugin: Final = plugin'
    and: '            #: The :class:`HookimplOpts` used to configure this hook implementation.'
    and: '            self.opts: Final = hook_impl_opts'
    and: '            #: The name of the plugin which defined this hook implementation.'
    and: '            self.plugin_name: Final = plugin_name'
    and: '            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.'
    and: '            self.wrapper: Final = hook_impl_opts["wrapper"]'
    and: '            #: Whether the hook implementation is an :ref:`old-style wrapper'
    and: '            #: <old_style_hookwrappers>`.'
    and: '            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]'
    and: '            #: Whether validation against a hook specification is :ref:`optional'
    and: '            #: <optionalhook>`.'
    and: '            self.optionalhook: Final = hook_impl_opts["optionalhook"]'
    and: '            #: Whether to try to order this hook implementation :ref:`first'
    and: '            #: <callorder>`.'
    and: '            self.tryfirst: Final = hook_impl_opts["tryfirst"]'
    and: '            #: Whether to try to order this hook implementation :ref:`last'
    and: '            #: <callorder>`.'
    and: '            self.trylast: Final = hook_impl_opts["trylast"]'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookSpec:'
    and: '        __slots__ = ('
    and: '            "namespace",'
    and: '            "function",'
    and: '            "name",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "opts",'
    and: '            "warn_on_impl",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:'
    and: '            self.namespace = namespace'
    and: '            self.function: Callable[..., object] = getattr(namespace, name)'
    and: '            self.name = name'
    and: '            self.argnames, self.kwargnames = varnames(self.function)'
    and: '            self.opts = opts'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0xa8b1660>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def _hookexec('
    and: '            self,'
    and: '            hook_name: str,'
    and: '            methods: Sequence[HookImpl],'
    and: '            kwargs: Mapping[str, object],'
    and: '            firstresult: bool,'
    and: '        ) -> object | list[object]:'
    and: '            # called from all hookcaller instances.'
    and: '            # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: '    '
    and: '        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:'
    and: '            """Register a plugin and return its name.'
    and: '    '
    and: '            :param name:'
    and: '                The name under which to register the plugin. If not specified, a'
    and: '                name is generated using :func:`get_canonical_name`.'
    and: '    '
    and: '            :returns:'
    and: '                The plugin name. If the name is blocked from registering, returns'
    and: '                ``None``.'
    and: '    '
    and: '            If the plugin is already registered, raises a :exc:`ValueError`.'
    and: '            """'
    and: '            plugin_name = name or self.get_canonical_name(plugin)'
    and: '    '
    and: '            if plugin_name in self._name2plugin:'
    and: '                if self._name2plugin.get(plugin_name, -1) is None:'
    and: '                    return None  # blocked plugin, return None to indicate no registration'
    and: '                raise ValueError('
    and: '                    "Plugin name already registered: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            if plugin in self._name2plugin.values():'
    and: '                raise ValueError('
    and: '                    "Plugin already registered under a different name: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            # XXX if an error happens we should make sure no state has been'
    and: '            # changed at point of return'
    and: '            self._name2plugin[plugin_name] = plugin'
    and: '    '
    and: '            # register matching hook implementations of the plugin'
    and: '            for name in dir(plugin):'
    and: '                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)'
    and: '                if hookimpl_opts is not None:'
    and: '                    normalize_hookimpl_opts(hookimpl_opts)'
    and: '                    method: _HookImplFunction[object] = getattr(plugin, name)'
    and: '                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)'
    and: '                    name = hookimpl_opts.get("specname") or name'
    and: '                    hook: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hook is None:'
    and: '                        hook = HookCaller(name, self._hookexec)'
    and: '                        setattr(self.hook, name, hook)'
    and: '                    elif hook.has_spec():'
    and: '                        self._verify_hook(hook, hookimpl)'
    and: '                        hook._maybe_apply_history(hookimpl)'
    and: '                    hook._add_hookimpl(hookimpl)'
    and: '            return plugin_name'
    and: '    '
    and: '        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:'
    and: '            """Try to obtain a hook implementation from an item with the given name'
    and: '            in the given plugin which is being searched for hook impls.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookimpl options, or None to skip the given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook implementation are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookimplMarker`.'
    and: '            """'
    and: '            method: object = getattr(plugin, name)'
    and: '            if not inspect.isroutine(method):'
    and: '                return None'
    and: '            try:'
    and: '                res: HookimplOpts | None = getattr('
    and: '                    method, self.project_name + "_impl", None'
    and: '                )'
    and: '            except Exception:'
    and: '                res = {}  # type: ignore[assignment]'
    and: '            if res is not None and not isinstance(res, dict):'
    and: '                # false positive'
    and: '                res = None  # type:ignore[unreachable]'
    and: '            return res'
    and: '    '
    and: '        def unregister('
    and: '            self, plugin: _Plugin | None = None, name: str | None = None'
    and: '        ) -> Any | None:'
    and: '            """Unregister a plugin and all of its hook implementations.'
    and: '    '
    and: '            The plugin can be specified either by the plugin object or the plugin'
    and: '            name. If both are specified, they must agree.'
    and: '    '
    and: '            Returns the unregistered plugin, or ``None`` if not found.'
    and: '            """'
    and: '            if name is None:'
    and: '                assert plugin is not None, "one of name or plugin needs to be specified"'
    and: '                name = self.get_name(plugin)'
    and: '                assert name is not None, "plugin is not registered"'
    and: '    '
    and: '            if plugin is None:'
    and: '                plugin = self.get_plugin(name)'
    and: '                if plugin is None:'
    and: '                    return None'
    and: '    '
    and: '            hookcallers = self.get_hookcallers(plugin)'
    and: '            if hookcallers:'
    and: '                for hookcaller in hookcallers:'
    and: '                    hookcaller._remove_plugin(plugin)'
    and: '    '
    and: '            # if self._name2plugin[name] == None registration was blocked: ignore'
    and: '            if self._name2plugin.get(name):'
    and: '                assert name is not None'
    and: '                del self._name2plugin[name]'
    and: '    '
    and: '            return plugin'
    and: '    '
    and: '        def set_blocked(self, name: str) -> None:'
    and: '            """Block registrations of the given name, unregister if already registered."""'
    and: '            self.unregister(name=name)'
    and: '            self._name2plugin[name] = None'
    and: '    '
    and: '        def is_blocked(self, name: str) -> bool:'
    and: '            """Return whether the given plugin name is blocked."""'
    and: '            return name in self._name2plugin and self._name2plugin[name] is None'
    and: '    '
    and: '        def add_hookspecs(self, module_or_class: _Namespace) -> None:'
    and: '            """Add new hook specifications defined in the given ``module_or_class``.'
    and: '    '
    and: '            Functions are recognized as hook specifications if they have been'
    and: '            decorated with a matching :class:`HookspecMarker`.'
    and: '            """'
    and: '            names = []'
    and: '            for name in dir(module_or_class):'
    and: '                spec_opts = self.parse_hookspec_opts(module_or_class, name)'
    and: '                if spec_opts is not None:'
    and: '                    hc: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hc is None:'
    and: '                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)'
    and: '                        setattr(self.hook, name, hc)'
    and: '                    else:'
    and: '                        # Plugins registered this hook without knowing the spec.'
    and: '                        hc.set_specification(module_or_class, spec_opts)'
    and: '                        for hookfunction in hc.get_hookimpls():'
    and: '                            self._verify_hook(hc, hookfunction)'
    and: '                    names.append(name)'
    and: '    '
    and: '            if not names:'
    and: '                raise ValueError('
    and: '                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"'
    and: '                )'
    and: '    '
    and: '        def parse_hookspec_opts('
    and: '            self, module_or_class: _Namespace, name: str'
    and: '        ) -> HookspecOpts | None:'
    and: '            """Try to obtain a hook specification from an item with the given name'
    and: '            in the given module or class which is being searched for hook specs.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookspec options for defining a hook, or None to skip the'
    and: '                given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook specifications are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookspecMarker`.'
    and: '            """'
    and: '            method = getattr(module_or_class, name)'
    and: '            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)'
    and: '            return opts'
    and: '    '
    and: '        def get_plugins(self) -> set[Any]:'
    and: '            """Return a set of all registered plugin objects."""'
    and: '            return set(self._name2plugin.values())'
    and: '    '
    and: '        def is_registered(self, plugin: _Plugin) -> bool:'
    and: '            """Return whether the plugin is already registered."""'
    and: '            return any(plugin == val for val in self._name2plugin.values())'
    and: '    '
    and: '        def get_canonical_name(self, plugin: _Plugin) -> str:'
    and: '            """Return a canonical name for a plugin object.'
    and: '    '
    and: '            Note that a plugin may be registered under a different name'
    and: '            specified by the caller of :meth:`register(plugin, name) <register>`.'
    and: '            To obtain the name of a registered plugin use :meth:`get_name(plugin)'
    and: '            <get_name>` instead.'
    and: '            """'
    and: '            name: str | None = getattr(plugin, "__name__", None)'
    and: '            return name or str(id(plugin))'
    and: '    '
    and: '        def get_plugin(self, name: str) -> Any | None:'
    and: '            """Return the plugin registered under the given name, if any."""'
    and: '            return self._name2plugin.get(name)'
    and: '    '
    and: '        def has_plugin(self, name: str) -> bool:'
    and: '            """Return whether a plugin with the given name is registered."""'
    and: '            return self.get_plugin(name) is not None'
    and: '    '
    and: '        def get_name(self, plugin: _Plugin) -> str | None:'
    and: '            """Return the name the plugin is registered under, or ``None`` if'
    and: '            is isn\'t."""'
    and: '            for name, val in self._name2plugin.items():'
    and: '                if plugin == val:'
    and: '                    return name'
    and: '            return None'
    and: '    '
    and: '        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:'
    and: '            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r\\nhook %r\\nhistoric incompatible with yield/wrapper/hookwrapper"'
    and: '                    % (hookimpl.plugin_name, hook.name),'
    and: '                )'
    and: '    '
    and: '            assert hook.spec is not None'
    and: '            if hook.spec.warn_on_impl:'
    and: '                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)'
    and: '    '
    and: '            # positional arg checking'
    and: '            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)'
    and: '            if notinspec:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Argument(s) %s are declared in the hookimpl but "'
    and: '                    "can not be found in the hookspec"'
    and: '                    % ('
    and: '                        hookimpl.plugin_name,'
    and: '                        hook.name,'
    and: '                        _formatdef(hookimpl.function),'
    and: '                        notinspec,'
    and: '                    ),'
    and: '                )'
    and: '    '
    and: '            if ('
    and: '                hookimpl.wrapper or hookimpl.hookwrapper'
    and: '            ) and not inspect.isgeneratorfunction(hookimpl.function):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Declared as wrapper=True or hookwrapper=True "'
    and: '                    "but function is not a generator function"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '            if hookimpl.wrapper and hookimpl.hookwrapper:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "The wrapper=True and hookwrapper=True options are mutually exclusive"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '        def check_pending(self) -> None:'
    and: '            """Verify that all hooks which have not been verified against a'
    and: '            hook specification are optional, otherwise raise'
    and: '            :exc:`PluginValidationError`."""'
    and: '            for name in self.hook.__dict__:'
    and: '                if name[0] != "_":'
    and: '                    hook: HookCaller = getattr(self.hook, name)'
    and: '                    if not hook.has_spec():'
    and: '                        for hookimpl in hook.get_hookimpls():'
    and: '                            if not hookimpl.optionalhook:'
    and: '                                raise PluginValidationError('
    and: '                                    hookimpl.plugin,'
    and: '                                    "unknown hook %r in plugin %r"'
    and: '                                    % (name, hookimpl.plugin),'
    and: '                                )'
    and: '    '
    and: '        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:'
    and: '            """Load modules from querying the specified setuptools ``group``.'
    and: '    '
    and: '            :param group:'
    and: '                Entry point group to load plugins.'
    and: '            :param name:'
    and: '                If given, loads only plugins with the given ``name``.'
    and: '    '
    and: '            :return:'
    and: '                The number of plugins loaded by this call.'
    and: '            """'
    and: '            count = 0'
    and: '            for dist in list(importlib.metadata.distributions()):'
    and: '                for ep in dist.entry_points:'
    and: '                    if ('
    and: '                        ep.group != group'
    and: '                        or (name is not None and ep.name != name)'
    and: '                        # already registered'
    and: '                        or self.get_plugin(ep.name)'
    and: '                        or self.is_blocked(ep.name)'
    and: '                    ):'
    and: '                        continue'
    and: '                    plugin = ep.load()'
    and: '                    self.register(plugin, name=ep.name)'
    and: '                    self._plugin_distinfo.append((plugin, DistFacade(dist)))'
    and: '                    count += 1'
    and: '            return count'
    and: '    '
    and: '        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:'
    and: '            """Return a list of (plugin, distinfo) pairs for all'
    and: '            setuptools-registered plugins."""'
    and: '            return list(self._plugin_distinfo)'
    and: '    '
    and: '        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:'
    and: '            """Return a list of (name, plugin) pairs for all registered plugins."""'
    and: '            return list(self._name2plugin.items())'
    and: '    '
    and: '        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:'
    and: '            """Get all hook callers for the specified plugin.'
    and: '    '
    and: '            :returns:'
    and: '                The hook callers, or ``None`` if ``plugin`` is not registered in'
    and: '                this plugin manager.'
    and: '            """'
    and: '            if self.get_name(plugin) is None:'
    and: '                return None'
    and: '            hookcallers = []'
    and: '            for hookcaller in self.hook.__dict__.values():'
    and: '                for hookimpl in hookcaller.get_hookimpls():'
    and: '                    if hookimpl.plugin is plugin:'
    and: '                        hookcallers.append(hookcaller)'
    and: '            return hookcallers'
    and: '    '
    and: '        def add_hookcall_monitoring('
    and: '            self, before: _BeforeTrace, after: _AfterTrace'
    and: '        ) -> Callable[[], None]:'
    and: '            """Add before/after tracing functions for all hooks.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracers.'
    and: '    '
    and: '            ``before(hook_name, hook_impls, kwargs)`` will be called ahead'
    and: '            of all hook calls and receive a hookcaller instance, a list'
    and: '            of HookImpl instances and the keyword arguments for the hook call.'
    and: '    '
    and: '            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the'
    and: '            same arguments as ``before`` but also a :class:`~pluggy.Result` object'
    and: '            which represents the result of the overall hook call.'
    and: '            """'
    and: '            oldcall = self._inner_hookexec'
    and: '    '
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>               return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x6414ea79>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x8338e42>'
    and: ''
    and: '        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '            """:meta private:"""'
    and: '            __tracebackhide__ = True'
    and: '            result = exception = None'
    and: '            try:'
    and: '>               result = func()'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '            return cls(result, exception)'
    and: '    '
    and: '        def force_result(self, result: ResultType) -> None:'
    and: '            """Force the result(s) to ``result``.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` a single value should'
    and: '            be set, otherwise set a (modified) list of results. Any exceptions'
    and: '            found during invocation will be deleted.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '            """'
    and: '            self._result = result'
    and: '            self._exception = None'
    and: '    '
    and: '        def force_exception(self, exception: BaseException) -> None:'
    and: '            """Force the result to fail with ``exception``.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '    '
    and: '            .. versionadded:: 1.1.0'
    and: '            """'
    and: '            self._result = None'
    and: '            self._exception = exception'
    and: '    '
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '                raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '>   ???'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x5e245663>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '            raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '        def runtest(self):'
    and: "            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '                 redirect_stdout(to), redirect_stderr(te):'
    and: '>               found_errors = check_file('
    and: '                    self.fspath,'
    and: '                    self.flake8ignore,'
    and: '                    self.maxlength,'
    and: '                    self.maxdoclength,'
    and: '                    self.maxcomplexity,'
    and: '                    self.showsource,'
    and: '                    self.statistics'
    and: '                )'
    and: '                to.flush()'
    and: '                te.flush()'
    and: "                out = bo.getvalue().decode('utf-8')"
    and: "                err = be.getvalue().decode('utf-8')"
    and: '    '
    and: '            if found_errors:'
    and: '                raise Flake8Error(out, err)'
    and: '            # update mtime only if test passed'
    and: '            # otherwise failures would not be re-run next time'
    and: '            if hasattr(self.config, "_flake8mtimes"):'
    and: '                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,'
    and: '                                                               self.flake8ignore)'
    and: '    '
    and: '        def repr_failure(self, excinfo):'
    and: '            if excinfo.errisinstance(Flake8Error):'
    and: '                return excinfo.value.args[0]'
    and: '            return super(Flake8Item, self).repr_failure(excinfo)'
    and: '    '
    and: '        def reportinfo(self):'
    and: '            if self.flake8ignore:'
    and: '                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)'
    and: '            else:'
    and: '                ignores = ""'
    and: '            return (self.fspath, -1, "FLAKE8-check%s" % ignores)'
    and: '    '
    and: '    '
    and: '    class Ignorer:'
    and: '        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\\d\\d\\d")):'
    and: '            self.ignores = ignores = []'
    and: '            for line in ignorelines:'
    and: '                i = line.find("#")'
    and: '                if i != -1:'
    and: '                    line = line[:i]'
    and: '                try:'
    and: '                    glob, ign = line.split(None, 1)'
    and: '                except ValueError:'
    and: '                    glob, ign = None, line'
    and: '                if glob and coderex.match(glob):'
    and: '                    glob, ign = None, line'
    and: '                ign = ign.split()'
    and: '                if "ALL" in ign:'
    and: '                    ign = None'
    and: '                if glob and "/" != os.sep and "/" in glob:'
    and: '                    glob = glob.replace("/", os.sep)'
    and: '                ignores.append((glob, ign))'
    and: '    '
    and: '        def __call__(self, path):'
    and: '            l = []  # noqa: E741'
    and: '            for (glob, ignlist) in self.ignores:'
    and: '                if not glob or path.fnmatch(glob):'
    and: '                    if ignlist is None:'
    and: '                        return None'
    and: '                    l.extend(ignlist)'
    and: '            return l'
    and: '    '
    and: '    '
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '        prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-5/test_mtime_caching0/hello.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x68f3505d>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '>               result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def __call__(self, **kwargs: object) -> Any:'
    and: '            """Call the hook.'
    and: '    '
    and: '            Only accepts keyword arguments, which should match the hook'
    and: '            specification.'
    and: '    '
    and: '            Returns the result(s) of calling all registered plugins, see'
    and: '            :ref:`calling`.'
    and: '            """'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def call_historic('
    and: '            self,'
    and: '            result_callback: Callable[[Any], None] | None = None,'
    and: '            kwargs: Mapping[str, object] | None = None,'
    and: '        ) -> None:'
    and: '            """Call the hook with given ``kwargs`` for all registered plugins and'
    and: '            for all plugins which will be registered afterwards, see'
    and: '            :ref:`historic`.'
    and: '    '
    and: '            :param result_callback:'
    and: '                If provided, will be called for each non-``None`` result obtained'
    and: '                from a hook implementation.'
    and: '            """'
    and: '            assert self._call_history is not None'
    and: '            kwargs = kwargs or {}'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            self._call_history.append((kwargs, result_callback))'
    and: "            # Historizing hooks don't return results."
    and: "            # Remember firstresult isn't compatible with historic."
    and: '            res = self._hookexec(self.name, self._hookimpls, kwargs, False)'
    and: '            if result_callback is None:'
    and: '                return'
    and: '            if isinstance(res, list):'
    and: '                for x in res:'
    and: '                    result_callback(x)'
    and: '    '
    and: '        def call_extra('
    and: '            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]'
    and: '        ) -> Any:'
    and: '            """Call the hook with some additional temporarily participating'
    and: '            methods using the specified ``kwargs`` as call parameters, see'
    and: '            :ref:`call_extra`."""'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            opts: HookimplOpts = {'
    and: '                "wrapper": False,'
    and: '                "hookwrapper": False,'
    and: '                "optionalhook": False,'
    and: '                "trylast": False,'
    and: '                "tryfirst": False,'
    and: '                "specname": None,'
    and: '            }'
    and: '            hookimpls = self._hookimpls.copy()'
    and: '            for method in methods:'
    and: '                hookimpl = HookImpl(None, "<temp>", method, opts)'
    and: '                # Find last non-tryfirst nonwrapper method.'
    and: '                i = len(hookimpls) - 1'
    and: '                while ('
    and: '                    i >= 0'
    and: '                    and hookimpls[i].tryfirst'
    and: '                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)'
    and: '                ):'
    and: '                    i -= 1'
    and: '                hookimpls.insert(i + 1, hookimpl)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '            return self._hookexec(self.name, hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def _maybe_apply_history(self, method: HookImpl) -> None:'
    and: '            """Apply call history to a new hookimpl if it is marked as historic."""'
    and: '            if self.is_historic():'
    and: '                assert self._call_history is not None'
    and: '                for kwargs, result_callback in self._call_history:'
    and: '                    res = self._hookexec(self.name, [method], kwargs, False)'
    and: '                    if res and result_callback is not None:'
    and: "                        # XXX: remember firstresult isn't compat with historic"
    and: '                        assert isinstance(res, list)'
    and: '                        result_callback(res[0])'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: '    _HookCaller = HookCaller'
    and: '    '
    and: '    '
    and: '    class _SubsetHookCaller(HookCaller):'
    and: '        """A proxy to another HookCaller which manages calls to all registered'
    and: '        plugins except the ones from remove_plugins."""'
    and: '    '
    and: '        # This class is unusual: in inhertits from `HookCaller` so all of'
    and: '        # the *code* runs in the class, but it delegates all underlying *data*'
    and: '        # to the original HookCaller.'
    and: '        # `subset_hook_caller` used to be implemented by creating a full-fledged'
    and: '        # HookCaller, copying all hookimpls from the original. This had problems'
    and: '        # with memory leaks (#346) and historic calls (#347), which make a proxy'
    and: '        # approach better.'
    and: '        # An alternative implementation is to use a `_getattr__`/`__getattribute__`'
    and: '        # proxy, however that adds more overhead and is more tricky to implement.'
    and: '    '
    and: '        __slots__ = ('
    and: '            "_orig",'
    and: '            "_remove_plugins",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:'
    and: '            self._orig = orig'
    and: '            self._remove_plugins = remove_plugins'
    and: '            self.name = orig.name  # type: ignore[misc]'
    and: '            self._hookexec = orig._hookexec  # type: ignore[misc]'
    and: '    '
    and: '        @property  # type: ignore[misc]'
    and: '        def _hookimpls(self) -> list[HookImpl]:'
    and: '            return ['
    and: '                impl'
    and: '                for impl in self._orig._hookimpls'
    and: '                if impl.plugin not in self._remove_plugins'
    and: '            ]'
    and: '    '
    and: '        @property'
    and: '        def spec(self) -> HookSpec | None:  # type: ignore[override]'
    and: '            return self._orig.spec'
    and: '    '
    and: '        @property'
    and: '        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]'
    and: '            return self._orig._call_history'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<_SubsetHookCaller {self.name!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookImpl:'
    and: '        """A hook implementation in a :class:`HookCaller`."""'
    and: '    '
    and: '        __slots__ = ('
    and: '            "function",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "plugin",'
    and: '            "opts",'
    and: '            "plugin_name",'
    and: '            "wrapper",'
    and: '            "hookwrapper",'
    and: '            "optionalhook",'
    and: '            "tryfirst",'
    and: '            "trylast",'
    and: '        )'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            plugin: _Plugin,'
    and: '            plugin_name: str,'
    and: '            function: _HookImplFunction[object],'
    and: '            hook_impl_opts: HookimplOpts,'
    and: '        ) -> None:'
    and: '            """:meta private:"""'
    and: '            #: The hook implementation function.'
    and: '            self.function: Final = function'
    and: '            argnames, kwargnames = varnames(self.function)'
    and: '            #: The positional parameter names of ``function```.'
    and: '            self.argnames: Final = argnames'
    and: '            #: The keyword parameter names of ``function```.'
    and: '            self.kwargnames: Final = kwargnames'
    and: '            #: The plugin which defined this hook implementation.'
    and: '            self.plugin: Final = plugin'
    and: '            #: The :class:`HookimplOpts` used to configure this hook implementation.'
    and: '            self.opts: Final = hook_impl_opts'
    and: '            #: The name of the plugin which defined this hook implementation.'
    and: '            self.plugin_name: Final = plugin_name'
    and: '            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.'
    and: '            self.wrapper: Final = hook_impl_opts["wrapper"]'
    and: '            #: Whether the hook implementation is an :ref:`old-style wrapper'
    and: '            #: <old_style_hookwrappers>`.'
    and: '            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]'
    and: '            #: Whether validation against a hook specification is :ref:`optional'
    and: '            #: <optionalhook>`.'
    and: '            self.optionalhook: Final = hook_impl_opts["optionalhook"]'
    and: '            #: Whether to try to order this hook implementation :ref:`first'
    and: '            #: <callorder>`.'
    and: '            self.tryfirst: Final = hook_impl_opts["tryfirst"]'
    and: '            #: Whether to try to order this hook implementation :ref:`last'
    and: '            #: <callorder>`.'
    and: '            self.trylast: Final = hook_impl_opts["trylast"]'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookSpec:'
    and: '        __slots__ = ('
    and: '            "namespace",'
    and: '            "function",'
    and: '            "name",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "opts",'
    and: '            "warn_on_impl",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:'
    and: '            self.namespace = namespace'
    and: '            self.function: Callable[..., object] = getattr(namespace, name)'
    and: '            self.name = name'
    and: '            self.argnames, self.kwargnames = varnames(self.function)'
    and: '            self.opts = opts'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0xa8b1660>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def _hookexec('
    and: '            self,'
    and: '            hook_name: str,'
    and: '            methods: Sequence[HookImpl],'
    and: '            kwargs: Mapping[str, object],'
    and: '            firstresult: bool,'
    and: '        ) -> object | list[object]:'
    and: '            # called from all hookcaller instances.'
    and: '            # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: '    '
    and: '        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:'
    and: '            """Register a plugin and return its name.'
    and: '    '
    and: '            :param name:'
    and: '                The name under which to register the plugin. If not specified, a'
    and: '                name is generated using :func:`get_canonical_name`.'
    and: '    '
    and: '            :returns:'
    and: '                The plugin name. If the name is blocked from registering, returns'
    and: '                ``None``.'
    and: '    '
    and: '            If the plugin is already registered, raises a :exc:`ValueError`.'
    and: '            """'
    and: '            plugin_name = name or self.get_canonical_name(plugin)'
    and: '    '
    and: '            if plugin_name in self._name2plugin:'
    and: '                if self._name2plugin.get(plugin_name, -1) is None:'
    and: '                    return None  # blocked plugin, return None to indicate no registration'
    and: '                raise ValueError('
    and: '                    "Plugin name already registered: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            if plugin in self._name2plugin.values():'
    and: '                raise ValueError('
    and: '                    "Plugin already registered under a different name: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            # XXX if an error happens we should make sure no state has been'
    and: '            # changed at point of return'
    and: '            self._name2plugin[plugin_name] = plugin'
    and: '    '
    and: '            # register matching hook implementations of the plugin'
    and: '            for name in dir(plugin):'
    and: '                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)'
    and: '                if hookimpl_opts is not None:'
    and: '                    normalize_hookimpl_opts(hookimpl_opts)'
    and: '                    method: _HookImplFunction[object] = getattr(plugin, name)'
    and: '                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)'
    and: '                    name = hookimpl_opts.get("specname") or name'
    and: '                    hook: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hook is None:'
    and: '                        hook = HookCaller(name, self._hookexec)'
    and: '                        setattr(self.hook, name, hook)'
    and: '                    elif hook.has_spec():'
    and: '                        self._verify_hook(hook, hookimpl)'
    and: '                        hook._maybe_apply_history(hookimpl)'
    and: '                    hook._add_hookimpl(hookimpl)'
    and: '            return plugin_name'
    and: '    '
    and: '        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:'
    and: '            """Try to obtain a hook implementation from an item with the given name'
    and: '            in the given plugin which is being searched for hook impls.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookimpl options, or None to skip the given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook implementation are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookimplMarker`.'
    and: '            """'
    and: '            method: object = getattr(plugin, name)'
    and: '            if not inspect.isroutine(method):'
    and: '                return None'
    and: '            try:'
    and: '                res: HookimplOpts | None = getattr('
    and: '                    method, self.project_name + "_impl", None'
    and: '                )'
    and: '            except Exception:'
    and: '                res = {}  # type: ignore[assignment]'
    and: '            if res is not None and not isinstance(res, dict):'
    and: '                # false positive'
    and: '                res = None  # type:ignore[unreachable]'
    and: '            return res'
    and: '    '
    and: '        def unregister('
    and: '            self, plugin: _Plugin | None = None, name: str | None = None'
    and: '        ) -> Any | None:'
    and: '            """Unregister a plugin and all of its hook implementations.'
    and: '    '
    and: '            The plugin can be specified either by the plugin object or the plugin'
    and: '            name. If both are specified, they must agree.'
    and: '    '
    and: '            Returns the unregistered plugin, or ``None`` if not found.'
    and: '            """'
    and: '            if name is None:'
    and: '                assert plugin is not None, "one of name or plugin needs to be specified"'
    and: '                name = self.get_name(plugin)'
    and: '                assert name is not None, "plugin is not registered"'
    and: '    '
    and: '            if plugin is None:'
    and: '                plugin = self.get_plugin(name)'
    and: '                if plugin is None:'
    and: '                    return None'
    and: '    '
    and: '            hookcallers = self.get_hookcallers(plugin)'
    and: '            if hookcallers:'
    and: '                for hookcaller in hookcallers:'
    and: '                    hookcaller._remove_plugin(plugin)'
    and: '    '
    and: '            # if self._name2plugin[name] == None registration was blocked: ignore'
    and: '            if self._name2plugin.get(name):'
    and: '                assert name is not None'
    and: '                del self._name2plugin[name]'
    and: '    '
    and: '            return plugin'
    and: '    '
    and: '        def set_blocked(self, name: str) -> None:'
    and: '            """Block registrations of the given name, unregister if already registered."""'
    and: '            self.unregister(name=name)'
    and: '            self._name2plugin[name] = None'
    and: '    '
    and: '        def is_blocked(self, name: str) -> bool:'
    and: '            """Return whether the given plugin name is blocked."""'
    and: '            return name in self._name2plugin and self._name2plugin[name] is None'
    and: '    '
    and: '        def add_hookspecs(self, module_or_class: _Namespace) -> None:'
    and: '            """Add new hook specifications defined in the given ``module_or_class``.'
    and: '    '
    and: '            Functions are recognized as hook specifications if they have been'
    and: '            decorated with a matching :class:`HookspecMarker`.'
    and: '            """'
    and: '            names = []'
    and: '            for name in dir(module_or_class):'
    and: '                spec_opts = self.parse_hookspec_opts(module_or_class, name)'
    and: '                if spec_opts is not None:'
    and: '                    hc: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hc is None:'
    and: '                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)'
    and: '                        setattr(self.hook, name, hc)'
    and: '                    else:'
    and: '                        # Plugins registered this hook without knowing the spec.'
    and: '                        hc.set_specification(module_or_class, spec_opts)'
    and: '                        for hookfunction in hc.get_hookimpls():'
    and: '                            self._verify_hook(hc, hookfunction)'
    and: '                    names.append(name)'
    and: '    '
    and: '            if not names:'
    and: '                raise ValueError('
    and: '                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"'
    and: '                )'
    and: '    '
    and: '        def parse_hookspec_opts('
    and: '            self, module_or_class: _Namespace, name: str'
    and: '        ) -> HookspecOpts | None:'
    and: '            """Try to obtain a hook specification from an item with the given name'
    and: '            in the given module or class which is being searched for hook specs.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookspec options for defining a hook, or None to skip the'
    and: '                given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook specifications are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookspecMarker`.'
    and: '            """'
    and: '            method = getattr(module_or_class, name)'
    and: '            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)'
    and: '            return opts'
    and: '    '
    and: '        def get_plugins(self) -> set[Any]:'
    and: '            """Return a set of all registered plugin objects."""'
    and: '            return set(self._name2plugin.values())'
    and: '    '
    and: '        def is_registered(self, plugin: _Plugin) -> bool:'
    and: '            """Return whether the plugin is already registered."""'
    and: '            return any(plugin == val for val in self._name2plugin.values())'
    and: '    '
    and: '        def get_canonical_name(self, plugin: _Plugin) -> str:'
    and: '            """Return a canonical name for a plugin object.'
    and: '    '
    and: '            Note that a plugin may be registered under a different name'
    and: '            specified by the caller of :meth:`register(plugin, name) <register>`.'
    and: '            To obtain the name of a registered plugin use :meth:`get_name(plugin)'
    and: '            <get_name>` instead.'
    and: '            """'
    and: '            name: str | None = getattr(plugin, "__name__", None)'
    and: '            return name or str(id(plugin))'
    and: '    '
    and: '        def get_plugin(self, name: str) -> Any | None:'
    and: '            """Return the plugin registered under the given name, if any."""'
    and: '            return self._name2plugin.get(name)'
    and: '    '
    and: '        def has_plugin(self, name: str) -> bool:'
    and: '            """Return whether a plugin with the given name is registered."""'
    and: '            return self.get_plugin(name) is not None'
    and: '    '
    and: '        def get_name(self, plugin: _Plugin) -> str | None:'
    and: '            """Return the name the plugin is registered under, or ``None`` if'
    and: '            is isn\'t."""'
    and: '            for name, val in self._name2plugin.items():'
    and: '                if plugin == val:'
    and: '                    return name'
    and: '            return None'
    and: '    '
    and: '        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:'
    and: '            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r\\nhook %r\\nhistoric incompatible with yield/wrapper/hookwrapper"'
    and: '                    % (hookimpl.plugin_name, hook.name),'
    and: '                )'
    and: '    '
    and: '            assert hook.spec is not None'
    and: '            if hook.spec.warn_on_impl:'
    and: '                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)'
    and: '    '
    and: '            # positional arg checking'
    and: '            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)'
    and: '            if notinspec:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Argument(s) %s are declared in the hookimpl but "'
    and: '                    "can not be found in the hookspec"'
    and: '                    % ('
    and: '                        hookimpl.plugin_name,'
    and: '                        hook.name,'
    and: '                        _formatdef(hookimpl.function),'
    and: '                        notinspec,'
    and: '                    ),'
    and: '                )'
    and: '    '
    and: '            if ('
    and: '                hookimpl.wrapper or hookimpl.hookwrapper'
    and: '            ) and not inspect.isgeneratorfunction(hookimpl.function):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Declared as wrapper=True or hookwrapper=True "'
    and: '                    "but function is not a generator function"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '            if hookimpl.wrapper and hookimpl.hookwrapper:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "The wrapper=True and hookwrapper=True options are mutually exclusive"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '        def check_pending(self) -> None:'
    and: '            """Verify that all hooks which have not been verified against a'
    and: '            hook specification are optional, otherwise raise'
    and: '            :exc:`PluginValidationError`."""'
    and: '            for name in self.hook.__dict__:'
    and: '                if name[0] != "_":'
    and: '                    hook: HookCaller = getattr(self.hook, name)'
    and: '                    if not hook.has_spec():'
    and: '                        for hookimpl in hook.get_hookimpls():'
    and: '                            if not hookimpl.optionalhook:'
    and: '                                raise PluginValidationError('
    and: '                                    hookimpl.plugin,'
    and: '                                    "unknown hook %r in plugin %r"'
    and: '                                    % (name, hookimpl.plugin),'
    and: '                                )'
    and: '    '
    and: '        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:'
    and: '            """Load modules from querying the specified setuptools ``group``.'
    and: '    '
    and: '            :param group:'
    and: '                Entry point group to load plugins.'
    and: '            :param name:'
    and: '                If given, loads only plugins with the given ``name``.'
    and: '    '
    and: '            :return:'
    and: '                The number of plugins loaded by this call.'
    and: '            """'
    and: '            count = 0'
    and: '            for dist in list(importlib.metadata.distributions()):'
    and: '                for ep in dist.entry_points:'
    and: '                    if ('
    and: '                        ep.group != group'
    and: '                        or (name is not None and ep.name != name)'
    and: '                        # already registered'
    and: '                        or self.get_plugin(ep.name)'
    and: '                        or self.is_blocked(ep.name)'
    and: '                    ):'
    and: '                        continue'
    and: '                    plugin = ep.load()'
    and: '                    self.register(plugin, name=ep.name)'
    and: '                    self._plugin_distinfo.append((plugin, DistFacade(dist)))'
    and: '                    count += 1'
    and: '            return count'
    and: '    '
    and: '        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:'
    and: '            """Return a list of (plugin, distinfo) pairs for all'
    and: '            setuptools-registered plugins."""'
    and: '            return list(self._plugin_distinfo)'
    and: '    '
    and: '        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:'
    and: '            """Return a list of (name, plugin) pairs for all registered plugins."""'
    and: '            return list(self._name2plugin.items())'
    and: '    '
    and: '        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:'
    and: '            """Get all hook callers for the specified plugin.'
    and: '    '
    and: '            :returns:'
    and: '                The hook callers, or ``None`` if ``plugin`` is not registered in'
    and: '                this plugin manager.'
    and: '            """'
    and: '            if self.get_name(plugin) is None:'
    and: '                return None'
    and: '            hookcallers = []'
    and: '            for hookcaller in self.hook.__dict__.values():'
    and: '                for hookimpl in hookcaller.get_hookimpls():'
    and: '                    if hookimpl.plugin is plugin:'
    and: '                        hookcallers.append(hookcaller)'
    and: '            return hookcallers'
    and: '    '
    and: '        def add_hookcall_monitoring('
    and: '            self, before: _BeforeTrace, after: _AfterTrace'
    and: '        ) -> Callable[[], None]:'
    and: '            """Add before/after tracing functions for all hooks.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracers.'
    and: '    '
    and: '            ``before(hook_name, hook_impls, kwargs)`` will be called ahead'
    and: '            of all hook calls and receive a hookcaller instance, a list'
    and: '            of HookImpl instances and the keyword arguments for the hook call.'
    and: '    '
    and: '            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the'
    and: '            same arguments as ``before`` but also a :class:`~pluggy.Result` object'
    and: '            which represents the result of the overall hook call.'
    and: '            """'
    and: '            oldcall = self._inner_hookexec'
    and: '    '
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>               return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x7e39c849>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x101b583e>'
    and: ''
    and: '        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '            """:meta private:"""'
    and: '            __tracebackhide__ = True'
    and: '            result = exception = None'
    and: '            try:'
    and: '>               result = func()'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '            return cls(result, exception)'
    and: '    '
    and: '        def force_result(self, result: ResultType) -> None:'
    and: '            """Force the result(s) to ``result``.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` a single value should'
    and: '            be set, otherwise set a (modified) list of results. Any exceptions'
    and: '            found during invocation will be deleted.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '            """'
    and: '            self._result = result'
    and: '            self._exception = None'
    and: '    '
    and: '        def force_exception(self, exception: BaseException) -> None:'
    and: '            """Force the result to fail with ``exception``.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '    '
    and: '            .. versionadded:: 1.1.0'
    and: '            """'
    and: '            self._result = None'
    and: '            self._exception = exception'
    and: '    '
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '                raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '>   ???'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x13c06df2>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '            raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '        def runtest(self):'
    and: "            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '                 redirect_stdout(to), redirect_stderr(te):'
    and: '>               found_errors = check_file('
    and: '                    self.fspath,'
    and: '                    self.flake8ignore,'
    and: '                    self.maxlength,'
    and: '                    self.maxdoclength,'
    and: '                    self.maxcomplexity,'
    and: '                    self.showsource,'
    and: '                    self.statistics'
    and: '                )'
    and: '                to.flush()'
    and: '                te.flush()'
    and: "                out = bo.getvalue().decode('utf-8')"
    and: "                err = be.getvalue().decode('utf-8')"
    and: '    '
    and: '            if found_errors:'
    and: '                raise Flake8Error(out, err)'
    and: '            # update mtime only if test passed'
    and: '            # otherwise failures would not be re-run next time'
    and: '            if hasattr(self.config, "_flake8mtimes"):'
    and: '                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,'
    and: '                                                               self.flake8ignore)'
    and: '    '
    and: '        def repr_failure(self, excinfo):'
    and: '            if excinfo.errisinstance(Flake8Error):'
    and: '                return excinfo.value.args[0]'
    and: '            return super(Flake8Item, self).repr_failure(excinfo)'
    and: '    '
    and: '        def reportinfo(self):'
    and: '            if self.flake8ignore:'
    and: '                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)'
    and: '            else:'
    and: '                ignores = ""'
    and: '            return (self.fspath, -1, "FLAKE8-check%s" % ignores)'
    and: '    '
    and: '    '
    and: '    class Ignorer:'
    and: '        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\\d\\d\\d")):'
    and: '            self.ignores = ignores = []'
    and: '            for line in ignorelines:'
    and: '                i = line.find("#")'
    and: '                if i != -1:'
    and: '                    line = line[:i]'
    and: '                try:'
    and: '                    glob, ign = line.split(None, 1)'
    and: '                except ValueError:'
    and: '                    glob, ign = None, line'
    and: '                if glob and coderex.match(glob):'
    and: '                    glob, ign = None, line'
    and: '                ign = ign.split()'
    and: '                if "ALL" in ign:'
    and: '                    ign = None'
    and: '                if glob and "/" != os.sep and "/" in glob:'
    and: '                    glob = glob.replace("/", os.sep)'
    and: '                ignores.append((glob, ign))'
    and: '    '
    and: '        def __call__(self, path):'
    and: '            l = []  # noqa: E741'
    and: '            for (glob, ignlist) in self.ignores:'
    and: '                if not glob or path.fnmatch(glob):'
    and: '                    if ignlist is None:'
    and: '                        return None'
    and: '                    l.extend(ignlist)'
    and: '            return l'
    and: '    '
    and: '    '
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '        prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-5/test_mtime_caching0/test_mtime_caching.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n..."
    and: "FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
    and: '============================== 2 failed in 0.26s ==============================='
remains unmatched: '*W293*'
---------------------------- Captured stderr setup -----------------------------
/tmp/pytest-of-tester/pytest-5/test_mtime_caching0
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_mtime_caching0
plugins: flake8-1.1.1
collected 2 items

hello.py F                                                               [ 50%]
test_mtime_caching.py F                                                  [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x70a5d852>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0xa8b1660>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x6414ea79>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x8338e42>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x5e245663>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_mtime_caching0/hello.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x68f3505d>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0xa8b1660>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7e39c849>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x101b583e>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x13c06df2>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_mtime_caching0/test_mtime_caching.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED hello.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...
FAILED test_mtime_caching.py::flake-8::FLAKE8 - AttributeError: 'Application'...
============================== 2 failed in 0.26s ===============================
_______________________________ test_ok_verbose ________________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 139, in test_ok_verbose
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0 -- /workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/bin/python
cachedir: .pytest_cache
rootdir: /tmp/pytest-of-tester/pytest-5/test_ok_verbose0
plugins: flake8-1.1.1
collecting ... collected 1 item

test_ok_verbose.py::flake-8::FLAKE8 FAILED                               [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x61956dbe>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x2158adf4>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x7809b421>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x218af408>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x2051323a>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_ok_verbose0/test_ok_verbose.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED test_ok_verbose.py::flake-8::FLAKE8 - AttributeError: 'Application' ob...
============================== 1 failed in 0.15s ===============================
______________________________ test_keyword_match ______________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 149, in test_keyword_match
    result.stdout.fnmatch_lines([
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1650, in fnmatch_lines
    self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1737, in _match_lines
    self._fail(msg)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 1785, in _fail
    fail(log_text)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/outcomes.py", line 198, in fail
    raise Failed(msg=reason, pytrace=pytrace)
Failed: nomatch: '*E201*'
    and: '============================= test session starts =============================='
    and: 'platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0'
    and: 'rootdir: /tmp/pytest-of-tester/pytest-5/test_keyword_match0'
    and: 'plugins: flake8-1.1.1'
    and: 'collected 2 items / 1 deselected / 1 selected'
    and: ''
    and: 'test_keyword_match.py F                                                  [100%]'
    and: ''
    and: '=================================== FAILURES ==================================='
    and: '_________________________________ FLAKE8-check _________________________________'
    and: ''
    and: "cls = <class '_pytest.runner.CallInfo'>"
    and: 'func = <function call_runtest_hook.<locals>.<lambda> at 0x564af0b4>'
    and: "when = 'call'"
    and: "reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)"
    and: ''
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '>               result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "self = <HookCaller 'pytest_runtest_call'>"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def __call__(self, **kwargs: object) -> Any:'
    and: '            """Call the hook.'
    and: '    '
    and: '            Only accepts keyword arguments, which should match the hook'
    and: '            specification.'
    and: '    '
    and: '            Returns the result(s) of calling all registered plugins, see'
    and: '            :ref:`calling`.'
    and: '            """'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def call_historic('
    and: '            self,'
    and: '            result_callback: Callable[[Any], None] | None = None,'
    and: '            kwargs: Mapping[str, object] | None = None,'
    and: '        ) -> None:'
    and: '            """Call the hook with given ``kwargs`` for all registered plugins and'
    and: '            for all plugins which will be registered afterwards, see'
    and: '            :ref:`historic`.'
    and: '    '
    and: '            :param result_callback:'
    and: '                If provided, will be called for each non-``None`` result obtained'
    and: '                from a hook implementation.'
    and: '            """'
    and: '            assert self._call_history is not None'
    and: '            kwargs = kwargs or {}'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            self._call_history.append((kwargs, result_callback))'
    and: "            # Historizing hooks don't return results."
    and: "            # Remember firstresult isn't compatible with historic."
    and: '            res = self._hookexec(self.name, self._hookimpls, kwargs, False)'
    and: '            if result_callback is None:'
    and: '                return'
    and: '            if isinstance(res, list):'
    and: '                for x in res:'
    and: '                    result_callback(x)'
    and: '    '
    and: '        def call_extra('
    and: '            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]'
    and: '        ) -> Any:'
    and: '            """Call the hook with some additional temporarily participating'
    and: '            methods using the specified ``kwargs`` as call parameters, see'
    and: '            :ref:`call_extra`."""'
    and: '            assert ('
    and: '                not self.is_historic()'
    and: '            ), "Cannot directly call a historic hook - use call_historic instead."'
    and: '            self._verify_all_args_are_provided(kwargs)'
    and: '            opts: HookimplOpts = {'
    and: '                "wrapper": False,'
    and: '                "hookwrapper": False,'
    and: '                "optionalhook": False,'
    and: '                "trylast": False,'
    and: '                "tryfirst": False,'
    and: '                "specname": None,'
    and: '            }'
    and: '            hookimpls = self._hookimpls.copy()'
    and: '            for method in methods:'
    and: '                hookimpl = HookImpl(None, "<temp>", method, opts)'
    and: '                # Find last non-tryfirst nonwrapper method.'
    and: '                i = len(hookimpls) - 1'
    and: '                while ('
    and: '                    i >= 0'
    and: '                    and hookimpls[i].tryfirst'
    and: '                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)'
    and: '                ):'
    and: '                    i -= 1'
    and: '                hookimpls.insert(i + 1, hookimpl)'
    and: '            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False'
    and: '            return self._hookexec(self.name, hookimpls, kwargs, firstresult)'
    and: '    '
    and: '        def _maybe_apply_history(self, method: HookImpl) -> None:'
    and: '            """Apply call history to a new hookimpl if it is marked as historic."""'
    and: '            if self.is_historic():'
    and: '                assert self._call_history is not None'
    and: '                for kwargs, result_callback in self._call_history:'
    and: '                    res = self._hookexec(self.name, [method], kwargs, False)'
    and: '                    if res and result_callback is not None:'
    and: "                        # XXX: remember firstresult isn't compat with historic"
    and: '                        assert isinstance(res, list)'
    and: '                        result_callback(res[0])'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: '    _HookCaller = HookCaller'
    and: '    '
    and: '    '
    and: '    class _SubsetHookCaller(HookCaller):'
    and: '        """A proxy to another HookCaller which manages calls to all registered'
    and: '        plugins except the ones from remove_plugins."""'
    and: '    '
    and: '        # This class is unusual: in inhertits from `HookCaller` so all of'
    and: '        # the *code* runs in the class, but it delegates all underlying *data*'
    and: '        # to the original HookCaller.'
    and: '        # `subset_hook_caller` used to be implemented by creating a full-fledged'
    and: '        # HookCaller, copying all hookimpls from the original. This had problems'
    and: '        # with memory leaks (#346) and historic calls (#347), which make a proxy'
    and: '        # approach better.'
    and: '        # An alternative implementation is to use a `_getattr__`/`__getattribute__`'
    and: '        # proxy, however that adds more overhead and is more tricky to implement.'
    and: '    '
    and: '        __slots__ = ('
    and: '            "_orig",'
    and: '            "_remove_plugins",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:'
    and: '            self._orig = orig'
    and: '            self._remove_plugins = remove_plugins'
    and: '            self.name = orig.name  # type: ignore[misc]'
    and: '            self._hookexec = orig._hookexec  # type: ignore[misc]'
    and: '    '
    and: '        @property  # type: ignore[misc]'
    and: '        def _hookimpls(self) -> list[HookImpl]:'
    and: '            return ['
    and: '                impl'
    and: '                for impl in self._orig._hookimpls'
    and: '                if impl.plugin not in self._remove_plugins'
    and: '            ]'
    and: '    '
    and: '        @property'
    and: '        def spec(self) -> HookSpec | None:  # type: ignore[override]'
    and: '            return self._orig.spec'
    and: '    '
    and: '        @property'
    and: '        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]'
    and: '            return self._orig._call_history'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<_SubsetHookCaller {self.name!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookImpl:'
    and: '        """A hook implementation in a :class:`HookCaller`."""'
    and: '    '
    and: '        __slots__ = ('
    and: '            "function",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "plugin",'
    and: '            "opts",'
    and: '            "plugin_name",'
    and: '            "wrapper",'
    and: '            "hookwrapper",'
    and: '            "optionalhook",'
    and: '            "tryfirst",'
    and: '            "trylast",'
    and: '        )'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            plugin: _Plugin,'
    and: '            plugin_name: str,'
    and: '            function: _HookImplFunction[object],'
    and: '            hook_impl_opts: HookimplOpts,'
    and: '        ) -> None:'
    and: '            """:meta private:"""'
    and: '            #: The hook implementation function.'
    and: '            self.function: Final = function'
    and: '            argnames, kwargnames = varnames(self.function)'
    and: '            #: The positional parameter names of ``function```.'
    and: '            self.argnames: Final = argnames'
    and: '            #: The keyword parameter names of ``function```.'
    and: '            self.kwargnames: Final = kwargnames'
    and: '            #: The plugin which defined this hook implementation.'
    and: '            self.plugin: Final = plugin'
    and: '            #: The :class:`HookimplOpts` used to configure this hook implementation.'
    and: '            self.opts: Final = hook_impl_opts'
    and: '            #: The name of the plugin which defined this hook implementation.'
    and: '            self.plugin_name: Final = plugin_name'
    and: '            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.'
    and: '            self.wrapper: Final = hook_impl_opts["wrapper"]'
    and: '            #: Whether the hook implementation is an :ref:`old-style wrapper'
    and: '            #: <old_style_hookwrappers>`.'
    and: '            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]'
    and: '            #: Whether validation against a hook specification is :ref:`optional'
    and: '            #: <optionalhook>`.'
    and: '            self.optionalhook: Final = hook_impl_opts["optionalhook"]'
    and: '            #: Whether to try to order this hook implementation :ref:`first'
    and: '            #: <callorder>`.'
    and: '            self.tryfirst: Final = hook_impl_opts["tryfirst"]'
    and: '            #: Whether to try to order this hook implementation :ref:`last'
    and: '            #: <callorder>`.'
    and: '            self.trylast: Final = hook_impl_opts["trylast"]'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    class HookSpec:'
    and: '        __slots__ = ('
    and: '            "namespace",'
    and: '            "function",'
    and: '            "name",'
    and: '            "argnames",'
    and: '            "kwargnames",'
    and: '            "opts",'
    and: '            "warn_on_impl",'
    and: '        )'
    and: '    '
    and: '        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:'
    and: '            self.namespace = namespace'
    and: '            self.function: Callable[..., object] = getattr(namespace, name)'
    and: '            self.name = name'
    and: '            self.argnames, self.kwargnames = varnames(self.function)'
    and: '            self.opts = opts'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <_pytest.config.PytestPluginManager object at 0x6c3b1099>'
    and: "hook_name = 'pytest_runtest_call'"
    and: "methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '        def _hookexec('
    and: '            self,'
    and: '            hook_name: str,'
    and: '            methods: Sequence[HookImpl],'
    and: '            kwargs: Mapping[str, object],'
    and: '            firstresult: bool,'
    and: '        ) -> object | list[object]:'
    and: '            # called from all hookcaller instances.'
    and: '            # enable_tracing will set its own wrapping function at self._inner_hookexec'
    and: '>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)'
    and: '    '
    and: '        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:'
    and: '            """Register a plugin and return its name.'
    and: '    '
    and: '            :param name:'
    and: '                The name under which to register the plugin. If not specified, a'
    and: '                name is generated using :func:`get_canonical_name`.'
    and: '    '
    and: '            :returns:'
    and: '                The plugin name. If the name is blocked from registering, returns'
    and: '                ``None``.'
    and: '    '
    and: '            If the plugin is already registered, raises a :exc:`ValueError`.'
    and: '            """'
    and: '            plugin_name = name or self.get_canonical_name(plugin)'
    and: '    '
    and: '            if plugin_name in self._name2plugin:'
    and: '                if self._name2plugin.get(plugin_name, -1) is None:'
    and: '                    return None  # blocked plugin, return None to indicate no registration'
    and: '                raise ValueError('
    and: '                    "Plugin name already registered: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            if plugin in self._name2plugin.values():'
    and: '                raise ValueError('
    and: '                    "Plugin already registered under a different name: %s=%s\\n%s"'
    and: '                    % (plugin_name, plugin, self._name2plugin)'
    and: '                )'
    and: '    '
    and: '            # XXX if an error happens we should make sure no state has been'
    and: '            # changed at point of return'
    and: '            self._name2plugin[plugin_name] = plugin'
    and: '    '
    and: '            # register matching hook implementations of the plugin'
    and: '            for name in dir(plugin):'
    and: '                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)'
    and: '                if hookimpl_opts is not None:'
    and: '                    normalize_hookimpl_opts(hookimpl_opts)'
    and: '                    method: _HookImplFunction[object] = getattr(plugin, name)'
    and: '                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)'
    and: '                    name = hookimpl_opts.get("specname") or name'
    and: '                    hook: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hook is None:'
    and: '                        hook = HookCaller(name, self._hookexec)'
    and: '                        setattr(self.hook, name, hook)'
    and: '                    elif hook.has_spec():'
    and: '                        self._verify_hook(hook, hookimpl)'
    and: '                        hook._maybe_apply_history(hookimpl)'
    and: '                    hook._add_hookimpl(hookimpl)'
    and: '            return plugin_name'
    and: '    '
    and: '        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:'
    and: '            """Try to obtain a hook implementation from an item with the given name'
    and: '            in the given plugin which is being searched for hook impls.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookimpl options, or None to skip the given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook implementation are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookimplMarker`.'
    and: '            """'
    and: '            method: object = getattr(plugin, name)'
    and: '            if not inspect.isroutine(method):'
    and: '                return None'
    and: '            try:'
    and: '                res: HookimplOpts | None = getattr('
    and: '                    method, self.project_name + "_impl", None'
    and: '                )'
    and: '            except Exception:'
    and: '                res = {}  # type: ignore[assignment]'
    and: '            if res is not None and not isinstance(res, dict):'
    and: '                # false positive'
    and: '                res = None  # type:ignore[unreachable]'
    and: '            return res'
    and: '    '
    and: '        def unregister('
    and: '            self, plugin: _Plugin | None = None, name: str | None = None'
    and: '        ) -> Any | None:'
    and: '            """Unregister a plugin and all of its hook implementations.'
    and: '    '
    and: '            The plugin can be specified either by the plugin object or the plugin'
    and: '            name. If both are specified, they must agree.'
    and: '    '
    and: '            Returns the unregistered plugin, or ``None`` if not found.'
    and: '            """'
    and: '            if name is None:'
    and: '                assert plugin is not None, "one of name or plugin needs to be specified"'
    and: '                name = self.get_name(plugin)'
    and: '                assert name is not None, "plugin is not registered"'
    and: '    '
    and: '            if plugin is None:'
    and: '                plugin = self.get_plugin(name)'
    and: '                if plugin is None:'
    and: '                    return None'
    and: '    '
    and: '            hookcallers = self.get_hookcallers(plugin)'
    and: '            if hookcallers:'
    and: '                for hookcaller in hookcallers:'
    and: '                    hookcaller._remove_plugin(plugin)'
    and: '    '
    and: '            # if self._name2plugin[name] == None registration was blocked: ignore'
    and: '            if self._name2plugin.get(name):'
    and: '                assert name is not None'
    and: '                del self._name2plugin[name]'
    and: '    '
    and: '            return plugin'
    and: '    '
    and: '        def set_blocked(self, name: str) -> None:'
    and: '            """Block registrations of the given name, unregister if already registered."""'
    and: '            self.unregister(name=name)'
    and: '            self._name2plugin[name] = None'
    and: '    '
    and: '        def is_blocked(self, name: str) -> bool:'
    and: '            """Return whether the given plugin name is blocked."""'
    and: '            return name in self._name2plugin and self._name2plugin[name] is None'
    and: '    '
    and: '        def add_hookspecs(self, module_or_class: _Namespace) -> None:'
    and: '            """Add new hook specifications defined in the given ``module_or_class``.'
    and: '    '
    and: '            Functions are recognized as hook specifications if they have been'
    and: '            decorated with a matching :class:`HookspecMarker`.'
    and: '            """'
    and: '            names = []'
    and: '            for name in dir(module_or_class):'
    and: '                spec_opts = self.parse_hookspec_opts(module_or_class, name)'
    and: '                if spec_opts is not None:'
    and: '                    hc: HookCaller | None = getattr(self.hook, name, None)'
    and: '                    if hc is None:'
    and: '                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)'
    and: '                        setattr(self.hook, name, hc)'
    and: '                    else:'
    and: '                        # Plugins registered this hook without knowing the spec.'
    and: '                        hc.set_specification(module_or_class, spec_opts)'
    and: '                        for hookfunction in hc.get_hookimpls():'
    and: '                            self._verify_hook(hc, hookfunction)'
    and: '                    names.append(name)'
    and: '    '
    and: '            if not names:'
    and: '                raise ValueError('
    and: '                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"'
    and: '                )'
    and: '    '
    and: '        def parse_hookspec_opts('
    and: '            self, module_or_class: _Namespace, name: str'
    and: '        ) -> HookspecOpts | None:'
    and: '            """Try to obtain a hook specification from an item with the given name'
    and: '            in the given module or class which is being searched for hook specs.'
    and: '    '
    and: '            :returns:'
    and: '                The parsed hookspec options for defining a hook, or None to skip the'
    and: '                given item.'
    and: '    '
    and: '            This method can be overridden by ``PluginManager`` subclasses to'
    and: '            customize how hook specifications are picked up. By default, returns the'
    and: '            options for items decorated with :class:`HookspecMarker`.'
    and: '            """'
    and: '            method = getattr(module_or_class, name)'
    and: '            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)'
    and: '            return opts'
    and: '    '
    and: '        def get_plugins(self) -> set[Any]:'
    and: '            """Return a set of all registered plugin objects."""'
    and: '            return set(self._name2plugin.values())'
    and: '    '
    and: '        def is_registered(self, plugin: _Plugin) -> bool:'
    and: '            """Return whether the plugin is already registered."""'
    and: '            return any(plugin == val for val in self._name2plugin.values())'
    and: '    '
    and: '        def get_canonical_name(self, plugin: _Plugin) -> str:'
    and: '            """Return a canonical name for a plugin object.'
    and: '    '
    and: '            Note that a plugin may be registered under a different name'
    and: '            specified by the caller of :meth:`register(plugin, name) <register>`.'
    and: '            To obtain the name of a registered plugin use :meth:`get_name(plugin)'
    and: '            <get_name>` instead.'
    and: '            """'
    and: '            name: str | None = getattr(plugin, "__name__", None)'
    and: '            return name or str(id(plugin))'
    and: '    '
    and: '        def get_plugin(self, name: str) -> Any | None:'
    and: '            """Return the plugin registered under the given name, if any."""'
    and: '            return self._name2plugin.get(name)'
    and: '    '
    and: '        def has_plugin(self, name: str) -> bool:'
    and: '            """Return whether a plugin with the given name is registered."""'
    and: '            return self.get_plugin(name) is not None'
    and: '    '
    and: '        def get_name(self, plugin: _Plugin) -> str | None:'
    and: '            """Return the name the plugin is registered under, or ``None`` if'
    and: '            is isn\'t."""'
    and: '            for name, val in self._name2plugin.items():'
    and: '                if plugin == val:'
    and: '                    return name'
    and: '            return None'
    and: '    '
    and: '        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:'
    and: '            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r\\nhook %r\\nhistoric incompatible with yield/wrapper/hookwrapper"'
    and: '                    % (hookimpl.plugin_name, hook.name),'
    and: '                )'
    and: '    '
    and: '            assert hook.spec is not None'
    and: '            if hook.spec.warn_on_impl:'
    and: '                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)'
    and: '    '
    and: '            # positional arg checking'
    and: '            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)'
    and: '            if notinspec:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Argument(s) %s are declared in the hookimpl but "'
    and: '                    "can not be found in the hookspec"'
    and: '                    % ('
    and: '                        hookimpl.plugin_name,'
    and: '                        hook.name,'
    and: '                        _formatdef(hookimpl.function),'
    and: '                        notinspec,'
    and: '                    ),'
    and: '                )'
    and: '    '
    and: '            if ('
    and: '                hookimpl.wrapper or hookimpl.hookwrapper'
    and: '            ) and not inspect.isgeneratorfunction(hookimpl.function):'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "Declared as wrapper=True or hookwrapper=True "'
    and: '                    "but function is not a generator function"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '            if hookimpl.wrapper and hookimpl.hookwrapper:'
    and: '                raise PluginValidationError('
    and: '                    hookimpl.plugin,'
    and: '                    "Plugin %r for hook %r\\nhookimpl definition: %s\\n"'
    and: '                    "The wrapper=True and hookwrapper=True options are mutually exclusive"'
    and: '                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),'
    and: '                )'
    and: '    '
    and: '        def check_pending(self) -> None:'
    and: '            """Verify that all hooks which have not been verified against a'
    and: '            hook specification are optional, otherwise raise'
    and: '            :exc:`PluginValidationError`."""'
    and: '            for name in self.hook.__dict__:'
    and: '                if name[0] != "_":'
    and: '                    hook: HookCaller = getattr(self.hook, name)'
    and: '                    if not hook.has_spec():'
    and: '                        for hookimpl in hook.get_hookimpls():'
    and: '                            if not hookimpl.optionalhook:'
    and: '                                raise PluginValidationError('
    and: '                                    hookimpl.plugin,'
    and: '                                    "unknown hook %r in plugin %r"'
    and: '                                    % (name, hookimpl.plugin),'
    and: '                                )'
    and: '    '
    and: '        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:'
    and: '            """Load modules from querying the specified setuptools ``group``.'
    and: '    '
    and: '            :param group:'
    and: '                Entry point group to load plugins.'
    and: '            :param name:'
    and: '                If given, loads only plugins with the given ``name``.'
    and: '    '
    and: '            :return:'
    and: '                The number of plugins loaded by this call.'
    and: '            """'
    and: '            count = 0'
    and: '            for dist in list(importlib.metadata.distributions()):'
    and: '                for ep in dist.entry_points:'
    and: '                    if ('
    and: '                        ep.group != group'
    and: '                        or (name is not None and ep.name != name)'
    and: '                        # already registered'
    and: '                        or self.get_plugin(ep.name)'
    and: '                        or self.is_blocked(ep.name)'
    and: '                    ):'
    and: '                        continue'
    and: '                    plugin = ep.load()'
    and: '                    self.register(plugin, name=ep.name)'
    and: '                    self._plugin_distinfo.append((plugin, DistFacade(dist)))'
    and: '                    count += 1'
    and: '            return count'
    and: '    '
    and: '        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:'
    and: '            """Return a list of (plugin, distinfo) pairs for all'
    and: '            setuptools-registered plugins."""'
    and: '            return list(self._plugin_distinfo)'
    and: '    '
    and: '        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:'
    and: '            """Return a list of (name, plugin) pairs for all registered plugins."""'
    and: '            return list(self._name2plugin.items())'
    and: '    '
    and: '        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:'
    and: '            """Get all hook callers for the specified plugin.'
    and: '    '
    and: '            :returns:'
    and: '                The hook callers, or ``None`` if ``plugin`` is not registered in'
    and: '                this plugin manager.'
    and: '            """'
    and: '            if self.get_name(plugin) is None:'
    and: '                return None'
    and: '            hookcallers = []'
    and: '            for hookcaller in self.hook.__dict__.values():'
    and: '                for hookimpl in hookcaller.get_hookimpls():'
    and: '                    if hookimpl.plugin is plugin:'
    and: '                        hookcallers.append(hookcaller)'
    and: '            return hookcallers'
    and: '    '
    and: '        def add_hookcall_monitoring('
    and: '            self, before: _BeforeTrace, after: _AfterTrace'
    and: '        ) -> Callable[[], None]:'
    and: '            """Add before/after tracing functions for all hooks.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracers.'
    and: '    '
    and: '            ``before(hook_name, hook_impls, kwargs)`` will be called ahead'
    and: '            of all hook calls and receive a hookcaller instance, a list'
    and: '            of HookImpl instances and the keyword arguments for the hook call.'
    and: '    '
    and: '            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the'
    and: '            same arguments as ``before`` but also a :class:`~pluggy.Result` object'
    and: '            which represents the result of the overall hook call.'
    and: '            """'
    and: '            oldcall = self._inner_hookexec'
    and: '    '
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '            def traced_hookexec('
    and: '                hook_name: str,'
    and: '                hook_impls: Sequence[HookImpl],'
    and: '                caller_kwargs: Mapping[str, object],'
    and: '                firstresult: bool,'
    and: '            ) -> object | list[object]:'
    and: '                before(hook_name, hook_impls, caller_kwargs)'
    and: '                outcome = Result.from_call('
    and: '                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '>               return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x5b147d8e>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "cls = <class 'pluggy._result.Result'>"
    and: 'func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x5384606b>'
    and: ''
    and: '        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:'
    and: '            """:meta private:"""'
    and: '            __tracebackhide__ = True'
    and: '            result = exception = None'
    and: '            try:'
    and: '>               result = func()'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '            return cls(result, exception)'
    and: '    '
    and: '        def force_result(self, result: ResultType) -> None:'
    and: '            """Force the result(s) to ``result``.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` a single value should'
    and: '            be set, otherwise set a (modified) list of results. Any exceptions'
    and: '            found during invocation will be deleted.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '            """'
    and: '            self._result = result'
    and: '            self._exception = None'
    and: '    '
    and: '        def force_exception(self, exception: BaseException) -> None:'
    and: '            """Force the result to fail with ``exception``.'
    and: '    '
    and: '            This overrides any previous result or exception.'
    and: '    '
    and: '            .. versionadded:: 1.1.0'
    and: '            """'
    and: '            self._result = None'
    and: '            self._exception = exception'
    and: '    '
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '                raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: '>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)'
    and: '                )'
    and: '                after(outcome, hook_name, hook_impls, caller_kwargs)'
    and: '                return outcome.get_result()'
    and: '    '
    and: '            self._inner_hookexec = traced_hookexec'
    and: '    '
    and: '            def undo() -> None:'
    and: '                self._inner_hookexec = oldcall'
    and: '    '
    and: '            return undo'
    and: '    '
    and: '        def enable_tracing(self) -> Callable[[], None]:'
    and: '            """Enable tracing of hook calls.'
    and: '    '
    and: '            Returns an undo function which, when called, removes the added tracing.'
    and: '            """'
    and: '            hooktrace = self.trace.root.get("hook")'
    and: '    '
    and: '            def before('
    and: '                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]'
    and: '            ) -> None:'
    and: '                hooktrace.root.indent += 1'
    and: '                hooktrace(hook_name, kwargs)'
    and: '    '
    and: '            def after('
    and: '                outcome: Result[object],'
    and: '                hook_name: str,'
    and: '                methods: Sequence[HookImpl],'
    and: '                kwargs: Mapping[str, object],'
    and: '            ) -> None:'
    and: '                if outcome.exception is None:'
    and: '                    hooktrace("finish", hook_name, "-->", outcome.get_result())'
    and: '                hooktrace.root.indent -= 1'
    and: '    '
    and: '            return self.add_hookcall_monitoring(before, after)'
    and: '    '
    and: '        def subset_hook_caller('
    and: '            self, name: str, remove_plugins: Iterable[_Plugin]'
    and: '        ) -> HookCaller:'
    and: '            """Return a proxy :class:`~pluggy.HookCaller` instance for the named'
    and: '            method which manages calls to all registered plugins except the ones'
    and: '            from remove_plugins."""'
    and: '            orig: HookCaller = getattr(self.hook, name)'
    and: '            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}'
    and: '            if plugins_to_remove:'
    and: '                return _SubsetHookCaller(orig, plugins_to_remove)'
    and: '            return orig'
    and: '    '
    and: '    '
    and: '    def _formatdef(func: Callable[..., object]) -> str:'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '>   ???'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <pluggy._result.Result object at 0x6fadffc0>'
    and: ''
    and: '        def get_result(self) -> ResultType:'
    and: '            """Get the result(s) for this hook call.'
    and: '    '
    and: '            If the hook was marked as a ``firstresult`` only a single value'
    and: '            will be returned, otherwise a list of results.'
    and: '            """'
    and: '            __tracebackhide__ = True'
    and: '            exc = self._exception'
    and: '            if exc is None:'
    and: '                return cast(ResultType, self._result)'
    and: '            else:'
    and: '>               raise exc.with_traceback(exc.__traceback__)'
    and: '    '
    and: '    '
    and: '    # Historical name (pluggy<=1.2), kept for backward compatibility.'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "hook_name = 'pytest_runtest_call'"
    and: "hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]"
    and: "caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False"
    and: ''
    and: '    def _multicall('
    and: '        hook_name: str,'
    and: '        hook_impls: Sequence[HookImpl],'
    and: '        caller_kwargs: Mapping[str, object],'
    and: '        firstresult: bool,'
    and: '    ) -> object | list[object]:'
    and: '        """Execute a call into multiple python functions/methods and return the'
    and: '        result(s).'
    and: '    '
    and: '        ``caller_kwargs`` comes from HookCaller.__call__().'
    and: '        """'
    and: '        __tracebackhide__ = True'
    and: '        results: list[object] = []'
    and: '        exception = None'
    and: '        only_new_style_wrappers = True'
    and: '        try:  # run impl and wrapper setup functions in a loop'
    and: '            teardowns: list[Teardown] = []'
    and: '            try:'
    and: '                for hook_impl in reversed(hook_impls):'
    and: '                    try:'
    and: '                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]'
    and: '                    except KeyError:'
    and: '                        for argname in hook_impl.argnames:'
    and: '                            if argname not in caller_kwargs:'
    and: '                                raise HookCallError('
    and: '                                    f"hook call must provide argument {argname!r}"'
    and: '                                )'
    and: '    '
    and: '                    if hook_impl.hookwrapper:'
    and: '                        only_new_style_wrappers = False'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            wrapper_gen = cast(Generator[None, Result[object], None], res)'
    and: '                            next(wrapper_gen)  # first yield'
    and: '                            teardowns.append((wrapper_gen,))'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(wrapper_gen, "did not yield")'
    and: '                    elif hook_impl.wrapper:'
    and: '                        try:'
    and: '                            # If this cast is not valid, a type error is raised below,'
    and: '                            # which is the desired response.'
    and: '                            res = hook_impl.function(*args)'
    and: '                            function_gen = cast(Generator[None, object, object], res)'
    and: '                            next(function_gen)  # first yield'
    and: '                            teardowns.append(function_gen)'
    and: '                        except StopIteration:'
    and: '                            _raise_wrapfail(function_gen, "did not yield")'
    and: '                    else:'
    and: '>                       res = hook_impl.function(*args)'
    and: '                        if res is not None:'
    and: '                            results.append(res)'
    and: '                            if firstresult:  # halt further impl calls'
    and: '                                break'
    and: '            except BaseException as exc:'
    and: '                exception = exc'
    and: '        finally:'
    and: '            # Fast path - only new-style wrappers, no Result.'
    and: '            if only_new_style_wrappers:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    result = results[0] if results else None'
    and: '                else:'
    and: '                    result = results'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    try:'
    and: '                        if exception is not None:'
    and: '                            teardown.throw(exception)  # type: ignore[union-attr]'
    and: '                        else:'
    and: '                            teardown.send(result)  # type: ignore[union-attr]'
    and: '                        # Following is unreachable for a well behaved hook wrapper.'
    and: '                        # Try to force finalizers otherwise postponed till GC action.'
    and: '                        # Note: close() may raise if generator handles GeneratorExit.'
    and: '                        teardown.close()  # type: ignore[union-attr]'
    and: '                    except StopIteration as si:'
    and: '                        result = si.value'
    and: '                        exception = None'
    and: '                        continue'
    and: '                    except BaseException as e:'
    and: '                        exception = e'
    and: '                        continue'
    and: '                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]'
    and: '    '
    and: '                if exception is not None:'
    and: '                    raise exception.with_traceback(exception.__traceback__)'
    and: '                else:'
    and: '                    return result'
    and: '    '
    and: '            # Slow path - need to support old-style wrappers.'
    and: '            else:'
    and: '                if firstresult:  # first result hooks return a single value'
    and: '                    outcome: Result[object | list[object]] = Result('
    and: '                        results[0] if results else None, exception'
    and: '                    )'
    and: '                else:'
    and: '                    outcome = Result(results, exception)'
    and: '    '
    and: '                # run all wrapper post-yield blocks'
    and: '                for teardown in reversed(teardowns):'
    and: '                    if isinstance(teardown, tuple):'
    and: '                        try:'
    and: '                            teardown[0].send(outcome)'
    and: '                            _raise_wrapfail(teardown[0], "has second yield")'
    and: '                        except StopIteration:'
    and: '                            pass'
    and: '                    else:'
    and: '                        try:'
    and: '                            if outcome._exception is not None:'
    and: '                                teardown.throw(outcome._exception)'
    and: '                            else:'
    and: '                                teardown.send(outcome._result)'
    and: '                            # Following is unreachable for a well behaved hook wrapper.'
    and: '                            # Try to force finalizers otherwise postponed till GC action.'
    and: '                            # Note: close() may raise if generator handles GeneratorExit.'
    and: '                            teardown.close()'
    and: '                        except StopIteration as si:'
    and: '                            outcome.force_result(si.value)'
    and: '                            continue'
    and: '                        except BaseException as e:'
    and: '                            outcome.force_exception(e)'
    and: '                            continue'
    and: '                        _raise_wrapfail(teardown, "has second yield")'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '            item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '>           raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'item = <Flake8Item flake-8>'
    and: ''
    and: '    def pytest_runtest_call(item: Item) -> None:'
    and: '        _update_current_test_var(item, "call")'
    and: '        try:'
    and: '            del sys.last_type'
    and: '            del sys.last_value'
    and: '            del sys.last_traceback'
    and: '        except AttributeError:'
    and: '            pass'
    and: '        try:'
    and: '>           item.runtest()'
    and: '        except Exception as e:'
    and: '            # Store trace info to allow postmortem debugging'
    and: '            sys.last_type = type(e)'
    and: '            sys.last_value = e'
    and: '            assert e.__traceback__ is not None'
    and: '            # Skip *this* frame'
    and: '            sys.last_traceback = e.__traceback__.tb_next'
    and: '            raise e'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:'
    and: '        _update_current_test_var(item, "teardown")'
    and: '        item.session._setupstate.teardown_exact(nextitem)'
    and: '        _update_current_test_var(item, None)'
    and: '    '
    and: '    '
    and: '    def _update_current_test_var('
    and: '        item: Item, when: Optional["Literal[\'setup\', \'call\', \'teardown\']"]'
    and: '    ) -> None:'
    and: '        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.'
    and: '    '
    and: '        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.'
    and: '        """'
    and: '        var_name = "PYTEST_CURRENT_TEST"'
    and: '        if when:'
    and: '            value = f"{item.nodeid} ({when})"'
    and: "            # don't allow null bytes on environment variables (see #2644, #2957)"
    and: '            value = value.replace("\\x00", "(null)")'
    and: '            os.environ[var_name] = value'
    and: '        else:'
    and: '            os.environ.pop(var_name)'
    and: '    '
    and: '    '
    and: '    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:'
    and: '        if report.when in ("setup", "teardown"):'
    and: '            if report.failed:'
    and: '                #      category, shortletter, verbose-word'
    and: '                return "error", "E", "ERROR"'
    and: '            elif report.skipped:'
    and: '                return "skipped", "s", "SKIPPED"'
    and: '            else:'
    and: '                return "", "", ""'
    and: '        return None'
    and: '    '
    and: '    '
    and: '    #'
    and: '    # Implementation'
    and: '    '
    and: '    '
    and: '    def call_and_report('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", log: bool = True, **kwds'
    and: '    ) -> TestReport:'
    and: '        call = call_runtest_hook(item, when, **kwds)'
    and: '        hook = item.ihook'
    and: '        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)'
    and: '        if log:'
    and: '            hook.pytest_runtest_logreport(report=report)'
    and: '        if check_interactive_exception(call, report):'
    and: '            hook.pytest_exception_interact(node=item, call=call, report=report)'
    and: '        return report'
    and: '    '
    and: '    '
    and: '    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:'
    and: '        """Check whether the call raised an exception that should be reported as'
    and: '        interactive."""'
    and: '        if call.excinfo is None:'
    and: "            # Didn't raise."
    and: '            return False'
    and: '        if hasattr(report, "wasxfail"):'
    and: '            # Exception was expected.'
    and: '            return False'
    and: '        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):'
    and: '            # Special control flow exception.'
    and: '            return False'
    and: '        return True'
    and: '    '
    and: '    '
    and: '    def call_runtest_hook('
    and: '        item: Item, when: "Literal[\'setup\', \'call\', \'teardown\']", **kwds'
    and: '    ) -> "CallInfo[None]":'
    and: '        if when == "setup":'
    and: '            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup'
    and: '        elif when == "call":'
    and: '            ihook = item.ihook.pytest_runtest_call'
    and: '        elif when == "teardown":'
    and: '            ihook = item.ihook.pytest_runtest_teardown'
    and: '        else:'
    and: '            assert False, f"Unhandled runtest hook case: {when}"'
    and: '        reraise: Tuple[Type[BaseException], ...] = (Exit,)'
    and: '        if not item.config.getoption("usepdb", False):'
    and: '            reraise += (KeyboardInterrupt,)'
    and: '        return CallInfo.from_call('
    and: '            lambda: ihook(item=item, **kwds), when=when, reraise=reraise'
    and: '        )'
    and: '    '
    and: '    '
    and: '    TResult = TypeVar("TResult", covariant=True)'
    and: '    '
    and: '    '
    and: '    @final'
    and: '    @dataclasses.dataclass'
    and: '    class CallInfo(Generic[TResult]):'
    and: '        """Result/Exception info of a function invocation."""'
    and: '    '
    and: '        _result: Optional[TResult]'
    and: '        #: The captured exception of the call, if it raised.'
    and: '        excinfo: Optional[ExceptionInfo[BaseException]]'
    and: '        #: The system time when the call started, in seconds since the epoch.'
    and: '        start: float'
    and: '        #: The system time when the call ended, in seconds since the epoch.'
    and: '        stop: float'
    and: '        #: The call duration, in seconds.'
    and: '        duration: float'
    and: '        #: The context of invocation: "collect", "setup", "call" or "teardown".'
    and: '        when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']"'
    and: '    '
    and: '        def __init__('
    and: '            self,'
    and: '            result: Optional[TResult],'
    and: '            excinfo: Optional[ExceptionInfo[BaseException]],'
    and: '            start: float,'
    and: '            stop: float,'
    and: '            duration: float,'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            *,'
    and: '            _ispytest: bool = False,'
    and: '        ) -> None:'
    and: '            check_ispytest(_ispytest)'
    and: '            self._result = result'
    and: '            self.excinfo = excinfo'
    and: '            self.start = start'
    and: '            self.stop = stop'
    and: '            self.duration = duration'
    and: '            self.when = when'
    and: '    '
    and: '        @property'
    and: '        def result(self) -> TResult:'
    and: '            """The return value of the call, if it didn\'t raise.'
    and: '    '
    and: '            Can only be accessed if excinfo is None.'
    and: '            """'
    and: '            if self.excinfo is not None:'
    and: '                raise AttributeError(f"{self!r} has no valid result")'
    and: "            # The cast is safe because an exception wasn't raised, hence"
    and: '            # _result has the expected function return type (which may be'
    and: "            #  None, that's why a cast and not an assert)."
    and: '            return cast(TResult, self._result)'
    and: '    '
    and: '        @classmethod'
    and: '        def from_call('
    and: '            cls,'
    and: '            func: "Callable[[], TResult]",'
    and: '            when: "Literal[\'collect\', \'setup\', \'call\', \'teardown\']",'
    and: '            reraise: Optional['
    and: '                Union[Type[BaseException], Tuple[Type[BaseException], ...]]'
    and: '            ] = None,'
    and: '        ) -> "CallInfo[TResult]":'
    and: '            """Call func, wrapping the result in a CallInfo.'
    and: '    '
    and: '            :param func:'
    and: '                The function to call. Called without arguments.'
    and: '            :param when:'
    and: '                The phase in which the function is called.'
    and: '            :param reraise:'
    and: '                Exception or exceptions that shall propagate if raised by the'
    and: '                function, instead of being wrapped in the CallInfo.'
    and: '            """'
    and: '            excinfo = None'
    and: '            start = timing.time()'
    and: '            precise_start = timing.perf_counter()'
    and: '            try:'
    and: '                result: Optional[TResult] = func()'
    and: '            except BaseException:'
    and: '                excinfo = ExceptionInfo.from_current()'
    and: '                if reraise is not None and isinstance(excinfo.value, reraise):'
    and: '                    raise'
    and: '                result = None'
    and: '            # use the perf counter'
    and: '            precise_stop = timing.perf_counter()'
    and: '            duration = precise_stop - precise_start'
    and: '            stop = timing.time()'
    and: '            return cls('
    and: '                start=start,'
    and: '                stop=stop,'
    and: '                duration=duration,'
    and: '                when=when,'
    and: '                result=result,'
    and: '                excinfo=excinfo,'
    and: '                _ispytest=True,'
    and: '            )'
    and: '    '
    and: '        def __repr__(self) -> str:'
    and: '            if self.excinfo is None:'
    and: '                return f"<CallInfo when={self.when!r} result: {self._result!r}>"'
    and: '            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"'
    and: '    '
    and: '    '
    and: '    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:'
    and: '        return TestReport.from_item_and_call(item, call)'
    and: '    '
    and: '    '
    and: '    def pytest_make_collect_report(collector: Collector) -> CollectReport:'
    and: '        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")'
    and: '        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None'
    and: '        if not call.excinfo:'
    and: '            outcome: Literal["passed", "skipped", "failed"] = "passed"'
    and: '        else:'
    and: '            skip_exceptions = [Skipped]'
    and: '            unittest = sys.modules.get("unittest")'
    and: '            if unittest is not None:'
    and: '                # Type ignored because unittest is loaded dynamically.'
    and: '                skip_exceptions.append(unittest.SkipTest)  # type: ignore'
    and: '            if isinstance(call.excinfo.value, tuple(skip_exceptions)):'
    and: '                outcome = "skipped"'
    and: '                r_ = collector._repr_failure_py(call.excinfo, "line")'
    and: '                assert isinstance(r_, ExceptionChainRepr), repr(r_)'
    and: '                r = r_.reprcrash'
    and: '                assert r'
    and: '                longrepr = (str(r.path), r.lineno, r.message)'
    and: '            else:'
    and: '                outcome = "failed"'
    and: '                errorinfo = collector.repr_failure(call.excinfo)'
    and: '                if not hasattr(errorinfo, "toterminal"):'
    and: '                    assert isinstance(errorinfo, str)'
    and: '                    errorinfo = CollectErrorRepr(errorinfo)'
    and: '                longrepr = errorinfo'
    and: '        result = call.result if not call.excinfo else None'
    and: '        rep = CollectReport(collector.nodeid, outcome, longrepr, result)'
    and: '        rep.call = call  # type: ignore # see collect_one_node'
    and: '        return rep'
    and: '    '
    and: '    '
    and: '    class SetupState:'
    and: '        """Shared state for setting up/tearing down test items or collectors'
    and: '        in a session.'
    and: '    '
    and: '        Suppose we have a collection tree as follows:'
    and: '    '
    and: '        <Session session>'
    and: '            <Module mod1>'
    and: '                <Function item1>'
    and: '            <Module mod2>'
    and: '                <Function item2>'
    and: '    '
    and: '        The SetupState maintains a stack. The stack starts out empty:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        During the setup phase of item1, setup(item1) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push session to stack, run session.setup()'
    and: '            push mod1 to stack, run mod1.setup()'
    and: '            push item1 to stack, run item1.setup()'
    and: '    '
    and: '        The stack is:'
    and: '    '
    and: '            [session, mod1, item1]'
    and: '    '
    and: '        While the stack is in this shape, it is allowed to add finalizers to'
    and: '        each of session, mod1, item1 using addfinalizer().'
    and: '    '
    and: '        During the teardown phase of item1, teardown_exact(item2) is called,'
    and: '        where item2 is the next item to item1. What it does is:'
    and: '    '
    and: '            pop item1 from stack, run its teardowns'
    and: '            pop mod1 from stack, run its teardowns'
    and: '    '
    and: '        mod1 was popped because it ended its purpose with item1. The stack is:'
    and: '    '
    and: '            [session]'
    and: '    '
    and: '        During the setup phase of item2, setup(item2) is called. What it does'
    and: '        is:'
    and: '    '
    and: '            push mod2 to stack, run mod2.setup()'
    and: '            push item2 to stack, run item2.setup()'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            [session, mod2, item2]'
    and: '    '
    and: '        During the teardown phase of item2, teardown_exact(None) is called,'
    and: '        because item2 is the last item. What it does is:'
    and: '    '
    and: '            pop item2 from stack, run its teardowns'
    and: '            pop mod2 from stack, run its teardowns'
    and: '            pop session from stack, run its teardowns'
    and: '    '
    and: '        Stack:'
    and: '    '
    and: '            []'
    and: '    '
    and: '        The end!'
    and: '        """'
    and: '    '
    and: '        def __init__(self) -> None:'
    and: '            # The stack is in the dict insertion order.'
    and: '            self.stack: Dict['
    and: '                Node,'
    and: '                Tuple['
    and: "                    # Node's finalizers."
    and: '                    List[Callable[[], object]],'
    and: "                    # Node's exception, if its setup raised."
    and: '                    Optional[Union[OutcomeException, Exception]],'
    and: '                ],'
    and: '            ] = {}'
    and: '    '
    and: '        def setup(self, item: Item) -> None:'
    and: '            """Setup objects along the collector chain to the item."""'
    and: '            needed_collectors = item.listchain()'
    and: '    '
    and: '            # If a collector fails its setup, fail its entire subtree of items.'
    and: '            # The setup is not retried for each item - the same exception is used.'
    and: '            for col, (finalizers, exc) in self.stack.items():'
    and: '                assert col in needed_collectors, "previous item was not torn down properly"'
    and: '                if exc:'
    and: '                    raise exc'
    and: '    '
    and: '            for col in needed_collectors[len(self.stack) :]:'
    and: '                assert col not in self.stack'
    and: '                # Push onto the stack.'
    and: '                self.stack[col] = ([col.teardown], None)'
    and: '                try:'
    and: '                    col.setup()'
    and: '                except TEST_OUTCOME as exc:'
    and: '                    self.stack[col] = (self.stack[col][0], exc)'
    and: '                    raise exc'
    and: '    '
    and: '        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:'
    and: '            """Attach a finalizer to the given node.'
    and: '    '
    and: '            The node must be currently active in the stack.'
    and: '            """'
    and: '            assert node and not isinstance(node, tuple)'
    and: '            assert callable(finalizer)'
    and: '            assert node in self.stack, (node, self.stack)'
    and: '            self.stack[node][0].append(finalizer)'
    and: '    '
    and: '        def teardown_exact(self, nextitem: Optional[Item]) -> None:'
    and: '            """Teardown the current stack up until reaching nodes that nextitem'
    and: '            also descends from.'
    and: '    '
    and: "            When nextitem is None (meaning we're at the last item), the entire"
    and: '            stack is torn down.'
    and: '            """'
    and: '            needed_collectors = nextitem and nextitem.listchain() or []'
    and: '            exceptions: List[BaseException] = []'
    and: '            while self.stack:'
    and: '                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:'
    and: '                    break'
    and: '                node, (finalizers, _) = self.stack.popitem()'
    and: '                these_exceptions = []'
    and: '                while finalizers:'
    and: '                    fin = finalizers.pop()'
    and: '                    try:'
    and: '                        fin()'
    and: '                    except TEST_OUTCOME as e:'
    and: '                        these_exceptions.append(e)'
    and: '    '
    and: '                if len(these_exceptions) == 1:'
    and: '                    exceptions.extend(these_exceptions)'
    and: '                elif these_exceptions:'
    and: '                    msg = f"errors while tearing down {node!r}"'
    and: '                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))'
    and: '    '
    and: '            if len(exceptions) == 1:'
    and: '                raise exceptions[0]'
    and: '            elif exceptions:'
    and: '                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])'
    and: '            if nextitem is None:'
    and: '                assert not self.stack'
    and: '    '
    and: '    '
    and: '    def collect_one_node(collector: Collector) -> CollectReport:'
    and: '        ihook = collector.ihook'
    and: '        ihook.pytest_collectstart(collector=collector)'
    and: '        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)'
    and: '        call = rep.__dict__.pop("call", None)'
    and: '        if call and check_interactive_exception(call, rep):'
    and: '            ihook.pytest_exception_interact(node=collector, call=call, report=rep)'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: 'self = <Flake8Item flake-8>'
    and: ''
    and: '        def runtest(self):'
    and: "            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \\"
    and: "                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \\"
    and: '                 redirect_stdout(to), redirect_stderr(te):'
    and: '>               found_errors = check_file('
    and: '                    self.fspath,'
    and: '                    self.flake8ignore,'
    and: '                    self.maxlength,'
    and: '                    self.maxdoclength,'
    and: '                    self.maxcomplexity,'
    and: '                    self.showsource,'
    and: '                    self.statistics'
    and: '                )'
    and: '                to.flush()'
    and: '                te.flush()'
    and: "                out = bo.getvalue().decode('utf-8')"
    and: "                err = be.getvalue().decode('utf-8')"
    and: '    '
    and: '            if found_errors:'
    and: '                raise Flake8Error(out, err)'
    and: '            # update mtime only if test passed'
    and: '            # otherwise failures would not be re-run next time'
    and: '            if hasattr(self.config, "_flake8mtimes"):'
    and: '                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,'
    and: '                                                               self.flake8ignore)'
    and: '    '
    and: '        def repr_failure(self, excinfo):'
    and: '            if excinfo.errisinstance(Flake8Error):'
    and: '                return excinfo.value.args[0]'
    and: '            return super(Flake8Item, self).repr_failure(excinfo)'
    and: '    '
    and: '        def reportinfo(self):'
    and: '            if self.flake8ignore:'
    and: '                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)'
    and: '            else:'
    and: '                ignores = ""'
    and: '            return (self.fspath, -1, "FLAKE8-check%s" % ignores)'
    and: '    '
    and: '    '
    and: '    class Ignorer:'
    and: '        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\\d\\d\\d")):'
    and: '            self.ignores = ignores = []'
    and: '            for line in ignorelines:'
    and: '                i = line.find("#")'
    and: '                if i != -1:'
    and: '                    line = line[:i]'
    and: '                try:'
    and: '                    glob, ign = line.split(None, 1)'
    and: '                except ValueError:'
    and: '                    glob, ign = None, line'
    and: '                if glob and coderex.match(glob):'
    and: '                    glob, ign = None, line'
    and: '                ign = ign.split()'
    and: '                if "ALL" in ign:'
    and: '                    ign = None'
    and: '                if glob and "/" != os.sep and "/" in glob:'
    and: '                    glob = glob.replace("/", os.sep)'
    and: '                ignores.append((glob, ign))'
    and: '    '
    and: '        def __call__(self, path):'
    and: '            l = []  # noqa: E741'
    and: '            for (glob, ignlist) in self.ignores:'
    and: '                if not glob or path.fnmatch(glob):'
    and: '                    if ignlist is None:'
    and: '                        return None'
    and: '                    l.extend(ignlist)'
    and: '            return l'
    and: '    '
    and: '    '
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '        prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: '
    and: '_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ '
    and: ''
    and: "path = local('/tmp/pytest-of-tester/pytest-5/test_keyword_match0/test_keyword_match.py')"
    and: "flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''"
    and: 'showsource = [], statistics = []'
    and: ''
    and: '    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,'
    and: '                   showsource, statistics):'
    and: '        """Run flake8 over a single file, and return the number of failures."""'
    and: '        args = []'
    and: '        if maxlength:'
    and: "            args += ['--max-line-length', maxlength]"
    and: '        if maxdoclenght:'
    and: "            args += ['--max-doc-length', maxdoclenght]"
    and: '        if maxcomplexity:'
    and: "            args += ['--max-complexity', maxcomplexity]"
    and: '        if showsource:'
    and: "            args += ['--show-source']"
    and: '        if statistics:'
    and: "            args += ['--statistics']"
    and: '        app = application.Application()'
    and: '>       prelim_opts, remaining_args = app.parse_preliminary_options(args)'
    and: '        config_finder = config.ConfigFileFinder('
    and: '            app.program,'
    and: '            prelim_opts.append_config,'
    and: '            config_file=prelim_opts.config,'
    and: '            ignore_config_files=prelim_opts.isolated,'
    and: '        )'
    and: '        app.find_plugins(config_finder)'
    and: '        app.register_plugin_options()'
    and: '        app.parse_configuration_and_cli(config_finder, remaining_args)'
    and: '        if flake8ignore:'
    and: '            app.options.ignore = flake8ignore'
    and: '        app.make_formatter()  # fix this'
    and: '        app.make_guide()'
    and: '        app.make_file_checker_manager()'
    and: '        app.run_checks([str(path)])'
    and: '        app.formatter.start()'
    and: '        app.report_errors()'
    and: '        app.formatter.stop()'
    and: "E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'"
    and: ''
    and: '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError'
    and: '=========================== short test summary info ============================'
    and: "FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'..."
    and: '======================= 1 failed, 1 deselected in 0.12s ========================'
remains unmatched: '*E201*'
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_keyword_match0
plugins: flake8-1.1.1
collected 2 items / 1 deselected / 1 selected

test_keyword_match.py F                                                  [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x564af0b4>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x6c3b1099>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x5b147d8e>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x5384606b>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x6fadffc0>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_keyword_match0/test_keyword_match.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED test_keyword_match.py::flake-8::FLAKE8 - AttributeError: 'Application'...
======================= 1 failed, 1 deselected in 0.12s ========================
____________________________ test_run_on_init_file _____________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 159, in test_run_on_init_file
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_run_on_init_file0
plugins: flake8-1.1.1
collected 1 item

tests/__init__.py F                                                      [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x1badbee4>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x128964ab>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x4e192480>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x7f47ebca>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x743accb6>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_run_on_init_file0/tests/__init__.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
=========================== short test summary info ============================
FAILED tests/__init__.py::flake-8::FLAKE8 - AttributeError: 'Application' obj...
============================== 1 failed in 0.10s ===============================
______________________________ test_unicode_error ______________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 167, in test_unicode_error
    f.write(py.builtin._totext("""
AttributeError: module 'py' has no attribute 'builtin'
_____________________________ test_junit_classname _____________________________
Traceback (most recent call last):
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 341, in from_call
    result: Optional[TResult] = func()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 262, in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 177, in pytest_runtest_call
    raise e
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py", line 169, in pytest_runtest_call
    item.runtest()
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 1792, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 113, in _multicall
    raise exception.with_traceback(exception.__traceback__)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/python.py", line 194, in pytest_pyfunc_call
    result = testfunction(**testargs)
  File "/workdir/pytest-flake8-1.1.1/test_flake8.py", line 192, in test_junit_classname
    result.assert_outcomes(passed=1)
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester.py", line 616, in assert_outcomes
    assert_outcomes(
  File "/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/pytester_assertions.py", line 75, in assert_outcomes
    assert obtained == expected
AssertionError
----------------------------- Captured stdout call -----------------------------
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0
rootdir: /tmp/pytest-of-tester/pytest-5/test_junit_classname0
plugins: flake8-1.1.1
collected 1 item

test_junit_classname.py F                                                [100%]

=================================== FAILURES ===================================
_________________________________ FLAKE8-check _________________________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x13219f0b>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
>               result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def __call__(self, **kwargs: object) -> Any:
            """Call the hook.
    
            Only accepts keyword arguments, which should match the hook
            specification.
    
            Returns the result(s) of calling all registered plugins, see
            :ref:`calling`.
            """
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
>           return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
    
        def call_historic(
            self,
            result_callback: Callable[[Any], None] | None = None,
            kwargs: Mapping[str, object] | None = None,
        ) -> None:
            """Call the hook with given ``kwargs`` for all registered plugins and
            for all plugins which will be registered afterwards, see
            :ref:`historic`.
    
            :param result_callback:
                If provided, will be called for each non-``None`` result obtained
                from a hook implementation.
            """
            assert self._call_history is not None
            kwargs = kwargs or {}
            self._verify_all_args_are_provided(kwargs)
            self._call_history.append((kwargs, result_callback))
            # Historizing hooks don't return results.
            # Remember firstresult isn't compatible with historic.
            res = self._hookexec(self.name, self._hookimpls, kwargs, False)
            if result_callback is None:
                return
            if isinstance(res, list):
                for x in res:
                    result_callback(x)
    
        def call_extra(
            self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]
        ) -> Any:
            """Call the hook with some additional temporarily participating
            methods using the specified ``kwargs`` as call parameters, see
            :ref:`call_extra`."""
            assert (
                not self.is_historic()
            ), "Cannot directly call a historic hook - use call_historic instead."
            self._verify_all_args_are_provided(kwargs)
            opts: HookimplOpts = {
                "wrapper": False,
                "hookwrapper": False,
                "optionalhook": False,
                "trylast": False,
                "tryfirst": False,
                "specname": None,
            }
            hookimpls = self._hookimpls.copy()
            for method in methods:
                hookimpl = HookImpl(None, "<temp>", method, opts)
                # Find last non-tryfirst nonwrapper method.
                i = len(hookimpls) - 1
                while (
                    i >= 0
                    and hookimpls[i].tryfirst
                    and not (hookimpls[i].hookwrapper or hookimpls[i].wrapper)
                ):
                    i -= 1
                hookimpls.insert(i + 1, hookimpl)
            firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
            return self._hookexec(self.name, hookimpls, kwargs, firstresult)
    
        def _maybe_apply_history(self, method: HookImpl) -> None:
            """Apply call history to a new hookimpl if it is marked as historic."""
            if self.is_historic():
                assert self._call_history is not None
                for kwargs, result_callback in self._call_history:
                    res = self._hookexec(self.name, [method], kwargs, False)
                    if res and result_callback is not None:
                        # XXX: remember firstresult isn't compat with historic
                        assert isinstance(res, list)
                        result_callback(res[0])
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.
    _HookCaller = HookCaller
    
    
    class _SubsetHookCaller(HookCaller):
        """A proxy to another HookCaller which manages calls to all registered
        plugins except the ones from remove_plugins."""
    
        # This class is unusual: in inhertits from `HookCaller` so all of
        # the *code* runs in the class, but it delegates all underlying *data*
        # to the original HookCaller.
        # `subset_hook_caller` used to be implemented by creating a full-fledged
        # HookCaller, copying all hookimpls from the original. This had problems
        # with memory leaks (#346) and historic calls (#347), which make a proxy
        # approach better.
        # An alternative implementation is to use a `_getattr__`/`__getattribute__`
        # proxy, however that adds more overhead and is more tricky to implement.
    
        __slots__ = (
            "_orig",
            "_remove_plugins",
        )
    
        def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:
            self._orig = orig
            self._remove_plugins = remove_plugins
            self.name = orig.name  # type: ignore[misc]
            self._hookexec = orig._hookexec  # type: ignore[misc]
    
        @property  # type: ignore[misc]
        def _hookimpls(self) -> list[HookImpl]:
            return [
                impl
                for impl in self._orig._hookimpls
                if impl.plugin not in self._remove_plugins
            ]
    
        @property
        def spec(self) -> HookSpec | None:  # type: ignore[override]
            return self._orig.spec
    
        @property
        def _call_history(self) -> _CallHistory | None:  # type: ignore[override]
            return self._orig._call_history
    
        def __repr__(self) -> str:
            return f"<_SubsetHookCaller {self.name!r}>"
    
    
    @final
    class HookImpl:
        """A hook implementation in a :class:`HookCaller`."""
    
        __slots__ = (
            "function",
            "argnames",
            "kwargnames",
            "plugin",
            "opts",
            "plugin_name",
            "wrapper",
            "hookwrapper",
            "optionalhook",
            "tryfirst",
            "trylast",
        )
    
        def __init__(
            self,
            plugin: _Plugin,
            plugin_name: str,
            function: _HookImplFunction[object],
            hook_impl_opts: HookimplOpts,
        ) -> None:
            """:meta private:"""
            #: The hook implementation function.
            self.function: Final = function
            argnames, kwargnames = varnames(self.function)
            #: The positional parameter names of ``function```.
            self.argnames: Final = argnames
            #: The keyword parameter names of ``function```.
            self.kwargnames: Final = kwargnames
            #: The plugin which defined this hook implementation.
            self.plugin: Final = plugin
            #: The :class:`HookimplOpts` used to configure this hook implementation.
            self.opts: Final = hook_impl_opts
            #: The name of the plugin which defined this hook implementation.
            self.plugin_name: Final = plugin_name
            #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.
            self.wrapper: Final = hook_impl_opts["wrapper"]
            #: Whether the hook implementation is an :ref:`old-style wrapper
            #: <old_style_hookwrappers>`.
            self.hookwrapper: Final = hook_impl_opts["hookwrapper"]
            #: Whether validation against a hook specification is :ref:`optional
            #: <optionalhook>`.
            self.optionalhook: Final = hook_impl_opts["optionalhook"]
            #: Whether to try to order this hook implementation :ref:`first
            #: <callorder>`.
            self.tryfirst: Final = hook_impl_opts["tryfirst"]
            #: Whether to try to order this hook implementation :ref:`last
            #: <callorder>`.
            self.trylast: Final = hook_impl_opts["trylast"]
    
        def __repr__(self) -> str:
            return f"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>"
    
    
    @final
    class HookSpec:
        __slots__ = (
            "namespace",
            "function",
            "name",
            "argnames",
            "kwargnames",
            "opts",
            "warn_on_impl",
        )
    
        def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
            self.namespace = namespace
            self.function: Callable[..., object] = getattr(namespace, name)
            self.name = name
            self.argnames, self.kwargnames = varnames(self.function)
            self.opts = opts

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x344b03ea>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

        def _hookexec(
            self,
            hook_name: str,
            methods: Sequence[HookImpl],
            kwargs: Mapping[str, object],
            firstresult: bool,
        ) -> object | list[object]:
            # called from all hookcaller instances.
            # enable_tracing will set its own wrapping function at self._inner_hookexec
>           return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    
        def register(self, plugin: _Plugin, name: str | None = None) -> str | None:
            """Register a plugin and return its name.
    
            :param name:
                The name under which to register the plugin. If not specified, a
                name is generated using :func:`get_canonical_name`.
    
            :returns:
                The plugin name. If the name is blocked from registering, returns
                ``None``.
    
            If the plugin is already registered, raises a :exc:`ValueError`.
            """
            plugin_name = name or self.get_canonical_name(plugin)
    
            if plugin_name in self._name2plugin:
                if self._name2plugin.get(plugin_name, -1) is None:
                    return None  # blocked plugin, return None to indicate no registration
                raise ValueError(
                    "Plugin name already registered: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            if plugin in self._name2plugin.values():
                raise ValueError(
                    "Plugin already registered under a different name: %s=%s\n%s"
                    % (plugin_name, plugin, self._name2plugin)
                )
    
            # XXX if an error happens we should make sure no state has been
            # changed at point of return
            self._name2plugin[plugin_name] = plugin
    
            # register matching hook implementations of the plugin
            for name in dir(plugin):
                hookimpl_opts = self.parse_hookimpl_opts(plugin, name)
                if hookimpl_opts is not None:
                    normalize_hookimpl_opts(hookimpl_opts)
                    method: _HookImplFunction[object] = getattr(plugin, name)
                    hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
                    name = hookimpl_opts.get("specname") or name
                    hook: HookCaller | None = getattr(self.hook, name, None)
                    if hook is None:
                        hook = HookCaller(name, self._hookexec)
                        setattr(self.hook, name, hook)
                    elif hook.has_spec():
                        self._verify_hook(hook, hookimpl)
                        hook._maybe_apply_history(hookimpl)
                    hook._add_hookimpl(hookimpl)
            return plugin_name
    
        def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:
            """Try to obtain a hook implementation from an item with the given name
            in the given plugin which is being searched for hook impls.
    
            :returns:
                The parsed hookimpl options, or None to skip the given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook implementation are picked up. By default, returns the
            options for items decorated with :class:`HookimplMarker`.
            """
            method: object = getattr(plugin, name)
            if not inspect.isroutine(method):
                return None
            try:
                res: HookimplOpts | None = getattr(
                    method, self.project_name + "_impl", None
                )
            except Exception:
                res = {}  # type: ignore[assignment]
            if res is not None and not isinstance(res, dict):
                # false positive
                res = None  # type:ignore[unreachable]
            return res
    
        def unregister(
            self, plugin: _Plugin | None = None, name: str | None = None
        ) -> Any | None:
            """Unregister a plugin and all of its hook implementations.
    
            The plugin can be specified either by the plugin object or the plugin
            name. If both are specified, they must agree.
    
            Returns the unregistered plugin, or ``None`` if not found.
            """
            if name is None:
                assert plugin is not None, "one of name or plugin needs to be specified"
                name = self.get_name(plugin)
                assert name is not None, "plugin is not registered"
    
            if plugin is None:
                plugin = self.get_plugin(name)
                if plugin is None:
                    return None
    
            hookcallers = self.get_hookcallers(plugin)
            if hookcallers:
                for hookcaller in hookcallers:
                    hookcaller._remove_plugin(plugin)
    
            # if self._name2plugin[name] == None registration was blocked: ignore
            if self._name2plugin.get(name):
                assert name is not None
                del self._name2plugin[name]
    
            return plugin
    
        def set_blocked(self, name: str) -> None:
            """Block registrations of the given name, unregister if already registered."""
            self.unregister(name=name)
            self._name2plugin[name] = None
    
        def is_blocked(self, name: str) -> bool:
            """Return whether the given plugin name is blocked."""
            return name in self._name2plugin and self._name2plugin[name] is None
    
        def add_hookspecs(self, module_or_class: _Namespace) -> None:
            """Add new hook specifications defined in the given ``module_or_class``.
    
            Functions are recognized as hook specifications if they have been
            decorated with a matching :class:`HookspecMarker`.
            """
            names = []
            for name in dir(module_or_class):
                spec_opts = self.parse_hookspec_opts(module_or_class, name)
                if spec_opts is not None:
                    hc: HookCaller | None = getattr(self.hook, name, None)
                    if hc is None:
                        hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)
                        setattr(self.hook, name, hc)
                    else:
                        # Plugins registered this hook without knowing the spec.
                        hc.set_specification(module_or_class, spec_opts)
                        for hookfunction in hc.get_hookimpls():
                            self._verify_hook(hc, hookfunction)
                    names.append(name)
    
            if not names:
                raise ValueError(
                    f"did not find any {self.project_name!r} hooks in {module_or_class!r}"
                )
    
        def parse_hookspec_opts(
            self, module_or_class: _Namespace, name: str
        ) -> HookspecOpts | None:
            """Try to obtain a hook specification from an item with the given name
            in the given module or class which is being searched for hook specs.
    
            :returns:
                The parsed hookspec options for defining a hook, or None to skip the
                given item.
    
            This method can be overridden by ``PluginManager`` subclasses to
            customize how hook specifications are picked up. By default, returns the
            options for items decorated with :class:`HookspecMarker`.
            """
            method = getattr(module_or_class, name)
            opts: HookspecOpts | None = getattr(method, self.project_name + "_spec", None)
            return opts
    
        def get_plugins(self) -> set[Any]:
            """Return a set of all registered plugin objects."""
            return set(self._name2plugin.values())
    
        def is_registered(self, plugin: _Plugin) -> bool:
            """Return whether the plugin is already registered."""
            return any(plugin == val for val in self._name2plugin.values())
    
        def get_canonical_name(self, plugin: _Plugin) -> str:
            """Return a canonical name for a plugin object.
    
            Note that a plugin may be registered under a different name
            specified by the caller of :meth:`register(plugin, name) <register>`.
            To obtain the name of a registered plugin use :meth:`get_name(plugin)
            <get_name>` instead.
            """
            name: str | None = getattr(plugin, "__name__", None)
            return name or str(id(plugin))
    
        def get_plugin(self, name: str) -> Any | None:
            """Return the plugin registered under the given name, if any."""
            return self._name2plugin.get(name)
    
        def has_plugin(self, name: str) -> bool:
            """Return whether a plugin with the given name is registered."""
            return self.get_plugin(name) is not None
    
        def get_name(self, plugin: _Plugin) -> str | None:
            """Return the name the plugin is registered under, or ``None`` if
            is isn't."""
            for name, val in self._name2plugin.items():
                if plugin == val:
                    return name
            return None
    
        def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:
            if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r\nhook %r\nhistoric incompatible with yield/wrapper/hookwrapper"
                    % (hookimpl.plugin_name, hook.name),
                )
    
            assert hook.spec is not None
            if hook.spec.warn_on_impl:
                _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
    
            # positional arg checking
            notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
            if notinspec:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Argument(s) %s are declared in the hookimpl but "
                    "can not be found in the hookspec"
                    % (
                        hookimpl.plugin_name,
                        hook.name,
                        _formatdef(hookimpl.function),
                        notinspec,
                    ),
                )
    
            if (
                hookimpl.wrapper or hookimpl.hookwrapper
            ) and not inspect.isgeneratorfunction(hookimpl.function):
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "Declared as wrapper=True or hookwrapper=True "
                    "but function is not a generator function"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
            if hookimpl.wrapper and hookimpl.hookwrapper:
                raise PluginValidationError(
                    hookimpl.plugin,
                    "Plugin %r for hook %r\nhookimpl definition: %s\n"
                    "The wrapper=True and hookwrapper=True options are mutually exclusive"
                    % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),
                )
    
        def check_pending(self) -> None:
            """Verify that all hooks which have not been verified against a
            hook specification are optional, otherwise raise
            :exc:`PluginValidationError`."""
            for name in self.hook.__dict__:
                if name[0] != "_":
                    hook: HookCaller = getattr(self.hook, name)
                    if not hook.has_spec():
                        for hookimpl in hook.get_hookimpls():
                            if not hookimpl.optionalhook:
                                raise PluginValidationError(
                                    hookimpl.plugin,
                                    "unknown hook %r in plugin %r"
                                    % (name, hookimpl.plugin),
                                )
    
        def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:
            """Load modules from querying the specified setuptools ``group``.
    
            :param group:
                Entry point group to load plugins.
            :param name:
                If given, loads only plugins with the given ``name``.
    
            :return:
                The number of plugins loaded by this call.
            """
            count = 0
            for dist in list(importlib.metadata.distributions()):
                for ep in dist.entry_points:
                    if (
                        ep.group != group
                        or (name is not None and ep.name != name)
                        # already registered
                        or self.get_plugin(ep.name)
                        or self.is_blocked(ep.name)
                    ):
                        continue
                    plugin = ep.load()
                    self.register(plugin, name=ep.name)
                    self._plugin_distinfo.append((plugin, DistFacade(dist)))
                    count += 1
            return count
    
        def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:
            """Return a list of (plugin, distinfo) pairs for all
            setuptools-registered plugins."""
            return list(self._plugin_distinfo)
    
        def list_name_plugin(self) -> list[tuple[str, _Plugin]]:
            """Return a list of (name, plugin) pairs for all registered plugins."""
            return list(self._name2plugin.items())
    
        def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:
            """Get all hook callers for the specified plugin.
    
            :returns:
                The hook callers, or ``None`` if ``plugin`` is not registered in
                this plugin manager.
            """
            if self.get_name(plugin) is None:
                return None
            hookcallers = []
            for hookcaller in self.hook.__dict__.values():
                for hookimpl in hookcaller.get_hookimpls():
                    if hookimpl.plugin is plugin:
                        hookcallers.append(hookcaller)
            return hookcallers
    
        def add_hookcall_monitoring(
            self, before: _BeforeTrace, after: _AfterTrace
        ) -> Callable[[], None]:
            """Add before/after tracing functions for all hooks.
    
            Returns an undo function which, when called, removes the added tracers.
    
            ``before(hook_name, hook_impls, kwargs)`` will be called ahead
            of all hook calls and receive a hookcaller instance, a list
            of HookImpl instances and the keyword arguments for the hook call.
    
            ``after(outcome, hook_name, hook_impls, kwargs)`` receives the
            same arguments as ``before`` but also a :class:`~pluggy.Result` object
            which represents the result of the overall hook call.
            """
            oldcall = self._inner_hookexec
    
            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

            def traced_hookexec(
                hook_name: str,
                hook_impls: Sequence[HookImpl],
                caller_kwargs: Mapping[str, object],
                firstresult: bool,
            ) -> object | list[object]:
                before(hook_name, hook_impls, caller_kwargs)
                outcome = Result.from_call(
                    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
>               return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:457: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x646d4054>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pluggy._result.Result'>
func = <function PluginManager.add_hookcall_monitoring.<locals>.traced_hookexec.<locals>.<lambda> at 0x138b9fd8>

        def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:
            """:meta private:"""
            __tracebackhide__ = True
            result = exception = None
            try:
>               result = func()
            except BaseException as exc:
                exception = exc
            return cls(result, exception)
    
        def force_result(self, result: ResultType) -> None:
            """Force the result(s) to ``result``.
    
            If the hook was marked as a ``firstresult`` a single value should
            be set, otherwise set a (modified) list of results. Any exceptions
            found during invocation will be deleted.
    
            This overrides any previous result or exception.
            """
            self._result = result
            self._exception = None
    
        def force_exception(self, exception: BaseException) -> None:
            """Force the result to fail with ``exception``.
    
            This overrides any previous result or exception.
    
            .. versionadded:: 1.1.0
            """
            self._result = None
            self._exception = exception
    
        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
                raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>                   lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)
                )
                after(outcome, hook_name, hook_impls, caller_kwargs)
                return outcome.get_result()
    
            self._inner_hookexec = traced_hookexec
    
            def undo() -> None:
                self._inner_hookexec = oldcall
    
            return undo
    
        def enable_tracing(self) -> Callable[[], None]:
            """Enable tracing of hook calls.
    
            Returns an undo function which, when called, removes the added tracing.
            """
            hooktrace = self.trace.root.get("hook")
    
            def before(
                hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]
            ) -> None:
                hooktrace.root.indent += 1
                hooktrace(hook_name, kwargs)
    
            def after(
                outcome: Result[object],
                hook_name: str,
                methods: Sequence[HookImpl],
                kwargs: Mapping[str, object],
            ) -> None:
                if outcome.exception is None:
                    hooktrace("finish", hook_name, "-->", outcome.get_result())
                hooktrace.root.indent -= 1
    
            return self.add_hookcall_monitoring(before, after)
    
        def subset_hook_caller(
            self, name: str, remove_plugins: Iterable[_Plugin]
        ) -> HookCaller:
            """Return a proxy :class:`~pluggy.HookCaller` instance for the named
            method which manages calls to all registered plugins except the ones
            from remove_plugins."""
            orig: HookCaller = getattr(self.hook, name)
            plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}
            if plugins_to_remove:
                return _SubsetHookCaller(orig, plugins_to_remove)
            return orig
    
    
    def _formatdef(func: Callable[..., object]) -> str:

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

>   ???

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pluggy._result.Result object at 0x43dcd055>

        def get_result(self) -> ResultType:
            """Get the result(s) for this hook call.
    
            If the hook was marked as a ``firstresult`` only a single value
            will be returned, otherwise a list of results.
            """
            __tracebackhide__ = True
            exc = self._exception
            if exc is None:
                return cast(ResultType, self._result)
            else:
>               raise exc.with_traceback(exc.__traceback__)
    
    
    # Historical name (pluggy<=1.2), kept for backward compatibility.

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/workdir/pytest-flake8-1.1.1/.tox/graalpylibtes...dir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/threadexception.py'>>]
caller_kwargs = {'item': <Flake8Item flake-8>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        only_new_style_wrappers = True
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                )
    
                    if hook_impl.hookwrapper:
                        only_new_style_wrappers = False
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            wrapper_gen = cast(Generator[None, Result[object], None], res)
                            next(wrapper_gen)  # first yield
                            teardowns.append((wrapper_gen,))
                        except StopIteration:
                            _raise_wrapfail(wrapper_gen, "did not yield")
                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            # Fast path - only new-style wrappers, no Result.
            if only_new_style_wrappers:
                if firstresult:  # first result hooks return a single value
                    result = results[0] if results else None
                else:
                    result = results
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    try:
                        if exception is not None:
                            teardown.throw(exception)  # type: ignore[union-attr]
                        else:
                            teardown.send(result)  # type: ignore[union-attr]
                        # Following is unreachable for a well behaved hook wrapper.
                        # Try to force finalizers otherwise postponed till GC action.
                        # Note: close() may raise if generator handles GeneratorExit.
                        teardown.close()  # type: ignore[union-attr]
                    except StopIteration as si:
                        result = si.value
                        exception = None
                        continue
                    except BaseException as e:
                        exception = e
                        continue
                    _raise_wrapfail(teardown, "has second yield")  # type: ignore[arg-type]
    
                if exception is not None:
                    raise exception.with_traceback(exception.__traceback__)
                else:
                    return result
    
            # Slow path - need to support old-style wrappers.
            else:
                if firstresult:  # first result hooks return a single value
                    outcome: Result[object | list[object]] = Result(
                        results[0] if results else None, exception
                    )
                else:
                    outcome = Result(results, exception)
    
                # run all wrapper post-yield blocks
                for teardown in reversed(teardowns):
                    if isinstance(teardown, tuple):
                        try:
                            teardown[0].send(outcome)
                            _raise_wrapfail(teardown[0], "has second yield")
                        except StopIteration:
                            pass
                    else:
                        try:
                            if outcome._exception is not None:
                                teardown.throw(outcome._exception)
                            else:
                                teardown.send(outcome._result)
                            # Following is unreachable for a well behaved hook wrapper.
                            # Try to force finalizers otherwise postponed till GC action.
                            # Note: close() may raise if generator handles GeneratorExit.
                            teardown.close()
                        except StopIteration as si:
                            outcome.force_result(si.value)
                            continue
                        except BaseException as e:
                            outcome.force_exception(e)
                            continue
                        _raise_wrapfail(teardown, "has second yield")

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
            item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
>           raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Flake8Item flake-8>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
        except AttributeError:
            pass
        try:
>           item.runtest()
        except Exception as e:
            # Store trace info to allow postmortem debugging
            sys.last_type = type(e)
            sys.last_value = e
            assert e.__traceback__ is not None
            # Skip *this* frame
            sys.last_traceback = e.__traceback__.tb_next
            raise e
    
    
    def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
        _update_current_test_var(item, "teardown")
        item.session._setupstate.teardown_exact(nextitem)
        _update_current_test_var(item, None)
    
    
    def _update_current_test_var(
        item: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
    ) -> None:
        """Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.
    
        If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
        """
        var_name = "PYTEST_CURRENT_TEST"
        if when:
            value = f"{item.nodeid} ({when})"
            # don't allow null bytes on environment variables (see #2644, #2957)
            value = value.replace("\x00", "(null)")
            os.environ[var_name] = value
        else:
            os.environ.pop(var_name)
    
    
    def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
        if report.when in ("setup", "teardown"):
            if report.failed:
                #      category, shortletter, verbose-word
                return "error", "E", "ERROR"
            elif report.skipped:
                return "skipped", "s", "SKIPPED"
            else:
                return "", "", ""
        return None
    
    
    #
    # Implementation
    
    
    def call_and_report(
        item: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
    ) -> TestReport:
        call = call_runtest_hook(item, when, **kwds)
        hook = item.ihook
        report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
        if log:
            hook.pytest_runtest_logreport(report=report)
        if check_interactive_exception(call, report):
            hook.pytest_exception_interact(node=item, call=call, report=report)
        return report
    
    
    def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
        """Check whether the call raised an exception that should be reported as
        interactive."""
        if call.excinfo is None:
            # Didn't raise.
            return False
        if hasattr(report, "wasxfail"):
            # Exception was expected.
            return False
        if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
            # Special control flow exception.
            return False
        return True
    
    
    def call_runtest_hook(
        item: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
    ) -> "CallInfo[None]":
        if when == "setup":
            ihook: Callable[..., None] = item.ihook.pytest_runtest_setup
        elif when == "call":
            ihook = item.ihook.pytest_runtest_call
        elif when == "teardown":
            ihook = item.ihook.pytest_runtest_teardown
        else:
            assert False, f"Unhandled runtest hook case: {when}"
        reraise: Tuple[Type[BaseException], ...] = (Exit,)
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
            lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )
    
    
    TResult = TypeVar("TResult", covariant=True)
    
    
    @final
    @dataclasses.dataclass
    class CallInfo(Generic[TResult]):
        """Result/Exception info of a function invocation."""
    
        _result: Optional[TResult]
        #: The captured exception of the call, if it raised.
        excinfo: Optional[ExceptionInfo[BaseException]]
        #: The system time when the call started, in seconds since the epoch.
        start: float
        #: The system time when the call ended, in seconds since the epoch.
        stop: float
        #: The call duration, in seconds.
        duration: float
        #: The context of invocation: "collect", "setup", "call" or "teardown".
        when: "Literal['collect', 'setup', 'call', 'teardown']"
    
        def __init__(
            self,
            result: Optional[TResult],
            excinfo: Optional[ExceptionInfo[BaseException]],
            start: float,
            stop: float,
            duration: float,
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            *,
            _ispytest: bool = False,
        ) -> None:
            check_ispytest(_ispytest)
            self._result = result
            self.excinfo = excinfo
            self.start = start
            self.stop = stop
            self.duration = duration
            self.when = when
    
        @property
        def result(self) -> TResult:
            """The return value of the call, if it didn't raise.
    
            Can only be accessed if excinfo is None.
            """
            if self.excinfo is not None:
                raise AttributeError(f"{self!r} has no valid result")
            # The cast is safe because an exception wasn't raised, hence
            # _result has the expected function return type (which may be
            #  None, that's why a cast and not an assert).
            return cast(TResult, self._result)
    
        @classmethod
        def from_call(
            cls,
            func: "Callable[[], TResult]",
            when: "Literal['collect', 'setup', 'call', 'teardown']",
            reraise: Optional[
                Union[Type[BaseException], Tuple[Type[BaseException], ...]]
            ] = None,
        ) -> "CallInfo[TResult]":
            """Call func, wrapping the result in a CallInfo.
    
            :param func:
                The function to call. Called without arguments.
            :param when:
                The phase in which the function is called.
            :param reraise:
                Exception or exceptions that shall propagate if raised by the
                function, instead of being wrapped in the CallInfo.
            """
            excinfo = None
            start = timing.time()
            precise_start = timing.perf_counter()
            try:
                result: Optional[TResult] = func()
            except BaseException:
                excinfo = ExceptionInfo.from_current()
                if reraise is not None and isinstance(excinfo.value, reraise):
                    raise
                result = None
            # use the perf counter
            precise_stop = timing.perf_counter()
            duration = precise_stop - precise_start
            stop = timing.time()
            return cls(
                start=start,
                stop=stop,
                duration=duration,
                when=when,
                result=result,
                excinfo=excinfo,
                _ispytest=True,
            )
    
        def __repr__(self) -> str:
            if self.excinfo is None:
                return f"<CallInfo when={self.when!r} result: {self._result!r}>"
            return f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"
    
    
    def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
        return TestReport.from_item_and_call(item, call)
    
    
    def pytest_make_collect_report(collector: Collector) -> CollectReport:
        call = CallInfo.from_call(lambda: list(collector.collect()), "collect")
        longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
        if not call.excinfo:
            outcome: Literal["passed", "skipped", "failed"] = "passed"
        else:
            skip_exceptions = [Skipped]
            unittest = sys.modules.get("unittest")
            if unittest is not None:
                # Type ignored because unittest is loaded dynamically.
                skip_exceptions.append(unittest.SkipTest)  # type: ignore
            if isinstance(call.excinfo.value, tuple(skip_exceptions)):
                outcome = "skipped"
                r_ = collector._repr_failure_py(call.excinfo, "line")
                assert isinstance(r_, ExceptionChainRepr), repr(r_)
                r = r_.reprcrash
                assert r
                longrepr = (str(r.path), r.lineno, r.message)
            else:
                outcome = "failed"
                errorinfo = collector.repr_failure(call.excinfo)
                if not hasattr(errorinfo, "toterminal"):
                    assert isinstance(errorinfo, str)
                    errorinfo = CollectErrorRepr(errorinfo)
                longrepr = errorinfo
        result = call.result if not call.excinfo else None
        rep = CollectReport(collector.nodeid, outcome, longrepr, result)
        rep.call = call  # type: ignore # see collect_one_node
        return rep
    
    
    class SetupState:
        """Shared state for setting up/tearing down test items or collectors
        in a session.
    
        Suppose we have a collection tree as follows:
    
        <Session session>
            <Module mod1>
                <Function item1>
            <Module mod2>
                <Function item2>
    
        The SetupState maintains a stack. The stack starts out empty:
    
            []
    
        During the setup phase of item1, setup(item1) is called. What it does
        is:
    
            push session to stack, run session.setup()
            push mod1 to stack, run mod1.setup()
            push item1 to stack, run item1.setup()
    
        The stack is:
    
            [session, mod1, item1]
    
        While the stack is in this shape, it is allowed to add finalizers to
        each of session, mod1, item1 using addfinalizer().
    
        During the teardown phase of item1, teardown_exact(item2) is called,
        where item2 is the next item to item1. What it does is:
    
            pop item1 from stack, run its teardowns
            pop mod1 from stack, run its teardowns
    
        mod1 was popped because it ended its purpose with item1. The stack is:
    
            [session]
    
        During the setup phase of item2, setup(item2) is called. What it does
        is:
    
            push mod2 to stack, run mod2.setup()
            push item2 to stack, run item2.setup()
    
        Stack:
    
            [session, mod2, item2]
    
        During the teardown phase of item2, teardown_exact(None) is called,
        because item2 is the last item. What it does is:
    
            pop item2 from stack, run its teardowns
            pop mod2 from stack, run its teardowns
            pop session from stack, run its teardowns
    
        Stack:
    
            []
    
        The end!
        """
    
        def __init__(self) -> None:
            # The stack is in the dict insertion order.
            self.stack: Dict[
                Node,
                Tuple[
                    # Node's finalizers.
                    List[Callable[[], object]],
                    # Node's exception, if its setup raised.
                    Optional[Union[OutcomeException, Exception]],
                ],
            ] = {}
    
        def setup(self, item: Item) -> None:
            """Setup objects along the collector chain to the item."""
            needed_collectors = item.listchain()
    
            # If a collector fails its setup, fail its entire subtree of items.
            # The setup is not retried for each item - the same exception is used.
            for col, (finalizers, exc) in self.stack.items():
                assert col in needed_collectors, "previous item was not torn down properly"
                if exc:
                    raise exc
    
            for col in needed_collectors[len(self.stack) :]:
                assert col not in self.stack
                # Push onto the stack.
                self.stack[col] = ([col.teardown], None)
                try:
                    col.setup()
                except TEST_OUTCOME as exc:
                    self.stack[col] = (self.stack[col][0], exc)
                    raise exc
    
        def addfinalizer(self, finalizer: Callable[[], object], node: Node) -> None:
            """Attach a finalizer to the given node.
    
            The node must be currently active in the stack.
            """
            assert node and not isinstance(node, tuple)
            assert callable(finalizer)
            assert node in self.stack, (node, self.stack)
            self.stack[node][0].append(finalizer)
    
        def teardown_exact(self, nextitem: Optional[Item]) -> None:
            """Teardown the current stack up until reaching nodes that nextitem
            also descends from.
    
            When nextitem is None (meaning we're at the last item), the entire
            stack is torn down.
            """
            needed_collectors = nextitem and nextitem.listchain() or []
            exceptions: List[BaseException] = []
            while self.stack:
                if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:
                    break
                node, (finalizers, _) = self.stack.popitem()
                these_exceptions = []
                while finalizers:
                    fin = finalizers.pop()
                    try:
                        fin()
                    except TEST_OUTCOME as e:
                        these_exceptions.append(e)
    
                if len(these_exceptions) == 1:
                    exceptions.extend(these_exceptions)
                elif these_exceptions:
                    msg = f"errors while tearing down {node!r}"
                    exceptions.append(BaseExceptionGroup(msg, these_exceptions[::-1]))
    
            if len(exceptions) == 1:
                raise exceptions[0]
            elif exceptions:
                raise BaseExceptionGroup("errors during test teardown", exceptions[::-1])
            if nextitem is None:
                assert not self.stack
    
    
    def collect_one_node(collector: Collector) -> CollectReport:
        ihook = collector.ihook
        ihook.pytest_collectstart(collector=collector)
        rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
        call = rep.__dict__.pop("call", None)
        if call and check_interactive_exception(call, rep):
            ihook.pytest_exception_interact(node=collector, call=call, report=rep)

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/runner.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flake8Item flake-8>

        def runtest(self):
            with BytesIO() as bo, TextIOWrapper(bo, encoding='utf-8') as to, \
                 BytesIO() as be, TextIOWrapper(be, encoding='utf-8') as te, \
                 redirect_stdout(to), redirect_stderr(te):
>               found_errors = check_file(
                    self.fspath,
                    self.flake8ignore,
                    self.maxlength,
                    self.maxdoclength,
                    self.maxcomplexity,
                    self.showsource,
                    self.statistics
                )
                to.flush()
                te.flush()
                out = bo.getvalue().decode('utf-8')
                err = be.getvalue().decode('utf-8')
    
            if found_errors:
                raise Flake8Error(out, err)
            # update mtime only if test passed
            # otherwise failures would not be re-run next time
            if hasattr(self.config, "_flake8mtimes"):
                self.config._flake8mtimes[str(self.fspath)] = (self._flake8mtime,
                                                               self.flake8ignore)
    
        def repr_failure(self, excinfo):
            if excinfo.errisinstance(Flake8Error):
                return excinfo.value.args[0]
            return super(Flake8Item, self).repr_failure(excinfo)
    
        def reportinfo(self):
            if self.flake8ignore:
                ignores = "(ignoring %s)" % " ".join(self.flake8ignore)
            else:
                ignores = ""
            return (self.fspath, -1, "FLAKE8-check%s" % ignores)
    
    
    class Ignorer:
        def __init__(self, ignorelines, coderex=re.compile(r"[EW]\d\d\d")):
            self.ignores = ignores = []
            for line in ignorelines:
                i = line.find("#")
                if i != -1:
                    line = line[:i]
                try:
                    glob, ign = line.split(None, 1)
                except ValueError:
                    glob, ign = None, line
                if glob and coderex.match(glob):
                    glob, ign = None, line
                ign = ign.split()
                if "ALL" in ign:
                    ign = None
                if glob and "/" != os.sep and "/" in glob:
                    glob = glob.replace("/", os.sep)
                ignores.append((glob, ign))
    
        def __call__(self, path):
            l = []  # noqa: E741
            for (glob, ignlist) in self.ignores:
                if not glob or path.fnmatch(glob):
                    if ignlist is None:
                        return None
                    l.extend(ignlist)
            return l
    
    
    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
        prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = local('/tmp/pytest-of-tester/pytest-5/test_junit_classname0/test_junit_classname.py')
flake8ignore = [], maxlength = '', maxdoclenght = '', maxcomplexity = ''
showsource = [], statistics = []

    def check_file(path, flake8ignore, maxlength, maxdoclenght, maxcomplexity,
                   showsource, statistics):
        """Run flake8 over a single file, and return the number of failures."""
        args = []
        if maxlength:
            args += ['--max-line-length', maxlength]
        if maxdoclenght:
            args += ['--max-doc-length', maxdoclenght]
        if maxcomplexity:
            args += ['--max-complexity', maxcomplexity]
        if showsource:
            args += ['--show-source']
        if statistics:
            args += ['--statistics']
        app = application.Application()
>       prelim_opts, remaining_args = app.parse_preliminary_options(args)
        config_finder = config.ConfigFileFinder(
            app.program,
            prelim_opts.append_config,
            config_file=prelim_opts.config,
            ignore_config_files=prelim_opts.isolated,
        )
        app.find_plugins(config_finder)
        app.register_plugin_options()
        app.parse_configuration_and_cli(config_finder, remaining_args)
        if flake8ignore:
            app.options.ignore = flake8ignore
        app.make_formatter()  # fix this
        app.make_guide()
        app.make_file_checker_manager()
        app.run_checks([str(path)])
        app.formatter.start()
        app.report_errors()
        app.formatter.stop()
E       AttributeError: 'Application' object has no attribute 'parse_preliminary_options'

/workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pytest_flake8.py:216: AttributeError
- generated xml file: /tmp/pytest-of-tester/pytest-5/test_junit_classname0/TEST.xml -
=========================== short test summary info ============================
FAILED test_junit_classname.py::flake-8::FLAKE8 - AttributeError: 'Applicatio...
============================== 1 failed in 0.20s ===============================
- generated xml file: /workdir/results/pytest-flake8/1.1.1/1/graalpy-test-results.xml -
=========================== short test summary info ============================
FAILED pytest_flake8.py::flake-8::FLAKE8 - AttributeError: 'Application' obje...
FAILED setup.py::flake-8::FLAKE8 - AttributeError: 'Application' object has n...
FAILED test_flake8.py::flake-8::FLAKE8 - AttributeError: 'Application' object...
FAILED test_flake8.py::TestIgnores::test_default_flake8_ignores - AssertionError
FAILED test_flake8.py::TestIgnores::test_ignores_all - AssertionError
FAILED test_flake8.py::TestIgnores::test_w293w292 - Failed: nomatch: '*W293*'
FAILED test_flake8.py::TestIgnores::test_mtime_caching - Failed: nomatch: '*W...
FAILED test_flake8.py::test_ok_verbose - AssertionError
FAILED test_flake8.py::test_keyword_match - Failed: nomatch: '*E201*'
FAILED test_flake8.py::test_run_on_init_file - AssertionError
FAILED test_flake8.py::test_unicode_error - AttributeError: module 'py' has n...
FAILED test_flake8.py::test_junit_classname - AssertionError
=================== 12 failed, 3 passed, 1 xfailed in 9.43s ====================
ERROR: InvocationError for command /workdir/pytest-flake8-1.1.1/.tox/graalpylibtest-unit-test-tests/bin/pytest -v --tb=native --junitxml /workdir/results/pytest-flake8/1.1.1/1/graalpy-test-results.xml (exited with code 1)
___________________________________ summary ____________________________________
ERROR:   graalpylibtest-unit-test-tests: commands failed
