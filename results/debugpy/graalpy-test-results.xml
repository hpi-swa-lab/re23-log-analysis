<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="2" failures="0" skipped="0" tests="2" time="34.452" timestamp="2023-11-21T01:59:56.975000" hostname="b80581c01e0f"><testcase classname="pytest" name="internal" time="0.000"><error message="internal error">def worker_internal_error(self, node, formatted_error):
            """
            pytest_internalerror() was called on the worker.
    
            pytest_internalerror() arguments are an excinfo and an excrepr, which can't
            be serialized, so we go with a poor man's solution of raising an exception
            here ourselves using the formatted message.
            """
            self._active_nodes.remove(node)
            try:
&gt;               assert False, formatted_error
            except AssertionError:
                from _pytest._code import ExceptionInfo
    
                excinfo = ExceptionInfo.from_current()
                excrepr = excinfo.getrepr()
                self.config.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)
    
        def worker_errordown(self, node, error):
            """Emitted by the WorkerController when a node dies."""
            self.config.hook.pytest_testnodedown(node=node, error=error)
            try:
                crashitem = self.sched.remove_node(node)
            except KeyError:
                pass
            else:
                if crashitem:
                    self.handle_crashitem(crashitem, node)
    
            self._failed_nodes_count += 1
            maximum_reached = (
                self._max_worker_restart is not None
                and self._failed_nodes_count &gt; self._max_worker_restart
            )
            if maximum_reached:
                if self._max_worker_restart == 0:
                    msg = "worker {} crashed and worker restarting disabled".format(
                        node.gateway.id
                    )
                else:
                    msg = "maximum crashed workers reached: %d" % self._max_worker_restart
                self._summary_report = msg
                self.report_line("\n" + msg)
                self.triggershutdown()
            else:
                self.report_line("\nreplacing crashed worker %s" % node.gateway.id)
                self.shuttingdown = False
                self._clone_node(node)
            self._active_nodes.remove(node)
    
        @pytest.hookimpl
        def pytest_terminal_summary(self, terminalreporter):
            if self.config.option.verbose &gt;= 0 and self._summary_report:
                terminalreporter.write_sep("=", f"xdist: {self._summary_report}")
    
        def worker_collectionfinish(self, node, ids):
            """worker has finished test collection.
    
            This adds the collection for this node to the scheduler.  If
            the scheduler indicates collection is finished (i.e. all
            initial nodes have submitted their collections), then tells the
            scheduler to schedule the collected items.  When initiating
            scheduling the first time it logs which scheduler is in use.
            """
            if self.shuttingdown:
                return
            self.config.hook.pytest_xdist_node_collection_finished(node=node, ids=ids)
            # tell session which items were effectively collected otherwise
            # the controller node will finish the session with EXIT_NOTESTSCOLLECTED
            self._session.testscollected = len(ids)
            self.sched.add_node_collection(node, ids)
            if self.terminal:
                self.trdist.setstatus(
                    node.gateway.spec, WorkerStatus.CollectionDone, tests_collected=len(ids)
                )
            if self.sched.collection_is_completed:
                if self.terminal and not self.sched.has_pending:
                    self.trdist.ensure_show_status()
                    self.terminal.write_line("")
                    if self.config.option.verbose &gt; 0:
                        self.terminal.write_line(
                            f"scheduling tests via {self.sched.__class__.__name__}"
                        )
                self.sched.schedule()
    
        def worker_logstart(self, node, nodeid, location):
            """Emitted when a node calls the pytest_runtest_logstart hook."""
            self.config.hook.pytest_runtest_logstart(nodeid=nodeid, location=location)
    
        def worker_logfinish(self, node, nodeid, location):
            """Emitted when a node calls the pytest_runtest_logfinish hook."""
            self.config.hook.pytest_runtest_logfinish(nodeid=nodeid, location=location)
    
        def worker_testreport(self, node, rep):
            """Emitted when a node calls the pytest_runtest_logreport hook."""
            rep.node = node
            self.config.hook.pytest_runtest_logreport(report=rep)
            self._handlefailures(rep)
    
        def worker_runtest_protocol_complete(self, node, item_index, duration):
            """
            Emitted when a node fires the 'runtest_protocol_complete' event,
            signalling that a test has completed the runtestprotocol and should be
            removed from the pending list in the scheduler.
            """
            self.sched.mark_test_complete(node, item_index, duration)
    
        def worker_unscheduled(self, node, indices):
            """
            Emitted when a node fires the 'unscheduled' event, signalling that
            some tests have been removed from the worker's queue and should be
            sent to some worker again.
    
            This should happen only in response to 'steal' command, so schedulers
            not using 'steal' command don't have to implement it.
            """
            self.sched.remove_pending_tests_from_node(node, indices)
    
        def worker_collectreport(self, node, rep):
            """Emitted when a node calls the pytest_collectreport hook.
    
            Because we only need the report when there's a failure/skip, as optimization
            we only expect to receive failed/skipped reports from workers (#330).
            """
            assert not rep.passed
            self._failed_worker_collectreport(node, rep)
    
        def worker_warning_captured(self, warning_message, when, item):
            """Emitted when a node calls the pytest_warning_captured hook (deprecated in 6.0)."""
            # This hook as been removed in pytest 7.1, and we can remove support once we only
            # support pytest &gt;=7.1.
            kwargs = dict(warning_message=warning_message, when=when, item=item)
            self.config.hook.pytest_warning_captured.call_historic(kwargs=kwargs)
    
        def worker_warning_recorded(self, warning_message, when, nodeid, location):
            """Emitted when a node calls the pytest_warning_recorded hook."""
            kwargs = dict(
                warning_message=warning_message, when=when, nodeid=nodeid, location=location
            )
            self.config.hook.pytest_warning_recorded.call_historic(kwargs=kwargs)
    
        def _clone_node(self, node):
            """Return new node based on an existing one.
    
            This is normally for when a node dies, this will copy the spec
            of the existing node and create a new one with a new id.  The
            new node will have been setup so it will start calling the
            "worker_*" hooks and do work soon.
            """
            spec = node.gateway.spec
            spec.id = None
            self.nodemanager.group.allocate_id(spec)
            node = self.nodemanager.setup_node(spec, self.queue.put)
            self._active_nodes.add(node)
            return node
    
        def _failed_worker_collectreport(self, node, rep):
            # Check we haven't already seen this report (from
            # another worker).
            if rep.longrepr not in self._failed_collection_errors:
                self._failed_collection_errors[rep.longrepr] = True
                self.config.hook.pytest_collectreport(report=rep)
                self._handlefailures(rep)
    
        def _handlefailures(self, rep):
            if rep.failed:
                self.countfailures += 1
                if (
                    self.maxfail
                    and self.countfailures &gt;= self.maxfail
                    and not self.shouldstop
                ):
                    self.shouldstop = f"stopping after {self.countfailures} failures"
    
        def triggershutdown(self):
            if not self.shuttingdown:
                self.log("triggering shutdown")
                self.shuttingdown = True
                for node in self.sched.nodes:
                    node.shutdown()
    
        def handle_crashitem(self, nodeid, worker):
            # XXX get more reporting info by recording pytest_runtest_logstart?
            # XXX count no of failures and retry N times
            runner = self.config.pluginmanager.getplugin("runner")
            fspath = nodeid.split("::")[0]
            msg = f"worker {worker.gateway.id!r} crashed while running {nodeid!r}"
            rep = runner.TestReport(
                nodeid, (fspath, None, fspath), (), "failed", msg, "???"
            )
            rep.node = worker
    
            self.config.hook.pytest_handlecrashitem(
                crashitem=nodeid,
                report=rep,
                sched=self.sched,
            )
            self.config.hook.pytest_runtest_logreport(report=rep)
    
    
    class WorkerStatus(Enum):
        """Status of each worker during creation/collection."""
    
        # Worker spec has just been created.
        Created = auto()
    
        # Worker has been initialized.
        Initialized = auto()
    
        # Worker is now ready for collection.
        ReadyForCollection = auto()
    
        # Worker has finished collection.
        CollectionDone = auto()
    
    
    class TerminalDistReporter:
        def __init__(self, config) -&gt; None:
            self.config = config
            self.tr = config.pluginmanager.getplugin("terminalreporter")
            self._status: dict[str, tuple[WorkerStatus, int]] = {}
            self._lastlen = 0
            self._isatty = getattr(self.tr, "isatty", self.tr.hasmarkup)
    
        def write_line(self, msg: str) -&gt; None:
            self.tr.write_line(msg)
    
        def ensure_show_status(self) -&gt; None:
            if not self._isatty:
                self.write_line(self.getstatus())
    
        def setstatus(
            self, spec, status: WorkerStatus, *, tests_collected: int, show: bool = True
        ) -&gt; None:
            self._status[spec.id] = (status, tests_collected)
            if show and self._isatty:
                self.rewrite(self.getstatus())
    
        def getstatus(self) -&gt; str:
            if self.config.option.verbose &gt;= 0:
                line = get_workers_status_line(list(self._status.values()))
                if line:
                    return line
    
            return "bringing up nodes..."
    
        def rewrite(self, line, newline=False):
            pline = line + " " * max(self._lastlen - len(line), 0)
            if newline:
                self._lastlen = 0
                pline += "\n"
            else:
                self._lastlen = len(line)
            self.tr.rewrite(pline, bold=True)
    
        @pytest.hookimpl
        def pytest_xdist_setupnodes(self, specs) -&gt; None:
            self._specs = specs
            for spec in specs:
                self.setstatus(spec, WorkerStatus.Created, tests_collected=0, show=False)
            self.setstatus(spec, WorkerStatus.Created, tests_collected=0, show=True)
            self.ensure_show_status()
    
        @pytest.hookimpl
        def pytest_xdist_newgateway(self, gateway) -&gt; None:
            if self.config.option.verbose &gt; 0:
                rinfo = gateway._rinfo()
                different_interpreter = rinfo.executable != sys.executable
                if different_interpreter:
                    version = "%s.%s.%s" % rinfo.version_info[:3]
                    self.rewrite(
                        f"[{gateway.id}] {rinfo.platform} Python {version} cwd: {rinfo.cwd}",
                        newline=True,
                    )
            self.setstatus(gateway.spec, WorkerStatus.Initialized, tests_collected=0)
    
        @pytest.hookimpl
        def pytest_testnodeready(self, node) -&gt; None:
            if self.config.option.verbose &gt; 0:
                d = node.workerinfo
                different_interpreter = d.get("executable") != sys.executable
                if different_interpreter:
                    version = d["version"].replace("\n", " -- ")
                    self.rewrite(f"[{d['id']}] Python {version}", newline=True)
            self.setstatus(
                node.gateway.spec, WorkerStatus.ReadyForCollection, tests_collected=0
            )
    
        @pytest.hookimpl
        def pytest_testnodedown(self, node, error) -&gt; None:
            if not error:
                return
            self.write_line(f"[{node.gateway.id}] node down: {error}")
    
    
    def get_default_max_worker_restart(config):
        """gets the default value of --max-worker-restart option if it is not provided.
    
        Use a reasonable default to avoid workers from restarting endlessly due to crashing collections (#226).
        """
        result = config.option.maxworkerrestart
        if result is not None:
            result = int(result)
        elif config.option.numprocesses:
            # if --max-worker-restart was not provided, use a reasonable default (#226)
            result = config.option.numprocesses * 4
        return result
    
    
    def get_workers_status_line(
        status_and_items: Sequence[tuple[WorkerStatus, int]]
    ) -&gt; str:
        """
        Return the line to display during worker setup/collection based on the
        status of the workers and number of tests collected for each.
        """
        statuses = [s for s, c in status_and_items]
        total_workers = len(statuses)
        workers_noun = "worker" if total_workers == 1 else "workers"
        if status_and_items and all(s == WorkerStatus.CollectionDone for s in statuses):
            # All workers collect the same number of items, so we grab
            # the total number of items from the first worker.
            first = status_and_items[0]
            status, tests_collected = first
            tests_noun = "item" if tests_collected == 1 else "items"
            return f"{total_workers} {workers_noun} [{tests_collected} {tests_noun}]"
        if WorkerStatus.CollectionDone in statuses:
            done = sum(1 for s, c in status_and_items if c &gt; 0)
            return f"collecting: {done}/{total_workers} {workers_noun}"
        if WorkerStatus.ReadyForCollection in statuses:
            ready = statuses.count(WorkerStatus.ReadyForCollection)
            return f"ready: {ready}/{total_workers} {workers_noun}"
        if WorkerStatus.Initialized in statuses:
            initialized = statuses.count(WorkerStatus.Initialized)
            return f"initialized: {initialized}/{total_workers} {workers_noun}"
        if WorkerStatus.Created in statuses:
            created = statuses.count(WorkerStatus.Created)
            return f"created: {created}/{total_workers} {workers_noun}"
E           AssertionError: Traceback (most recent call last):
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1498, in _save
E               dispatch = self._dispatch[tp]
E           KeyError: &lt;class 'sys.version_info'&gt;
E           
E           During handling of the above exception, another exception occurred:
E           
E           Traceback (most recent call last):
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/main.py", line 269, in wrap_session
E               config.hook.pytest_sessionstart(session=session)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
E               return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
E               return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
E               return outcome.get_result()
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
E               raise exc.with_traceback(exc.__traceback__)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
E               res = hook_impl.function(*args)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/xdist/remote.py", line 100, in pytest_sessionstart
E               self.sendevent("workerready", workerinfo=workerinfo)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/xdist/remote.py", line 87, in sendevent
E               self.channel.send((name, kwargs))
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 811, in send
E               self.gateway._send(Message.CHANNEL_DATA, self.id, dumps_internal(item))
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1469, in dumps_internal
E               return _Serializer().save(obj)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1487, in save
E               self._save(obj)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1505, in _save
E               dispatch(self, obj)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1580, in save_tuple
E               self._save(item)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1505, in _save
E               dispatch(self, obj)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1576, in save_dict
E               self._write_setitem(key, value)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1570, in _write_setitem
E               self._save(value)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1505, in _save
E               dispatch(self, obj)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1576, in save_dict
E               self._write_setitem(key, value)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1570, in _write_setitem
E               self._save(value)
E             File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/execnet/gateway_base.py", line 1503, in _save
E               raise DumpError(f"can't serialize {tp}")
E           execnet.gateway_base.DumpError: can't serialize &lt;class 'sys.version_info'&gt;

.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/xdist/dsession.py:200: AssertionError</error><error message="internal error">Traceback (most recent call last):
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/main.py", line 271, in wrap_session
    session.exitstatus = doit(config, session) or 0
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/_pytest/main.py", line 325, in _main
    config.hook.pytest_runtestloop(session=session)
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_hooks.py", line 493, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_manager.py", line 115, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 152, in _multicall
    return outcome.get_result()
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_result.py", line 114, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/pluggy/_callers.py", line 77, in _multicall
    res = hook_impl.function(*args)
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/xdist/dsession.py", line 123, in pytest_runtestloop
    self.loop_once()
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/xdist/dsession.py", line 148, in loop_once
    call(**kwargs)
  File "/workdir/debugpy-1.6.7/.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/xdist/dsession.py", line 238, in worker_errordown
    self._active_nodes.remove(node)
KeyError: &lt;WorkerController gw0&gt;</error></testcase></testsuite></testsuites>