warning: no previously-included files found matching '.coverage'
warning: no previously-included files found matching '.gitignore'
warning: no previously-included files found matching '.pre-commit-config.yaml'
warning: no previously-included files found matching '.coverage'
warning: no previously-included files found matching '.gitignore'
warning: no previously-included files found matching '.pre-commit-config.yaml'
graalpylibtest-unit-test-tests create: /workdir/krb5-0.5.0/.tox/graalpylibtest-unit-test-tests
graalpylibtest-unit-test-tests installdeps: -r/workdir/krb5-0.5.0/requirements-dev.txt
graalpylibtest-unit-test-tests inst: /workdir/krb5-0.5.0/.tox/.tmp/package/1/krb5-0.5.0.tar.gz
graalpylibtest-unit-test-tests installed: black==22.10.0,cfgv==3.4.0,click==8.1.7,distlib==0.3.7,exceptiongroup==1.2.0,filelock==3.13.1,graalpy-virtualenv==0.0.1,hpy==0.9.0rc2,identify==2.5.32,iniconfig==2.0.0,isort==5.10.1,k5test==0.10.3,krb5 @ file:///workdir/krb5-0.5.0/.tox/.tmp/package/1/krb5-0.5.0.tar.gz,mypy==0.982,mypy-extensions==1.0.0,nodeenv==1.8.0,packaging==23.2,pathspec==0.11.2,platformdirs==4.0.0,pluggy==1.3.0,pre-commit==3.5.0,py==1.11.0,pytest==7.4.3,PyYAML==6.0.1,six==1.16.0,tomli==2.0.1,tox==3.28.0,typing_extensions==4.8.0,virtualenv==20.24.7
graalpylibtest-unit-test-tests run-test-pre: PYTHONHASHSEED='3660464449'
graalpylibtest-unit-test-tests run-test: commands[0] | python -m pytest -v
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.3, pluggy-1.3.0 -- /workdir/krb5-0.5.0/.tox/graalpylibtest-unit-test-tests/bin/python
cachedir: .tox/graalpylibtest-unit-test-tests/.pytest_cache
rootdir: /workdir/krb5-0.5.0
configfile: pyproject.toml
testpaths: tests
collecting ... collected 79 items

tests/test_ccache.py::test_cc_default ERROR                              [  1%]
tests/test_ccache.py::test_cc_default_name ERROR                         [  2%]
tests/test_ccache.py::test_cc_destroy PASSED                             [  3%]
tests/test_ccache.py::test_cc_get_name PASSED                            [  5%]
tests/test_ccache.py::test_cc_get_principal PASSED                       [  6%]
tests/test_ccache.py::test_cc_get_type PASSED                            [  7%]
tests/test_ccache.py::test_cc_initialize PASSED                          [  8%]
tests/test_ccache.py::test_cc_new_unique PASSED                          [ 10%]
tests/test_ccache.py::test_cc_resolve PASSED                             [ 11%]
tests/test_ccache.py::test_cc_store_cred ERROR                           [ 12%]
tests/test_ccache.py::test_cc_dup PASSED                                 [ 13%]
tests/test_ccache.py::test_cc_set_default_name PASSED                    [ 15%]
tests/test_ccache.py::test_cc_switch ERROR                               [ 16%]
tests/test_ccache.py::test_cc_supports_switch_invalid_type PASSED        [ 17%]
tests/test_ccache.py::test_cc_supports_switch[FILE] PASSED               [ 18%]
tests/test_ccache.py::test_cc_supports_switch[DIR] PASSED                [ 20%]
tests/test_ccache.py::test_cc_cache_match ERROR                          [ 21%]
tests/test_ccache.py::test_cc_retrieve_remove_cred ERROR                 [ 22%]
tests/test_cccol.py::test_cccol_iter PASSED                              [ 24%]
tests/test_context.py::test_init_context PASSED                          [ 25%]
tests/test_context.py::test_set_default_realm ERROR                      [ 26%]
tests/test_context.py::test_init_secure_context PASSED                   [ 27%]
tests/test_creds.py::test_get_init_creds_keytab ERROR                    [ 29%]
tests/test_creds.py::test_get_init_creds_password ERROR                  [ 30%]
tests/test_creds.py::test_get_init_creds_password_prompt ERROR           [ 31%]
tests/test_creds.py::test_get_init_creds_password_prompt_failure ERROR   [ 32%]
tests/test_creds.py::test_get_creds_keytab ERROR                         [ 34%]
tests/test_creds.py::test_get_creds_keytab_wrong_principal ERROR         [ 35%]
tests/test_creds.py::test_init_creds_set_password ERROR                  [ 36%]
tests/test_creds.py::test_init_creds_set_password_invalid ERROR          [ 37%]
tests/test_creds_opt.py::test_get_init_creds_opt_alloc PASSED            [ 39%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_anonymous PASSED    [ 40%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_canonicalize PASSED [ 41%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_etype_list PASSED   [ 43%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_forwardable PASSED  [ 44%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_proxiable PASSED    [ 45%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_renew_life PASSED   [ 46%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_salt PASSED         [ 48%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_salt_invalid_empty_string PASSED [ 49%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_tkt_life PASSED     [ 50%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_fast_flags PASSED   [ 51%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_fast_ccache PASSED  [ 53%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_fast_ccache_name PASSED [ 54%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_in_ccache PASSED    [ 55%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_out_ccache PASSED   [ 56%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_pac_request PASSED  [ 58%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_default_flags SKIPPED [ 59%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_pa PASSED           [ 60%]
tests/test_creds_opt.py::test_get_init_creds_opt_set_pa_invalid_empty_value PASSED [ 62%]
tests/test_keyblock.py::test_init_keyblock_empty PASSED                  [ 63%]
tests/test_keyblock.py::test_init_keyblock_data PASSED                   [ 64%]
tests/test_kt.py::test_kt_default ERROR                                  [ 65%]
tests/test_kt.py::test_kt_default_name ERROR                             [ 67%]
tests/test_kt.py::test_kt_get_name ERROR                                 [ 68%]
tests/test_kt.py::test_kt_get_full_name PASSED                           [ 69%]
tests/test_kt.py::test_kt_get_type PASSED                                [ 70%]
tests/test_kt.py::test_kt_enumerate ERROR                                [ 72%]
tests/test_kt.py::test_kt_get_entry_empty ERROR                          [ 73%]
tests/test_kt.py::test_kt_get_entry ERROR                                [ 74%]
tests/test_kt.py::test_kt_get_entry_multiple_kvno ERROR                  [ 75%]
tests/test_kt.py::test_kt_get_entry_multiple_enctype ERROR               [ 77%]
tests/test_kt.py::test_kt_read_service_key_empty ERROR                   [ 78%]
tests/test_kt.py::test_kt_read_service_key PASSED                        [ 79%]
tests/test_kt.py::test_kt_read_service_key_multiple_kvno ERROR           [ 81%]
tests/test_kt.py::test_kt_read_service_key_multiple_enctype ERROR        [ 82%]
tests/test_kt.py::test_kt_resolve PASSED                                 [ 83%]
tests/test_kt.py::test_kt_client_default ERROR                           [ 84%]
tests/test_kt.py::test_kt_dup PASSED                                     [ 86%]
tests/test_kt.py::test_kt_have_content PASSED                            [ 87%]
tests/test_principal.py::test_parse_principal ERROR                      [ 88%]
tests/test_principal.py::test_parse_principal_no_realm_failure ERROR     [ 89%]
tests/test_principal.py::test_unparse_principal ERROR                    [ 91%]
tests/test_principal.py::test_principal_get_realm SKIPPED (KRB5 API ...) [ 92%]
tests/test_string.py::test_enctype_to_string ERROR                       [ 93%]
tests/test_string.py::test_enctype_to_string_invalid ERROR               [ 94%]
tests/test_string.py::test_string_to_enctype PASSED                      [ 96%]
tests/test_string.py::test_string_to_enctype_invalid ERROR               [ 97%]
tests/test_string.py::test_string_to_name PASSED                         [ 98%]
tests/test_string.py::test_string_to_name_shortest PASSED                [100%]

==================================== ERRORS ====================================
______________________ ERROR at setup of test_cc_default _______________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
____________________ ERROR at setup of test_cc_default_name ____________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_____________________ ERROR at setup of test_cc_store_cred _____________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_______________________ ERROR at setup of test_cc_switch _______________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
____________________ ERROR at setup of test_cc_cache_match _____________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
________________ ERROR at setup of test_cc_retrieve_remove_cred ________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________________ ERROR at setup of test_set_default_realm ___________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_________________ ERROR at setup of test_get_init_creds_keytab _________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
________________ ERROR at setup of test_get_init_creds_password ________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
____________ ERROR at setup of test_get_init_creds_password_prompt _____________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
________ ERROR at setup of test_get_init_creds_password_prompt_failure _________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________________ ERROR at setup of test_get_creds_keytab ____________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________ ERROR at setup of test_get_creds_keytab_wrong_principal ____________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
________________ ERROR at setup of test_init_creds_set_password ________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
____________ ERROR at setup of test_init_creds_set_password_invalid ____________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
______________________ ERROR at setup of test_kt_default _______________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
____________________ ERROR at setup of test_kt_default_name ____________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
______________________ ERROR at setup of test_kt_get_name ______________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_____________________ ERROR at setup of test_kt_enumerate ______________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
__________________ ERROR at setup of test_kt_get_entry_empty ___________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_____________________ ERROR at setup of test_kt_get_entry ______________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
______________ ERROR at setup of test_kt_get_entry_multiple_kvno _______________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_____________ ERROR at setup of test_kt_get_entry_multiple_enctype _____________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_______________ ERROR at setup of test_kt_read_service_key_empty _______________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________ ERROR at setup of test_kt_read_service_key_multiple_kvno ___________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_________ ERROR at setup of test_kt_read_service_key_multiple_enctype __________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________________ ERROR at setup of test_kt_client_default ___________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
____________________ ERROR at setup of test_parse_principal ____________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________ ERROR at setup of test_parse_principal_no_realm_failure ____________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________________ ERROR at setup of test_unparse_principal ___________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
___________________ ERROR at setup of test_enctype_to_string ___________________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_______________ ERROR at setup of test_enctype_to_string_invalid _______________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
_______________ ERROR at setup of test_string_to_enctype_invalid _______________

    def realm() -> typing.Iterator[k5test.K5Realm]:
>       test_realm = k5test.K5Realm()
        try:
            original_env: typing.Dict[str, typing.Optional[str]] = {}
            for k in test_realm.env.keys():
                original_env[k] = os.environ.pop(k, None)
    
            try:
                os.environ.update(test_realm.env)
    
                yield test_realm
    
            finally:
                for k, v in original_env.items():
                    if v:
                        os.environ[k] = v
                    else:
                        del os.environ[k]
    
        finally:
            test_realm.stop()
            del test_realm
    
    
    @pytest.fixture(autouse=True)
    def requires_api(request: typing.Any) -> None:
        marker = request.node.get_closest_marker("requires_api")
        if marker:
            api_name = marker.args[0]
            if not hasattr(krb5, api_name):
                pytest.skip(f"KRB5 API {api_name} not available on current environment")
    
        return
    
    
    def pytest_configure(config: typing.Any) -> None:
        config.addinivalue_line(
            "markers",
            "requires_api(name): skip tests that don't have the required KRB5 API installed",

tests/conftest.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:166: in __init__
    self.create_kdb()
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:517: in create_kdb
    self.run([self.kdb5_util, "create", "-W", "-s", "-P", "master"])
.tox/graalpylibtest-unit-test-tests/lib/python3.10/site-packages/k5test/realm.py:339: in run
    proc = subprocess.Popen(
/opt/graalpy/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['/usr/sbin/kdb5_util', 'create', '-W', '-s', ...>
args = ['/usr/sbin/kdb5_util', 'create', '-W', '-s', '-P', 'master']
executable = b'/usr/sbin/kdb5_util', preexec_fn = None, close_fds = True
pass_fds = (), cwd = None
env = {'KPROPD_PORT': '61003', 'KPROP_PORT': '61003', 'KRB5CCNAME': '/tmp/tmp38l7tdvf-krbtest/ccache', 'KRB5RCACHEDIR': '/tmp/tmp38l7tdvf-krbtest', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = -1, c2pread = 16, c2pwrite = 17, errread = -1, errwrite = 17
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        # Truffle change
        if sys.platform == 'win32':
            if executable is None and len(args) == 1:
                import shlex
                executable = next(shlex.shlex(list2cmdline(args)))
                if executable.startswith('"') and executable.endswith('"'):
                    executable = executable[1:-1]
            if (len(args) == 1 and executable != args[0]) or shell:
                if not shell:
                    warnings.warn(f"Running\n\t{args[0]!r} in a cmd shell", RuntimeWarning)
                shell = False
                comspec = os.environ.get("COMSPEC", "cmd.exe")
                executable = comspec
                if len(args) == 1:
                    args = [comspec, "/u", "/c", *args]
                else:
                    args = [comspec, "/u", "/c", list2cmdline(args)]
            for idx, arg in enumerate(args):
                modified = False
                if '\n' in args[idx]:
                    # newlines are not passed correctly. the common case
                    # where we have arguments like this is python code, so
                    # assume that and hope for the best
                    args[idx] = args[idx].strip().replace('\n', ';')
                    modified = True
                if '"' in args[idx]:
                    args[idx] = list2cmdline(args[idx:idx + 1])
                    modified = True
                if modified:
                    warnings.warn(f"Replacing\n\t{arg!r}\nwith\n\t{args[idx]!r}", RuntimeWarning)
        # End Truffle change
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
            raise child_exception_type(err_msg)
    
    
    def _handle_exitstatus(self, sts,
                           waitstatus_to_exitcode=os.waitstatus_to_exitcode,
                           _WIFSTOPPED=os.WIFSTOPPED,
                           _WSTOPSIG=os.WSTOPSIG):
        """All callers to this function MUST hold self._waitpid_lock."""
        # This method is called (indirectly) by __del__, so it cannot
        # refer to anything outside of its local scope.
        if _WIFSTOPPED(sts):
            self.returncode = -_WSTOPSIG(sts)
        else:
            self.returncode = waitstatus_to_exitcode(sts)
    
    def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
            _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
        """Check if child process has terminated.  Returns returncode
        attribute.
    
        This method is called by __del__, so it cannot reference anything
        outside of the local scope (nor can any methods it calls).
    
        """
        if self.returncode is None:
            if not self._waitpid_lock.acquire(False):
                # Something else is busy calling waitpid.  Don't allow two
                # at once.  We know nothing yet.
                return None
            try:
                if self.returncode is not None:
                    return self.returncode  # Another thread waited.
                pid, sts = _waitpid(self.pid, _WNOHANG)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
            except OSError as e:
                if _deadstate is not None:
                    self.returncode = _deadstate
                elif e.errno == _ECHILD:
                    # This happens if SIGCLD is set to be ignored or
                    # waiting for child processes has otherwise been
                    # disabled for our process.  This child is dead, we
                    # can't get the status.
                    # http://bugs.python.org/issue15756
                    self.returncode = 0
            finally:
                self._waitpid_lock.release()
        return self.returncode
    
    
    def _try_wait(self, wait_flags):
        """All callers to this function MUST hold self._waitpid_lock."""
        try:
            (pid, sts) = os.waitpid(self.pid, wait_flags)
        except ChildProcessError:
            # This happens if SIGCLD is set to be ignored or waiting
            # for child processes has otherwise been disabled for our
            # process.  This child is dead, we can't get the status.
            pid = self.pid
            sts = 0
        return (pid, sts)
    
    
    def _wait(self, timeout):
        """Internal implementation of wait() on POSIX."""
        if self.returncode is not None:
            return self.returncode
    
        if timeout is not None:
            endtime = _time() + timeout
            # Enter a busy loop if we have a timeout.  This busy loop was
            # cribbed from Lib/threading.py in Thread.wait() at r71065.
            delay = 0.0005 # 500 us -> initial delay of 1 ms
            while True:
                if self._waitpid_lock.acquire(False):
                    try:
                        if self.returncode is not None:
                            break  # Another thread waited.
                        (pid, sts) = self._try_wait(os.WNOHANG)
                        assert pid == self.pid or pid == 0
                        if pid == self.pid:
                            self._handle_exitstatus(sts)
                            break
                    finally:
                        self._waitpid_lock.release()
                remaining = self._remaining_time(endtime)
                if remaining <= 0:
                    raise TimeoutExpired(self.args, timeout)
                delay = min(delay * 2, remaining, .05)
                time.sleep(delay)
        else:
            while self.returncode is None:
                with self._waitpid_lock:
                    if self.returncode is not None:
                        break  # Another thread waited.
                    (pid, sts) = self._try_wait(0)
                    # Check the pid and loop as waitpid has been known to
                    # return 0 even without WNOHANG in odd situations.
                    # http://bugs.python.org/issue14396.
                    if pid == self.pid:
                        self._handle_exitstatus(sts)
        return self.returncode
    
    
    def _communicate(self, input, endtime, orig_timeout):
        if self.stdin and not self._communication_started:
            # Flush stdio buffer.  This might block, if the user has
            # been writing to .stdin in an uncontrolled fashion.
            try:
                self.stdin.flush()
            except BrokenPipeError:
                pass  # communicate() must ignore BrokenPipeError.
            if not input:
                try:
                    self.stdin.close()
                except BrokenPipeError:
                    pass  # communicate() must ignore BrokenPipeError.
    
        stdout = None
        stderr = None
    
        # Only create this mapping if we haven't already.
        if not self._communication_started:
            self._fileobj2output = {}
            if self.stdout:
                self._fileobj2output[self.stdout] = []
            if self.stderr:
                self._fileobj2output[self.stderr] = []
    
        if self.stdout:
            stdout = self._fileobj2output[self.stdout]
        if self.stderr:
            stderr = self._fileobj2output[self.stderr]
    
        self._save_input(input)
    
        if self._input:
            input_view = memoryview(self._input)
    
        with _PopenSelector() as selector:
            if self.stdin and input:
                selector.register(self.stdin, selectors.EVENT_WRITE)
            if self.stdout and not self.stdout.closed:
                selector.register(self.stdout, selectors.EVENT_READ)
            if self.stderr and not self.stderr.closed:
                selector.register(self.stderr, selectors.EVENT_READ)
    
            while selector.get_map():
                timeout = self._remaining_time(endtime)
                if timeout is not None and timeout < 0:
                    self._check_timeout(endtime, orig_timeout,
                                        stdout, stderr,
                                        skip_check_and_raise=True)
                    raise RuntimeError(  # Impossible :)
                        '_check_timeout(..., skip_check_and_raise=True) '
                        'failed to raise TimeoutExpired.')
    
                ready = selector.select(timeout)
                self._check_timeout(endtime, orig_timeout, stdout, stderr)
    
                # XXX Rewrite these to use non-blocking I/O on the file
                # objects; they are no longer using C stdio!
    
                for key, events in ready:
                    if key.fileobj is self.stdin:
                        chunk = input_view[self._input_offset :
                                           self._input_offset + _PIPE_BUF]
                        try:
                            self._input_offset += os.write(key.fd, chunk)
                        except BrokenPipeError:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        else:
                            if self._input_offset >= len(self._input):
                                selector.unregister(key.fileobj)
                                key.fileobj.close()
                    elif key.fileobj in (self.stdout, self.stderr):
                        data = os.read(key.fd, 32768)
                        if not data:
                            selector.unregister(key.fileobj)
                            key.fileobj.close()
                        self._fileobj2output[key.fileobj].append(data)
    
        self.wait(timeout=self._remaining_time(endtime))
    
        # All data exchanged.  Translate lists into strings.
        if stdout is not None:
            stdout = b''.join(stdout)
        if stderr is not None:
            stderr = b''.join(stderr)
    
        # Translate newlines, if requested.
        # This also turns bytes into strings.
        if self.text_mode:
            if stdout is not None:
                stdout = self._translate_newlines(stdout,
                                                  self.stdout.encoding,
                                                  self.stdout.errors)
            if stderr is not None:
                stderr = self._translate_newlines(stderr,
                                                  self.stderr.encoding,
                                                  self.stderr.errors)
    
        return (stdout, stderr)
    
    
    def _save_input(self, input):
        # This method is called from the _communicate_with_*() methods
        # so that if we time out while communicating, we can continue
        # sending input if we retry.
        if self.stdin and self._input is None:
            self._input_offset = 0
            self._input = input
            if input is not None and self.text_mode:
                self._input = self._input.encode(self.stdin.encoding,
                                                 self.stdin.errors)
    
    
    def send_signal(self, sig):
        """Send a signal to the process."""
        # bpo-38630: Polling reduces the risk of sending a signal to the
        # wrong process if the process completed, the Popen.returncode
        # attribute is still None, and the pid has been reassigned
        # (recycled) to a new different process. This race condition can
        # happens in two cases.
        #
        # Case 1. Thread A calls Popen.poll(), thread B calls
        # Popen.send_signal(). In thread A, waitpid() succeed and returns
        # the exit status. Thread B calls kill() because poll() in thread A
        # did not set returncode yet. Calling poll() in thread B prevents
        # the race condition thanks to Popen._waitpid_lock.
        #
        # Case 2. waitpid(pid, 0) has been called directly, without
        # using Popen methods: returncode is still None is this case.
        # Calling Popen.poll() will set returncode to a default value,
        # since waitpid() fails with ProcessLookupError.
        self.poll()
        if self.returncode is not None:
            # Skip signalling a process that we know has already died.
            return
    
        # The race condition can still happen if the race condition
        # described above happens between the returncode test
        # and the kill() call.
        try:
            os.kill(self.pid, sig)
        except ProcessLookupError:
            # Supress the race condition error; bpo-40550.
            pass
    
    def terminate(self):
        """Terminate the process with SIGTERM
        """
        self.send_signal(signal.SIGTERM)
    
    def kill(self):
        """Kill the process with SIGKILL
        """
E       FileNotFoundError: [Errno 2] No such file or directory: '/usr/sbin/kdb5_util'

/opt/graalpy/lib/python3.10/subprocess.py:1879: FileNotFoundError
=========================== short test summary info ============================
ERROR tests/test_ccache.py::test_cc_default - FileNotFoundError: [Errno 2] No...
ERROR tests/test_ccache.py::test_cc_default_name - FileNotFoundError: [Errno ...
ERROR tests/test_ccache.py::test_cc_store_cred - FileNotFoundError: [Errno 2]...
ERROR tests/test_ccache.py::test_cc_switch - FileNotFoundError: [Errno 2] No ...
ERROR tests/test_ccache.py::test_cc_cache_match - FileNotFoundError: [Errno 2...
ERROR tests/test_ccache.py::test_cc_retrieve_remove_cred - FileNotFoundError:...
ERROR tests/test_context.py::test_set_default_realm - FileNotFoundError: [Err...
ERROR tests/test_creds.py::test_get_init_creds_keytab - FileNotFoundError: [E...
ERROR tests/test_creds.py::test_get_init_creds_password - FileNotFoundError: ...
ERROR tests/test_creds.py::test_get_init_creds_password_prompt - FileNotFound...
ERROR tests/test_creds.py::test_get_init_creds_password_prompt_failure - File...
ERROR tests/test_creds.py::test_get_creds_keytab - FileNotFoundError: [Errno ...
ERROR tests/test_creds.py::test_get_creds_keytab_wrong_principal - FileNotFou...
ERROR tests/test_creds.py::test_init_creds_set_password - FileNotFoundError: ...
ERROR tests/test_creds.py::test_init_creds_set_password_invalid - FileNotFoun...
ERROR tests/test_kt.py::test_kt_default - FileNotFoundError: [Errno 2] No suc...
ERROR tests/test_kt.py::test_kt_default_name - FileNotFoundError: [Errno 2] N...
ERROR tests/test_kt.py::test_kt_get_name - FileNotFoundError: [Errno 2] No su...
ERROR tests/test_kt.py::test_kt_enumerate - FileNotFoundError: [Errno 2] No s...
ERROR tests/test_kt.py::test_kt_get_entry_empty - FileNotFoundError: [Errno 2...
ERROR tests/test_kt.py::test_kt_get_entry - FileNotFoundError: [Errno 2] No s...
ERROR tests/test_kt.py::test_kt_get_entry_multiple_kvno - FileNotFoundError: ...
ERROR tests/test_kt.py::test_kt_get_entry_multiple_enctype - FileNotFoundErro...
ERROR tests/test_kt.py::test_kt_read_service_key_empty - FileNotFoundError: [...
ERROR tests/test_kt.py::test_kt_read_service_key_multiple_kvno - FileNotFound...
ERROR tests/test_kt.py::test_kt_read_service_key_multiple_enctype - FileNotFo...
ERROR tests/test_kt.py::test_kt_client_default - FileNotFoundError: [Errno 2]...
ERROR tests/test_principal.py::test_parse_principal - FileNotFoundError: [Err...
ERROR tests/test_principal.py::test_parse_principal_no_realm_failure - FileNo...
ERROR tests/test_principal.py::test_unparse_principal - FileNotFoundError: [E...
ERROR tests/test_string.py::test_enctype_to_string - FileNotFoundError: [Errn...
ERROR tests/test_string.py::test_enctype_to_string_invalid - FileNotFoundErro...
ERROR tests/test_string.py::test_string_to_enctype_invalid - FileNotFoundErro...
=================== 44 passed, 2 skipped, 33 errors in 7.14s ===================
ERROR: InvocationError for command /workdir/krb5-0.5.0/.tox/graalpylibtest-unit-test-tests/bin/python -m pytest -v (exited with code 1)
___________________________________ summary ____________________________________
ERROR:   graalpylibtest-unit-test-tests: commands failed
